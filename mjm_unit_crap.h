#ifndef MJM_UNIT_CRAP_H__
#define MJM_UNIT_CRAP_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

// should just be ragged table but allows more saving. 
//#include "mjm_ragged_forms.h"
#include "mjm_collections.h"
#include "mjm_string_tokenizer.h"
#include "mjm_read_buffer.h"
#include "mjm_indexed_map.h"
// a shadow converter for replacement 
// it uses the unit_desc here however so this not work... 
#include "mjm_unit_desc_crap.h"
#include "mjm_simple_units.h"
//#include "mjm_constrained_file.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <cstdlib>


// Sun Aug 30 10:55:15 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_unit_crap   
// g++ -Wall -std=gnu++11 -DTEST_MJM_UNIT_CRAP -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_unit_crap.h  -lpthread -lreadline


#if 0
// fudding stream operators here fudd 
class _mjm_unit_string
{
typedef _mjm_unit_string Myt;
typedef std::string StrTy;
typedef unsigned int IdxTy;

public:
_mjm_unit_string( ) {  } 
_mjm_unit_string(const char * u ) { Parse(StrTy(u)); } 
_mjm_unit_string(const StrTy & u ) { Parse(u); } 
// if u has a thing it may need to be parsed... 
_mjm_unit_string(const StrTy & u, const StrTy & t )
: m_unit(u), m_thing(t) {m_cstr=String();   } 
_mjm_unit_string(const StrTy & u, const StrTy & t,const IdxTy flags )
 {
Parse(u);
if ((m_thing=="")||Bit(flags,0)) m_thing=t; 
m_cstr=String();   } 

// some reason to return a copy?
const StrTy& unit() const { return m_unit; }
const StrTy& thing() const { return m_thing; }
const StrTy& string()const  { return m_cstr; } 
// these may need to conform or be specialized later
bool thing_if(const StrTy & u ) {const bool x=has_thing(); 
if (!x) {  m_thing=u; String(); } return x;    } 

void thing(const StrTy & x ) {m_thing=x; String(); }  
void unit(const StrTy & x ) {m_unit=x; String(); }  

const char * c_str() const { return m_cstr.c_str(); } 
bool operator<(const Myt & x)const  { return string()<StrTy(x); }  
bool operator==(const Myt & x)const  { return string()==StrTy(x); }  
bool same_thing(const Myt & x)const  { return m_thing==x.m_thing; }  
bool same_unit(const Myt & x)const  { return m_unit==x.m_unit; }  
operator StrTy() const { return String(); } 

private:
bool Bit(const IdxTy f, const IdxTy b) const { return (f&(1<<b))!=0; } 
bool has_thing() const { return m_thing.length()!=0; } 
StrTy   String()  const 
{
if (!has_thing())  m_cstr= m_unit;
//else m_cstr= m_unit+StrTy("~")+m_thing;
else m_cstr= m_unit+StrTy("~\"")+m_thing+"\"";;
return m_cstr;
}
void Parse(const StrTy & ut)
{
// could use loo parse or read buff but ok for now.
const IdxTy sz=ut.length();
char c[sz+2];
const char * p=ut.c_str();
IdxTy pc=0, loc=~0;
while (*p!=0)
{
if (*p=='~'){ c[pc]=0; loc=pc; }  else c[pc]=(*p);
++p;
++pc;
} // while 
c[pc]=0;
m_unit=StrTy(c);
if (loc!=~0U) m_thing=StrTy(c+loc+1);
m_cstr=String();
} // Parse

StrTy m_unit, m_thing;
mutable StrTy m_cstr;
}; // _mjm_unit_string

//static 
std::ostream & operator<<(std::ostream & os,const _mjm_unit_string & s ) { os<<s.string(); return os; }  

#endif

template <class Tr>
class mjm_unit_crap 
{
 typedef mjm_unit_crap Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef string_tokenizer St;
typedef St::coded_type Co;
typedef mjm_read_buffer<Tr>  Rb;

typedef _mjm_unit_string mjm_unit_string;

typedef mjm_simple_units<Tr> SimpleUnits;




//typedef std::map<StrTy,int> Powers;
typedef mjm_unit_string PowerKey;
typedef std::map<PowerKey,int> Powers;
public:



//typedef ConvEntry conv_type;
typedef typename SimpleUnits::conv_type conv_type;
//typedef ConvEntry conversion_type;
typedef typename SimpleUnits::conversion_type conversion_type;
//typedef std::vector<conv_type> Vc;
typedef typename SimpleUnits::Vc  Vc;
//typedef ValueClass dimmed_value_type;
typedef typename SimpleUnits::dimmed_value_type dimmed_value_type;



typedef mjm_unit_string power_key_type;
StrTy base_unit(const StrTy & x) { return x; }
StrTy base_thing(const StrTy & x) { return StrTy(); }
StrTy base_unit(const power_key_type & x) { return x.unit(); }
StrTy base_thing(const power_key_type & x) { return x.thing(); }

private:

#if 0
class _parse_rational_expression
{

typedef  _parse_rational_expression Myt;
public:
_parse_rational_expression() { }
// TODO m_sfx botched with operations 

_parse_rational_expression(const char * exp) { m_sfx=exp;  Parse(exp); }
//_parse_rational_expression(const StrTy &  exp) { Parse(exp.c_str()); }
_parse_rational_expression(const StrTy &  exp){m_sfx=exp; Parse(exp.c_str());}
// the units are a slopy ratio like mg/kg. Apply one "thing" to numberator
// and another to bottom. 
_parse_rational_expression(const StrTy &  exp, const StrTy & top, const StrTy & bot
){m_sfx=exp; Parse(exp.c_str(),top,bot);}
Myt operator/(const Myt & that) const { return Div(that); } 
Myt operator*(const Myt & that) const { return Div(that,1,'*'); } 
int cancel() { return Cancel(); } 
void flip() { Flip(); } 
int  ratio(const Myt & that) const { return Ratio(that); } 
// if anyone has modified the power map, need to make it private
// TODO FIXME 
//const StrTy&  sfx() const { return m_sfx; }
// TODO this needs to be fixed, people can't go modify the
// power table and m_sfx needs to be current doh 
const StrTy  sfx() const { return Sfx(); }
StrTy  usfx() const { return Sfx(); }
StrTy  dump() const { return Dump(); }
bool equiv(const Myt & that) const { return Equiv(that); } 
// make a copy 
Powers powers() const { return m_pow; } 
int keys( ) const  { return m_pow.size(); } 
IdxTy size() const { return m_pow.size(); } 
void add(const power_key_type & x, const int d) { m_pow[x]+=d; } 

// should return false if changed. 
bool thing_if(const StrTy & nm, const StrTy & t )
{ return ThingIf(nm,t); } 
int power(const StrTy & nm ) const  { return Power(nm); } 
enum list_bits { UNITS=0, THINGS=1,NAMES=2,
DEAD=3,DEN=4,DEN2=5, NUM=6,NUM2=7,BLANKTHING=8,NONBLANKTHING=9, PUNIT=10, PTHING=11 };
template <class Tv> void all_list(Tv & x, const IdxTy flags,const StrTy & p="")
{ AllList(x,flags,p); } 
private:
bool Bit(const IdxTy f, const IdxTy b) const { return (f&(1<<b))!=0; } 
template <class Tv> void AllList(Tv & x, const IdxTy flags,const StrTy  &p)
{
const bool units=Bit(flags,UNITS); 
const bool things=Bit(flags,THINGS); 
const bool cs=Bit(flags,NAMES); 
const bool dead=Bit(flags,DEAD); 
const bool den=Bit(flags,DEN); 
const bool den2=Bit(flags,DEN2); 
const bool num=Bit(flags,NUM);
const bool num2=Bit(flags,NUM2);
const bool all=!(dead||num||den||num2||den2);  
const bool blankthings=Bit(flags,BLANKTHING);
const bool pthing=Bit(flags,PTHING);
const bool punit=Bit(flags,PUNIT);
const bool nonblankthings=Bit(flags,NONBLANKTHING);
const bool allthings=!(punit||pthing||blankthings||nonblankthings);
//MM_ERR(" xxxxx "<<MMPR4(flags,units,things,cs)<<MMPR4(dead,den,den2,num) <<MMPR4(num2,all,blankthings,pthing)<<MMPR3(punit,nonblankthings,allthings))
MM_LOOP(ii,m_pow)
{
const PowerKey pk=(*ii).first;
const StrTy& u=pk.unit();
const StrTy& t=pk.thing();
const StrTy& c=pk.string();
const int d=(*ii).second;
bool cat_ok=all;
if ((d==0)&&dead) { cat_ok=true; }
else if ((d<0)&&den) { cat_ok=true; }
else if ((d>0)&&num) { cat_ok=true; }
else if ((d>1)&&num2) { cat_ok=true; }
else if ((d<(-1))&&den2) { cat_ok=true; }
//MM_ERR(MMPR3(cat_ok,d,u))
if (!cat_ok) continue;
bool things_ok=allthings;
if (blankthings) { things_ok=(t==""); }
else if (nonblankthings) { things_ok=(t!=""); }
else if (pthing)  { things_ok=(t==p); }
else if (punit)  { things_ok=(u==p); }
//MM_ERR(MMPR3(things_ok,d,u))

if (!things_ok) continue;
if (units) x.push_back(u);
if (things) x.push_back(t);
if (cs) x.push_back(c);


} // ii 

} // AllList


// should return false if changed. 
bool ThingIf(const StrTy & nm, const StrTy & t )
{ auto ii=m_pow.find(nm); 
if(ii=m_pow.end()) return  !false; return (*ii).second.thing_if(t); } 
int Power(const StrTy & nm ) const 
{
auto xx=m_pow.find(nm);
if (xx==m_pow.end()) return 0;
return (*xx).second; 
}
StrTy Dump() const
{
//const Powers & p=m_pow;
Ss ss; 
ss<<usfx(); 
//MM_LOOP(ii,p){ss<<m_st((*ii).first) <<"^"<<(*ii).second;  }
//MM_LOOP(ii,p){ss<<((*ii).first) <<"^"<<(*ii).second;  }
return ss.str(); 
} // DUmp
bool Equiv(const Myt & that) const 
{ return this->E(that)&&that.E(*this); }  // Equiv
bool E(const Myt & that) const { 
const Powers & p=m_pow;
const Powers & q=that.m_pow;
//bool e=true;
MM_LOOP(ii,p) { int c=(*ii).second; 
if (!c) continue;
const auto jj=q.find((*ii).first);
if (jj==q.end()) return false;
if (c!=(*jj).second) return false;
} // ii
return true;
} // E

// keep positives on left, negatives precede with slash. 
// no negative exponents 
StrTy Sfx() const
{
const Powers & p=m_pow;
std::map<int, std::vector< StrTy > > omap;
MM_LOOP(ii,p){omap[-(*ii).second].push_back((*ii).first);  }
Ss ss; 
IdxTy ip=0;
MM_LOOP(ii,omap)
{
int n=-(*ii).first;
if (n==0) continue;
if (n==1) {MM_LOOP(jj,(*ii).second) 
	{  if (ip!=0) ss<<"-"; ss<<(*jj) ; ++ip; } continue;}
if (n>1) {MM_LOOP(jj,(*ii).second) 
	{  if (ip!=0) ss<<"-"; ss<<(*jj)<<"^"<<n ; ++ip; } continue;}
if (n== -1) {MM_LOOP(jj,(*ii).second) 
	{  if (ip==0) ss<<"1"; ss<<"/"<<(*jj) ; ++ip; } continue;}
{MM_LOOP(jj,(*ii).second) 
{  if (ip==0) ss<<"1"; ss<<"/"<<(*jj)<<"^"<<(-n ); ++ip; } continue;}
}// ii  
return ss.str(); 
} // Sfx



class ParseTree
{
typedef PowerKey Pk;
public:
ParseTree(const IdxTy a=0):m_op(0),l(0),r(0),m_ambig(a) {}
ParseTree(const char * x,const IdxTy a=0 ):m_op(0),l(0),r(0),m_ambig(a) {m_p[x]=1; }
ParseTree(const StrTy &  x, const IdxTy a=0 ):m_op(0),l(0),r(0),m_ambig(a) {m_p[x]=1; }
ParseTree(const StrTy &  x,ParseTree * _l,ParseTree * _r, const IdxTy a=0 )
:m_op(0),l(_l),r(_r),m_ambig(a) {m_p[x]=1; }

void newleft() { l = new ParseTree(); }
void freeleft() {delete  l ; l=0;  }
void newright() { r = new ParseTree(); }
void freeright() {delete  r ; r=0;  }
void addleft() {MM_LOOP(ii,l->m_p) { m_p[(*ii).first]+=(*ii).second; }  }
void addright() {MM_LOOP(ii,r->m_p) { m_p[(*ii).first]+=(*ii).second; }  }
void subleft() {MM_LOOP(ii,l->m_p) { m_p[(*ii).first]-=(*ii).second; }   }
void subright() {MM_LOOP(ii,r->m_p) { m_p[(*ii).first]-=(*ii).second; }   }
void subright(const StrTy & tb) 
{MM_LOOP(ii,r->m_p) { 
m_p[(*ii).first]-=(*ii).second; }   
}
void mult(const int p ) {MM_LOOP(ii,m_p) { m_p[(*ii).first]*=p; }  }
void add(const StrTy & n, const int d) { m_p[n]+=d; }
void add(const StrTy & n, const StrTy & thing, const int d) 
{ m_p[Pk(n,thing,m_ambig)]+=d; }
const IdxTy size() const { return m_p.size(); }
int  val() const 
{
auto ii=m_p.begin();
if (ii!=m_p.end())  return atoi((*ii).first.c_str()); 
return 0;
}
char m_op;
Powers m_p;
ParseTree *l, *r;
IdxTy m_ambig;
}; // ParseTree

class ParseState
{
typedef ParseState Myt;
public:
ParseState(): e(0),i(0),len(0) {}
ParseState(const char * e) {this->e=e;  i=0; len=strlen(e); }
ParseState(ParseState * ps) { e=ps->e; i=ps->i; len=ps->len; }
const char c() const { return e[i]; } 
Myt & operator++() { ++i; return *this; } 
operator bool() const { return i<len; }   
const char * e;
IdxTy i,len;
}; // ParseState
// treat - as * 
// recognize -,*,/,^ should use charclass lut however. 
// needs to accept () 

void Add(ParseTree * pt, Rb & nm, const int d=1)
{
nm.cap();
if (nm[0][0]!=0) pt->add(StrTy(nm[0]),d); 
nm.clear();
} // Add 3

void Add(ParseTree * pt, Rb & nm, const StrTy & thing, const int d=1)
{
nm.cap();
if (nm[0][0]!=0) pt->add(StrTy(nm[0]),thing,d); 
nm.clear();
} // Add 4 


void Add(ParseTree * pt, const StrTy  & nm, const StrTy & thing, const int d=1)
{
if (nm.length()!=0) pt->add(nm,thing,d); 
} // Add 4 


int number( const char * exp, ParseState & ps )
{
int j=0;
bool neg=false;
int i=0;
while (ps)
{
const char c=ps.c(); 
if (c==0) return neg?(-j):j;
if (i==0) if (c=='-'){ ++ps;  ++i;  neg=true; continue; } 
if (c<='9') if (c>='0') { ++ps;  ++i; j=j*10+(c-'0'); continue; } 
return neg?(-j):j;

} // true;
return neg?(-j):j;
} // number 
void Partial(ParseTree * pt, const char * exp, ParseState & ps )
{
bool quote=false;
Rb rb;
rb.clear();
rb.mark();
while (ps)
{
const char c=ps.c();
++ps;
if (quote)
{
if (c=='"')  quote=false; 
else rb.append(c); 
continue;
} // quote
if (c==' ') {  continue; } 
if (c=='"') {  quote=true; } 
else if (c=='(') { Add(pt,rb);  pt->newleft(); Partial(pt->l,exp,ps); 
pt->addleft();
pt->freeleft();  }
else if (c==')' )  {Add(pt,rb); } 
else if (c=='-')  { Add(pt,rb); } 
else if (c=='*')  { Add(pt,rb); } 
else if (c=='^')  { 
Add(pt,rb,1);
//pt->newright(); 
int d=number(exp,ps);
//Partial(pt->r,exp,ps);  // this needs to eval to number
//int d=pt->r->val();
pt->mult(d);
//Add(pt,rb,d); 
//pt->freeright(); 
}  // ^
else if (c=='/')  { 
Add(pt,rb);
pt->newright(); Partial(pt->r,exp,ps);  // this needs to eval to number
pt->subright();
pt->freeright(); }  // ^
else rb.append(c); // a colon shoult fall through for ", grams:foo, now tilde not colon,  units OF something"
} // ps 
Add(pt,rb);
if ((pt->l)|| (pt->r)) MM_ERR(" still have kids ")

} // Partial 
///////////////

void Partial(ParseTree * pt, const char * exp, const StrTy & top, const StrTy & bot, ParseState & ps )
{
Rb rb;
rb.clear();
rb.mark();
while (ps)
{
const char c=ps.c();
++ps;
if (c==' ') {  continue; } 
if (c=='(') { Add(pt,rb,top);  pt->newleft(); Partial(pt->l,exp,top,bot,ps); 
pt->addleft();
pt->freeleft();  }
else if (c==')' )  {Add(pt,rb,top); } 
else if (c=='-')  { Add(pt,rb,top); } 
else if (c=='*')  { Add(pt,rb,top); } 
else if (c=='^')  { 
const StrTy nm=rb[0];
//Add(pt,rb,top,1);
//pt->newright(); 
int d=number(exp,ps);
//Partial(pt->r,exp,ps);  // this needs to eval to number
//int d=pt->r->val();
Add(pt,nm,(d>0)?top:bot,d);
//pt->mult(d);
//Add(pt,rb,d); 
//pt->freeright(); 
}  // ^
else if (c=='/')  { 
Add(pt,rb,top);
//const StrTy nm=rb[0];
pt->newright(); Partial(pt->r,exp,bot,top,ps);  // this needs to eval to number
pt->subright(bot);
pt->freeright(); }  // ^
else rb.append(c); // a colon shoult fall through for ", grams:foo, now tilde not colon,  units OF something"
} // ps 
Add(pt,rb,top);
if ((pt->l)|| (pt->r)) MM_ERR(" still have kids ")

} // Partial 


///////////////

void Parse(const char * exp)
{
ParseState ps(exp);
ParseTree pt;
Partial(&pt,m_exp.c_str(),ps);
Ss ss; 
MM_LOOP(ii,(pt.m_p)) {  ss<<(*ii).first<<"^"<<(*ii).second; }
//MM_ERR("parsing "<<MMPR(ss.str()))
m_pow=pt.m_p;
}
void Parse(const char * exp,const StrTy & top, const StrTy& bot)
{
ParseState ps(exp);
ParseTree pt;
Partial(&pt,m_exp.c_str(),top,bot,ps);
Ss ss; 
MM_LOOP(ii,(pt.m_p)) {  ss<<(*ii).first<<"^"<<(*ii).second; }
MM_ERR("parsing "<<MMPR(ss.str()))
m_pow=pt.m_p;
}


Myt Div(const Myt & that, const int p=-1, const char sym='/' ) const 
{ 
Myt x=*this;
Ss ss; ss<<x.m_exp ; ss<<(sym); ss<<that.m_exp;
x.m_exp=ss.str().c_str();
//x.m_exp=x.m_exp+StrTy(sym)+that.m_exp;
//MM_LOOP(ii,that.m_pow) { x.m_pow[(*ii).first]-=(*ii).second; }
MM_LOOP(ii,that.m_pow) { x.m_pow[(*ii).first]+=(*ii).second*p; }
return x; 
} // Div
int Cancel()
{
int n=0;
Powers _pow;
MM_LOOP(ii,m_pow) 
{ if ((*ii).second!=0){ ++n ;  _pow[(*ii).first]=(*ii).second; } } 
m_pow=_pow;
return n;
}
void Flip() { MM_LOOP(ii,m_pow) { m_pow[(*ii).first]=-(*ii).second; } } 

int  Ratio(const Myt & that) const 
{ 
Myt x=*this; // avoids inserting zero into map 
int low=0, high=0,rrx=0;
MM_LOOP(ii,that.m_pow) {
const int p1=(*ii).second;
if (p1==0) continue;
// this creates a zero if none before , using a copy
const int p2= x.m_pow[(*ii).first]; 
if (p2==0) continue;
const int ap1=(p1<0)?(-p1):p1;
const int ap2=(p2<0)?(-p2):p2;
const int r=(ap1>ap2)?(p1/p2):(p2/p1);
if (r>high) high=r;
if (r<low) low=r;
}
if(high!=0) if (low==0) rrx=high;
if(low!=0) if (high==0) rrx=low;
return rrx; 
} // Div


StrTy m_sfx; // questionable value, make the power map more readable.  
StrTy m_exp;
StrTy m_nanme;
public:
Powers m_pow;

}; // _parse_rational_expression
public:
typedef _parse_rational_expression ratio_parse;
protected:

typedef mjm_unit_desc_crap<Tr> _unit_desc;
//#if 0
class _unit_desc
{
typedef _unit_desc Myt;
typedef std::map<Co, Co > StrMap;
typedef std::map<StrTy, IdxTy > Aliases;
typedef std::map<Co, D > ConvMap; // qty???
typedef std::map<StrTy,int> Umap;

public:


typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef StrTy Word;
typedef string_tokenizer St;
// BAD refers to the quality of the abbreviation not the
// computer issues 
enum { ERROR, MULTIPLIER, BAD, EXTENSIVE, INTENSIVE };
_unit_desc() {}
_unit_desc(const Line & l, St & st) { Init(l, st); } 
const IdxTy & name() const { return m_name; }
const IdxTy & up() const { return m_up; }
bool upok() const { return m_up!=BadCo(); } 
bool downok() const { return m_down!=BadCo(); } 
const IdxTy & down() const { return m_down; }
const Aliases & labels() const { return m_aliases; } 
bool error() const { return m_error; } 
const StrTy &  error_string() const { return m_error_string; } 
bool unit() const { return false; }
bool multiplier() const { return false; }
bool acronym() const { return false; }
bool mfg() const { return false; }
D mconv(const IdxTy s ) const { return Mconv(s); } 
// caller has tokenizer if needed 
IdxTy type() const { return m_type; }
const StrTy & expansion() const  { return m_def; } 
template <class Tmap > 
bool bridge(D & v, const Myt & that, const Tmap & m ) const { return Bridge(v,that,m); } 
StrTy dump() const  { Ss ss; dump(ss,0); return ss.str(); }
StrTy dump(const St & st ) const  { Ss ss; dump(ss,st,0); return ss.str(); }
void dump(Ss & ss , const IdxTy flags=0) const { Dump(ss,flags); } 
void dump(Ss & ss , const St &st , const IdxTy flags=0) const  { Dump(ss,st,flags); } 
const Aliases & aka() const { return m_aliases; }
const ConvMap & conv_factors() const { return m_conv; } 
private:
//StrTyZZ
D Mconv(const IdxTy s) const
{
if (s==m_name) return 1; 
auto ii=m_conv.find(s);
if (ii==m_conv.end()) return 0;
return (*ii).second;

}
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
bool U(IdxTy & x, const Line & l, IdxTy & i, const IdxTy sz,St& st)
{ ++i; if (i>=sz) return false; x=st(l[i]); return true; }
bool U(StrTy & x, const Line & l, IdxTy & i, const IdxTy sz)
{ ++i; if (i>=sz) return false; x=l[i]; return true; }
bool UMap( const Line & l, IdxTy & i, const IdxTy sz, St& st)
{ ++i; if (i>=sz) return false; const StrTy & w=l[i]; 
Rb rb;
std::vector<Word> v;
rb.vectorize(v,w,',');
IdxTy vs=v.size();
if (vs&1)
{
m_error=true;
m_error_string=" convert string needs even number of elements  "+w; 
vs=vs-1;
//return false;
} // ==2
for(IdxTy i=0; i<vs; i+=2) m_conv[st(v[i])]=atof(v[i+1].c_str()); 

return !m_error; }
bool Labels( const Line & l, IdxTy & i, const IdxTy sz, St& st)
{ ++i; if (i>=sz) return false; const StrTy & w=l[i]; 
Rb rb;
std::vector<Word> v;
rb.vectorize(v,w,',');
MM_LOOP(ii,v) { m_aliases[(*ii)]=1;  } 
return true; }

bool UnitsRatio( const Line & l, IdxTy & i, const IdxTy sz, St& st)
{ ++i; if (i>=sz) return false; const StrTy & w=l[i]; 
ratio_parse rp=ratio_parse(w);
m_units=rp.m_pow;
return true; }




template <class Tmap > 
bool Bridge(D & v, const Myt & that, const Tmap & m ) const { 

// first see if they have a common base unit and types
// are compatible
if (m_base==that.m_base) 
{v=m_conv[that.m_base]/that.m_conv[m_base]; return true; } 
if (m_type!=that.m_type) return false; 
// try to find the conversion things in the map...


return false; 

} 

Co BadCo()const  { return ~0; } 

void Init(const Line & l, St & st ) 
{ 
m_error=false;
m_type=BadCo();
m_base=BadCo();
m_up=BadCo();
m_down=BadCo();
Rb m_scratch;
const IdxTy sz=l.size();
if (sz==0) return ; 
m_name=st(l[0]);
m_base=m_name; // BadCo();
for(IdxTy i=1; i<sz; ++i)
//for(IdxTy i=0; i<sz; ++i)
{
if (m_error) break; 
const Word & w=l[i];
if (w=="text"){  U(m_text,l,i,sz); continue;}
if (w=="definiition"){  U(m_def,l,i,sz); continue;}
// 
if (w=="type"){  U(m_type,l,i,sz,st); continue;}
if (w=="system"){  U(m_system,l,i,sz); continue;}
if (w=="base"){  U(m_base,l,i,sz,st); continue;}
if (w=="up"){  U(m_up,l,i,sz,st); continue;}
if (w=="down"){  U(m_down,l,i,sz,st); continue;}
if (w=="units"){  U(m_units_string,l,i,sz); continue;}
if (w=="convert"){  UMap(l,i,sz,st); continue;}
// TODO save for conversion types 
//if (w=="equals"){  UMap(l,i,sz,st); continue;}
if (w=="aliases"){  Labels(l,i,sz,st); continue;}
//if (w=="units"){  Labels(l,i,sz,st); continue;}

} // i 

}  // Init 
void Dump(Ss & ss , const IdxTy flags=0) const
{
ss<<MMPR4(m_name,m_text,m_def,m_type);
ss<<MMPR2(m_up,m_down);
ss<<MMPR4(m_sfx_map.size(),m_conv.size(),m_error,m_error_string); 

}
void Dump(Ss & ss , const St & st, const IdxTy flags=0) const 
{
ss<<MMPR4(st(m_name),m_text,m_def,st(m_type));
ss<<MMPR2(st(m_up),st(m_down));
ss<<MMPR4(m_sfx_map.size(),m_conv.size(),m_error,m_error_string); 

}



// members 
Co m_name;
Aliases m_aliases;
StrTy m_text,m_def,m_units_string, m_system;
Co m_type,m_base,m_up,m_down ;
StrMap m_sfx_map;
ConvMap m_conv; // conversion factors for various names 
bool m_error;
StrTy m_error_string;
Umap  m_units;

friend mjm_unit_crap;

}; // _unit_desc
#endif

typedef typename  mjm_unit_base_crap<Tr>::_unit_desc _unit_desc;
typedef typename  mjm_unit_base_crap<Tr>::ratio_parse ratio_parse;


class _qty_dim
{
typedef _qty_dim Myt;
public:
typedef mjm_unit_crap::ratio_parse ratio_parse;
// uggh thought I could avoid these doh
_qty_dim() : m_d(0) {}
_qty_dim(const D & v ) : m_d(v) {}
_qty_dim(const IdxTy & v ) : m_d(v) {}
_qty_dim(const int  & v ) : m_d(v) {}

_qty_dim(const char * exp)
{ char * last; m_d=strtod(exp,&last);if (last==exp) m_d=1;  m_rp=ratio_parse(last); }
typedef Powers powers_map_type;
typedef Powers::key_type key_type;
_qty_dim(const D & v,const char * exp) { m_d=v; m_rp=ratio_parse(exp); } 
_qty_dim(const D & v,const StrTy &  exp) { m_d=v; m_rp=ratio_parse(exp); } 
_qty_dim(const StrTy &  exp)
{ char * last; m_d=strtod(exp.c_str(),&last); 
if (exp.c_str()==last) m_d=1;
m_rp=ratio_parse(last); }

_qty_dim(const StrTy &  exp,const StrTy & top, const StrTy & bot)
{ char * last; m_d=strtod(exp.c_str(),&last); 
if (exp.c_str()==last) m_d=1;
m_rp=ratio_parse(last,top,bot); }

D & qty() { return m_d; }
const D & qty() const { return m_d; }
key_type t_u_sfx() const { if ( powers().size()!=1) return key_type(sfx());
return ((*(powers().begin())).first);  } 
StrTy sfx() const { return m_rp.sfx(); } 
// wtf make two copies lol doh 
ratio_parse rp() const { return m_rp; } 
Powers powers() const { return m_rp.powers(); } 
int keys( ) const  { return m_rp.keys(); } 
const int power(const StrTy & p) const { return m_rp.power(p); } 
void set_qty(const D & x) { m_d=x; } 
void add_raw(const D & x) { m_d+=x; } 
void mult_raw(const D & x) { m_d*=x; } 
// operators defined by subclassed, use special things here. ..
Myt div(const Myt & t)
 {  Myt x; x.m_d=m_d/t.m_d; x.m_rp=m_rp/t.m_rp; x.m_rp.cancel();  return x; } 
Myt times(const Myt & t)
 {  Myt x; x.m_d=m_d*t.m_d; x.m_rp=m_rp*t.m_rp; x.m_rp.cancel();  return x; } 
bool lexi_lt(const Myt & x)  { return sfx()<x.sfx(); } 
StrTy dump() const
{ Ss ss; ss<<m_d<<m_rp.dump(); return ss.str(); } // dump
operator StrTy() const { return dump(); } 
D m_d;
ratio_parse m_rp;

}; // _qty_dim
#if 0

template <class Tos>  Tos& operator<<(Tos & os, const _qty_dim & q) 
{
os<<q.dump();
return os;
}
#endif

class _qty_ty : public _qty_dim
{
typedef _qty_ty Myt;
typedef _qty_dim Super;
enum { EMPTY=0, BADUNITS=1 } ;
public:
_qty_ty() : Super() {Init();  Set(EMPTY); }
// these could be empy with the wrong string values
// may want to check that TODO FIXME 
_qty_ty(const D & v ) : Super(v) {Init(); }
_qty_ty(const IdxTy & v ) : Super(v) {Init(); }
_qty_ty(const int  & v ) : Super(v) {Init(); }
_qty_ty(const char * exp) : Super(exp) {Init(); }
_qty_ty(const D & v,const char * exp): Super(v,exp)  {Init();   } 
_qty_ty(const D & v,const StrTy &  exp) : Super(v,exp) {Init();   } 
_qty_ty(const StrTy &  exp) : Super(exp) {Init(); }
bool empty() const { return Bit(m_state,EMPTY); } 
bool valid() const { return !Bit(m_state,BADUNITS); } 
void invalidate() { Set(BADUNITS); } 
bool adds_ok(const Myt & that) { return AddsOk(that); } 
Myt&  operator+=(const StrTy  & s)  { return PlusEq(s); } 
Myt & operator+(const Myt & that)const  { return Add(that); } 
Myt & operator+=(const Myt & that)  { return PlusEq(that); } 
Myt & operator*=(const D & x)  { shot()*=x; Clear(EMPTY);  } 
Myt  operator*(const D & x) const  {Myt y=(*this);  y.shot()*=x; return y;} 
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
void Set( const IdxTy b)   { m_state|=(1<<b); }
void Clear( const IdxTy b)  { m_state&=( ~(1<<b)); }
ratio_parse & fudd() { return Super::m_rp; }
const ratio_parse & fudd()const { return Super::m_rp; }
D & shot() { return Super::m_d; }
const D & shot() const  { return Super::m_d; }
bool AddsOk(const Myt & that) { 
if (that.empty()) return true; 
if (empty()) return true; 
return (fudd().equiv(that.fudd())); 
} // AddsOk  

Myt  Add(const Myt & that)const  
{ 
Myt & y=*this;
if (y.empty()) return that;
if (that.empty()) return y;
Myt x=y;
if(x.fudd().equiv(that.fudd())) { x.shot()+=that.shot(); } 
else MM_ERR(" stubbed  unable to add "<<MMPR2(x.sfx(),that.sfx()))

return x; 

} 
Myt& PlusEq(const Myt & that) 
{
if (that.empty()) return (*this); 
if(empty()) 
{ shot()+=that.shot(); fudd()=that.fudd(); 
if (debugg()) 
{ MM_ERR(" stubbed   "<<MMPR4(shot(),that.shot(),Super::sfx(),that.sfx())) }
 Clear(EMPTY); return (*this);  } 
if(!fudd().equiv(that.fudd()))  Set(BADUNITS); 
 shot()+=that.shot();  
if (debugg())
{
 MM_ERR(" stubbed   "<<MMPR4(shot(),that.shot(),Super::sfx(),that.sfx()))
}
return (*this); 
} // PlusEq
 
Myt & PlusEq(const StrTy  & s)   
{ Myt x(s); 
if (debugg()) {MM_ERR(" stubbed "<<MMPR2(x.qty(),x.sfx())) }

(*this)+=x; 
if(debugg()) {
 MM_ERR(" stubbed   "<<MMPR4(shot(),x.shot(),Super::sfx(),x.sfx()))
}

return *this; }

StrTy Dump(const IdxTy flags=0){Ss ss; Dump(ss,flags); return ss.str(); }
void Dump(Ss & ss, const IdxTy flags=0)
{
 }

void Init()
{
m_state=0; // 1<<EMPTY;


} // Init

IdxTy m_state;

}; // _qty_ty


public:
typedef _unit_desc unit_desc;
typedef _qty_dim qty_dim;
typedef _qty_ty qty_ty;
//typedef std::map<StrTy, unit_desc> units_map;
//typedef std::map<StrTy, unit_desc> units_map;
typedef mjm_indexed_map<Tr,unit_desc> units_map;
mjm_unit_crap() {}
~mjm_unit_crap() {}
// bool debugg()const  { return false; } 
static bool debugg()  { return false; } 
void fn(const StrTy & fn ) { m_fn=fn; }
IdxTy load() { return Load();} 
IdxTy save() { return Save();} 
IdxTy parse() { return Parse();} 
IdxTy size() const { return m_map.size(); }
void clear() { m_map.clear(); m_defs.clear();  }
qty_dim base(const StrTy & s )const { qty_dim x(s); return ToBase(x); } 
IdxTy to_base(qty_dim & x) const { return ToBase(x); } 
int auto_range(D & v, StrTy & sfx)  { return AutoRange(v,sfx); }  
void intensive (const StrTy & s )
{
ratio_parse rp= ratio_parse(s.c_str());

}
IdxTy plus_eq(qty_ty& d, const qty_ty& s) { return PlusEq(d,s); } 
// this needs to look up abbreviations 
// as well as whole names. 
bool have(const StrTy & s) { return Have(s); }
unit_desc * desc(const StrTy & s) { return m_map[s]; } 
IdxTy  to(D & r, const StrTy & to, const StrTy & from, const StrTy & v)
{ return To(r, to,from,v); } 
IdxTy  to(D & r, const char * to, const char *  from)
{ return To(r, to,from); } 

IdxTy  convert(D & d, const D & q, const StrTy &  to, const StrTy &  from,
const StrTy & rho)
{ return  Convert(d, q, to, from,rho); }
// return something in "r" with a return code
// Ideally the returned value has same units as "to" in ct
// although maybe not if rc!=0; Will use loaded units and
// local conversions in vc
typedef std::vector<StrTy> VcString;
IdxTy convert(dimmed_value_type & r, const conversion_type & ct
    , const VcString & vc, const IdxTy flags) const
{

return Convert(r,ct,vc,flags); 
} 
void dump(Ss & ss,const IdxTy flags=0) {  Dump(ss,flags); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; 
Dump(ss,flags); 
 return ss.str(); }
void Dump(Ss & ss, const IdxTy flags=0)
{
MM_ERR(MMPR(m_map.size()))
MM_LOOP(ii,m_map) {//MM_ERR(" dumping "); 

 (*ii).second.dump(ss,m_st); ss<<CRLF;  }
}

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
IdxTy Load() { 
m_defs.load(m_fn);
m_simple.load(m_fn);
return 0;

} 
IdxTy Save() { 
Ss ss;
ss<<m_defs.dump(3);
std::ofstream os(m_fn.c_str());
os<<ss.str();

return 0;

}
IdxTy Add(const Line & l)
{
unit_desc x(l,m_st);
if (x.error())
{
// if length is zero no error possible
Ss ss;
ss<<" error in line :";
MM_LOOP(ii,l) { ss<<" "<<(*ii);  }
ss<<CRLF;
if (l.size()>0)
MM_ERR(" bad units abbrv "<<MMPR2(l[0],x.error_string()))
else
MM_ERR(" error with zero length line wtf")
}
//m_map[m_st(x.name())]=x;
m_map.add_multi(m_st(x.name()),x.labels(),x);

} // Add
 
IdxTy Parse() { 
m_simple.parse(0);
Ragged & r= m_defs;
IdxTy lno=0;
MM_LOOP(ii,r)
{
const Line & l =(*ii);
if (l.size()==0)  { ++lno; continue; } 
if (l[0].c_str()[0]=='#') { ++lno; continue; } 
//MM_ERR(" parsing line "<<MMPR2(lno,l.size()))
unit_desc x(l,m_st);
if (x.error())
{
// if length is zero no error possible
if (l.size()>0)
MM_ERR(" bad units abbrv "<<MMPR3(lno,l[0],x.error_string()))
else
MM_ERR(" error with zero length line wtf")
}
//m_map[m_st(x.name())]=x;
m_map.add_multi(m_st(x.name()),x.labels(),x);
++lno;
} // ii 
return 0;

} // Parse
// FIXME this is dumb, if it is not zero then what?
bool Have(const StrTy & s) { return (m_map[s]!=0); }
IdxTy To(D & r, const StrTy & to, const StrTy & from, const StrTy & v)
{
unit_desc * in=m_map[from];
unit_desc * out=m_map[to];
if ( !in) return 1;
if (!out) return 2;
const D vin=atof(v.c_str());
const IdxTy ib=(*in).m_base;
const IdxTy  ob=(*out).m_base;
if (ib!=ob) {MM_ERR(" not chasing convert  chains "<<MMPR4(to,from,ib,ob)) } 
// the tokenizer is generally a waste here but
// may be useful in other places, with the right typedefs
// a dummy can be used 
//const D f=(*in).m_conv[((*in).m_base)]/(*out).m_conv[((*out).m_base)];
const D f=(*in).m_conv[ib]/(*out).m_conv[ob];
r=f*vin;
return 0;
}

IdxTy To(D & r, const StrTy & to, const StrTy & from)
{
unit_desc * in=m_map[from];
unit_desc * out=m_map[to];
if ( !in) return 1;
if (!out) return 2;
const IdxTy ib=(*in).m_base;
const IdxTy ob=(*out).m_base;
if (ib!=ob) {MM_ERR(" not chasing convert  chains "<<MMPR4(to,from,m_st(ib),m_st(ob))) } 
//const D f=(*in).m_conv[((*in).m_base)]/(*out).m_conv[((*out).m_base)];
const D f=(*in).m_conv[ib]/(*out).m_conv[ob];
r=f;
return 0;
}
StrTy  Rat(const Powers & p)
{
Ss ss; 
//MM_LOOP(ii,p){ss<<m_st((*ii).first) <<"^"<<(*ii).second;  }
MM_LOOP(ii,p){ss<<((*ii).first) <<"^"<<(*ii).second;  }
return ss.str(); 
}
// Convert each entry into its "base" unit or common
// one to make harmonization easier 
IdxTy ToBase(D & v, Powers & p) const
{
Powers pb;
MM_LOOP(ii,p)
{
// this just looks up units of units~thing
const PowerKey & pk=(*ii).first;
// this would work but want pieces anyway
//unit_desc * descp=m_map[(*ii).first];
// accessor was returnin a copy? 
const StrTy& u=pk.unit();
const StrTy& t=pk.thing();

const unit_desc * descp=m_map[u];
if (debugg()) MM_ERR(" ToBase map content  "<<MMPR4(descp,u,t,(*ii).second ))
if (!descp) 
{
MM_ERR(" unit not found die now "<<MMPR3(u,t,(*ii).second))
MM_LOOP(jj,p) {MM_ERR(" also have "<<MMPR2((*jj).first,(*jj).second)) }
return ~0;  } 
if (debugg()) MM_ERR(" ToBase map content  "<<MMPR4((*descp).dump(m_st),u,t,(*ii).second ))
// doh, this needs the power of the exponent... 
const int pi=(*ii).second;
if (pi==0){
MM_ERR(" have zero power cacneeeldle "<<MMPR2(pi,StrTy(pk)))
 continue; // should clean the map 
}
// these are tokenized. 
const IdxTy ib=(*descp).m_base;
//D vc=(*descp).m_conv[ib];
D vc=(*descp).mconv(ib);
if (vc==0) // no conversion found, m_base may be bad or missing factor 
{ pb[pk]+=pi;  
MM_ERR(" missing factor "<<MMPR((*descp).dump()))
} 
else { 
int pii=(pi<0)?(-pi):pi;
if (pi<0) vc=1.0/vc;
// note for high int power, sqrt may be best 
if (debugg()) { MM_ERR(" ToBase power xfer "<<MMPR4(pii,pi,vc,v))}
while  (pii>0) { v=v*vc; --pii; } 
//if (pi==1) v=v*vc; else if (pi== -1 ) v=v/vc; else if (pi==0) {}
//else v=v*::pow(vc,pi);
// the input units should condense to fewer base units. 
// this discards the "~" or "of" oart 
//pb[m_st(ib)]+=pi; // (*ii).second;
pb[PowerKey(m_st(ib),t)]+=pi; // (*ii).second;
} // vc!=0 convert ok 

} // ii 
// no assfudding dump shot fudd need a nfew fudding thing see Loo crap  
if (debugg()) { MM_ERR(" ToBase exit "<<MMPR2(fudd(p),fudd(pb)))}
p=pb;
return 0;
} // ToBase
template <class Tm >
StrTy fudd( const Tm & f) const 
{ Ss ss;
MM_LOOP(ii,f) { ss<<((*ii).first)<<"="<<(*ii).second<<" ";  } 
return ss.str();
}

IdxTy ToBase(qty_dim & qd)const { return  ToBase(qd.m_d, qd.m_rp.m_pow); } 

typedef typename SimpleUnits::conversion_type Ct;
typedef typename SimpleUnits::conv_type Cf;
typedef std::vector<Cf> RhoVec;
class term_class { public: term_class() {} 
term_class (const StrTy _u, const StrTy _t, const int s): u(_u),t(_t),p(s) {}  
StrTy u,t; int p; StrTy dump() const { Ss ss; ss<<MMPR3(u,t,p); return ss.str(); }  }; 
IdxTy StrToSimple(Cf & d, const StrTy & s) const
{
qty_dim sqd(s.c_str());
std::vector<term_class> terms;
MM_LOOP(ii,sqd.m_rp.m_pow) { terms.push_back(term_class( 
(*ii).first.unit(),(*ii).first.thing(),(*ii).second
)); } 
MM_LOOP(ii,terms) { MM_ERR(" TERMS "<<MMPR(s)<<MMPR((*ii).dump()))} 
D rv=sqd.qty(); // atof(cip.p1.c_str());
// the ctor should take the value now... 
Cf cf;
cf.v(rv);
MM_LOOP(ii,terms)
{
const term_class & f=(*ii);
if (f.p==1) cf.top(f.u,f.t);
if (f.p==-1) cf.bottom(f.u,f.t);
}
d=cf;
#if 0 
if (sqd.m_rp.m_pow.size()==2)
{
auto iir=(s.m_rp.m_pow.begin());
D rv=s.qty(); // atof(cip.p1.c_str());
const StrTy rtu=(*iir).first.unit();// cip.p2;
const StrTy rtt=(*iir).first.thing(); // cip.wif(3);
const int p0=(*iir).second;
++iir;
const StrTy rfu=(*iir).first.unit(); // cip.wif(4);
const StrTy rft=(*iir).first.thing(); // cip.wif(5);
const int p1=(*iir).second;
//if (p0>p1) 
//rv=1.0/rv; 
MM_ERR(MMPR4(rtu,rtt,p0,rv))
MM_ERR(MMPR4(rfu,rft,p1,rv))
Cf cf(rfu,rft,rtu,rtt,rv);
d=cf;
return 0; 
//facs.push_back(cf);
}// size is right 
#endif


return 0; 
} 
// create "r" according to conversion specified by ct
// using stored units and anything in vc that is needed
// return requested value of anything possible
//typedef std::vector<StrTy> VcString;
// the bastard usage for "ct" requires care... doh 
IdxTy Convert(dimmed_value_type & r, const conversion_type & ct
    , const VcString & vc, const IdxTy flags) const
{
const bool convert_DEBUG=!false;
RhoVec vcf;
MM_LOOP(ii,vc){
if (convert_DEBUG) { MM_ERR(MMPR((*ii))) } 
// a blank string converts ok but its a bad entry... 
// this is dumb the factor defaults to zero 
conv_type cf(0);  IdxTy tc=StrToSimple(cf,(*ii)); 
const bool ok=(tc==0)&&(cf.v()!=0)&&(cf.to_unit()!="");
if (convert_DEBUG) { MM_ERR(" considering "<<MMPR4(ok,tc,(*ii),cf.dump())) }

if (ok) vcf.push_back(cf); else MM_ERR(" ignoring "<<MMPR2((*ii),cf.dump())) }

return m_simple.convert(r,ct,vcf,flags); 
}

IdxTy  NewConvert(D & d, const D & q, const StrTy &  to, const StrTy &  from,
const StrTy & rho)
{
if (debugg()) { MM_ERR("enter NEW convert "<< MMPR4(q,to,from,rho)) } 
if (to==from) { d=q; return 0; } 
if (to.length()==0) { d=q; return ~0; } 
qty_dim toqd(1,to);
auto im=(toqd.m_rp.m_pow); // begin();
MM_ERR(MMPR(im.size()));
const bool have_to=(im.size());
auto ii=im.begin();
//const auto iif=(*(toqd.m_rp.m_pow.begin())).first;
const auto & iif=(*ii).first;
//const int p=(*(toqd.m_rp.m_pow.begin())).second;
const int p=have_to?(*ii).second:0;
const StrTy uto=have_to?iif.unit():StrTy();
const StrTy tto=have_to?iif.thing():StrTy();
MM_ERR(MMPR4(p,uto,tto,im.size()))
//const D v=toqd.qty(); 
qty_dim fromqd(q,from);
const auto mm=fromqd.m_rp.m_pow;
const bool have_from=mm.size();
MM_ERR(MMPR2(have_from,mm.size()))
const auto & iiff=(*(fromqd.m_rp.m_pow.begin())).first;
const int pf=have_from?(*(fromqd.m_rp.m_pow.begin())).second:0;
const StrTy ufrom=have_from?iiff.unit():StrTy();
const StrTy tfrom=have_from?iiff.thing():StrTy();
const D v=fromqd.qty(); 
RhoVec facs;
{
qty_dim rhoqd(rho.c_str());
 Cf cf;
IdxTy rcrho=StrToSimple(cf,rho);
if (rcrho==0) facs.push_back(cf);
}
#if 0
if (rhoqd.m_rp.m_pow.size()==2)
{
auto iir=(rhoqd.m_rp.m_pow.begin());
D rv=rhoqd.qty(); // atof(cip.p1.c_str());
const StrTy rtu=(*iir).first.unit();// cip.p2;
const StrTy rtt=(*iir).first.thing(); // cip.wif(3);
const int p0=(*iir).second;
++iir;
const StrTy rfu=(*iir).first.unit(); // cip.wif(4);
const StrTy rft=(*iir).first.thing(); // cip.wif(5);
const int p1=(*iir).second;
//if (p0>p1) 
//rv=1.0/rv; 
MM_ERR(MMPR4(rtu,rtt,p0,rv))
MM_ERR(MMPR4(rfu,rft,p1,rv))
Cf cf(rfu,rft,rtu,rtt,rv);
facs.push_back(cf);
}// size is right 
#endif


/*

Cf cf(fu,ft,tu,tt,v);
MM_ERR(MMPR(cf.dump()))
facs.push_back(cf);
continue;
}
if (cmd=="conv") {
// this is BACKWARDS 
const D v=atof(cip.p1.c_str());
const StrTy tu=cip.p2;
const StrTy tt=cip.wif(3);
const StrTy fu=cip.wif(4);
const StrTy ft=cip.wif(5);
//Ct cf(fu,ft,tu,tt,v);
Ct cf(tu,tt,fu,ft,v);


*/
//const D v=atof(cip.p1.c_str());
const StrTy tu=uto; // cip.p2;
const StrTy tt=tto; // cip.wif(3);
const StrTy fu=ufrom; // cip.wif(4);
const StrTy ft=tfrom; // cip.wif(5);
Ct cf(fu,ft,tu,tt,v);
//Ct cf(tu,tt,fu,ft,v);
MM_ERR(MMPR(cf.dump()))
//D vout=0;
//facs.push_back(cf);
//const IdxTy rc=x.convert(vout,cf,facs,0);
const IdxTy rc=m_simple.convert(d,cf,facs);
MM_ERR(MMPR3(d,rc,cf.dump()))
return rc; // DANGER WILL ROBINSON need to fix rc... 

} // NewConvert

// call with string vector of Qdim vector... 

// IdxTy Convert(dimmed_value_type & r, const conversion_type & ct
//    , const Vc & vc, const IdxTy flags) const




// gg/dump
IdxTy  Convert(D & d, const D & q, const StrTy &  to, const StrTy &  from,
const StrTy & rho)
{
if (debugg()) { MM_ERR("enter convert "<< MMPR4(q,to,from,rho)) } 
if (true) { return NewConvert(d,q,to,from,rho); } 
if (to==from) { d=q; return 0; } 
//if (to=="") { d=q; return 1; } 
// this would require a serving size to turns mass or volume into a "count"
//if (to.length()==0) { d=q; return ~0; } 
if (to.length()==0) { d=q; return 1; } 
// need a member element for caching, can't use static 
// with multiple instances 
qty_dim toqd(1,to);
const IdxTy rc4=ToBase(toqd);
// NB q added here doh  FUDD DOH ... 
qty_dim fromqd(q,from);
//MM_ERR(MMPR(fromqd.dump()))
const IdxTy rc2= ToBase(fromqd);
if (debugg()) { MM_ERR("to base forms "<<MMPR2(toqd.dump(),fromqd.dump())) } 
////////////////////////
if (debugg()) MM_ERR(MMPR4(from,fromqd.sfx(),to,toqd.sfx()))
if ((fromqd.sfx()!=from)|| (toqd.sfx()!=to))
{
//return  Convert(d,q/fromqd.qty()*toqd.qty(),toqd.sfx(),fromqd.sfx(),rho);
}

////////////////////////

//if (fromqd.m_rp.m_pow==toqd.m_rp.m_pow) 
if (fromqd.m_rp.equiv(toqd.m_rp))
{  // cache c here 
const D c=fromqd.m_d/toqd.m_d;
d=c;   if (debugg()) { MM_ERR(MMPR4(d,q,toqd.m_d,fromqd.m_d))  } 
return 0; } 
// wtf? 
if (rho.length()==0){ d=q;  return 1;  } 
qty_dim rhoqd(rho.c_str());
if (debugg()) { MM_ERR(MMPR(rhoqd.dump())) }
const IdxTy rc3= ToBase(rhoqd);
if (debugg()) { MM_ERR(MMPR2(toqd.m_d,rhoqd.dump())) } 
ratio_parse x=toqd.m_rp/fromqd.m_rp;
int rr=x.ratio(rhoqd.m_rp);
ratio_parse y;
D c=1.0/toqd.m_d*fromqd.m_d;
const D d1=c;
if (debugg()) MM_ERR(MMPR(rr)<<MMPR4(d1,q,toqd.dump(),fromqd.dump())) 
//if (rr==1) {  y=x/rhoqd.m_rp; c=c*rhoqd.m_d; }
//else if (rr== -1) {  y=x*rhoqd.m_rp; c=c/rhoqd.m_d; }
//else // this comes up when noun density is in private units. 
{
//int pt=rhoqd.power(to);
int pt=rhoqd.power(toqd.sfx());
//int pf=rhoqd.power(from);
int pf=rhoqd.power(fromqd.sfx());
int keys=rhoqd.keys();
Powers xp= rhoqd.powers();
//unit_desc * xpr[keys];
StrTy xpp[keys];
IdxTy i=0; 
MM_LOOP(ii,xp) 
{ 
xpp[i]=(*ii).first; // xpr[i]=m_map[(*ii).first];

 ++i; }
unit_desc * descp_to=m_map[to];
unit_desc * descp_from=m_map[from];
const bool can_do=
	(keys==2)&&((pt!=0)||(descp_to!=0)) &&((pf!=0)||(descp_from!=0));
// rhoqd was converted to a base but not to and from yet... 
if (debugg()) MM_ERR("check can do "<< MMPR3(to,from,rhoqd.dump())<<MMPR4(can_do,keys,pt,descp_to)<<MMPR2(pf,descp_from))
if (can_do) {
// have both just do it here... 
// DOH "q" is in the "from" part FUDD 
//if ((pt==1)&&(pf==(-1))) { d=q*rhoqd.m_d/toqd.qty()/fromqd.qty(); 
if ((pt==1)&&(pf==(-1))) { d=rhoqd.m_d/toqd.qty()*fromqd.qty(); 
MM_ERR(" actual conversion "<< MMPR4(d,q,rhoqd.m_d,toqd.qty())<<MMPR3(fromqd.qty(),fromqd.sfx(),toqd.sfx()))
return 0; }
// q is contained in from 
MM_ERR(" untested converstion code "<<MMPR(rhoqd.dump()))
if ((pf==1)&&(pt==(-1))) { d=1.0/rhoqd.m_d/toqd.qty()*fromqd.qty(); return 0; }

if (((pf==1)||(pf==-1))&&(descp_to!=0))
{
MM_ERR(" verify this path "<<MMPR3(q,rhoqd.m_d,(*descp_to).dump(m_st)))
const D qnew=(pf==1)?(q/rhoqd.m_d):(q*rhoqd.m_d);
IdxTy wi=0;
if (xpp[0]==from) wi=1;
const StrTy fromnew=xpp[wi];
MM_ERR(" bastard recurse "<<MMPR4(d,qnew,to,fromnew))
return  Convert( d,  qnew, to,  fromnew , StrTy(""));
} // pf!=0


}  // can_do
// generalize the recursive thing, this is a general appraoch. 

} // else rr  
// cache c here 
d=c;
//MM_ERR(MMPR2(d,c)<<MMPR4(y.dump(),v,rr,rhoqd.m_d))
if (debugg()) { MM_ERR(MMPR2(d,c)<<MMPR4(y.dump(),toqd.m_d,rr,rhoqd.m_d)) }
// its ok if the "ToBase" fails as the density may have the right factors...
return rc2|rc3|rc4; 
}
IdxTy PlusEq(qty_ty& d, const qty_ty& s) 
{ 
IdxTy rc=0;
if (d.adds_ok(s)) { d+=s; return rc; } 
// now try to fix the things
// this much is ok but s is const 
const IdxTy rc2= ToBase(d);
qty_ty sc=s;
const IdxTy rc3= ToBase(sc);
ratio_parse x=d.m_rp/sc.m_rp;


return rc; 
}  // PlusEq

int AutoRange(D & v, StrTy & sfx)  { 
int dx=0, iter=0;
bool oor=false;
do { 
++iter;
unit_desc * in=m_map[sfx];
MM_ERR(" FUDD "<<MMPR2(in,sfx))
if ( !in) return dx;
// returning "invalid" works ok but is confusing so just get it out...
bool upok=in->upok();
bool downok=in->downok();
oor=false;
D dup=0,ddown=0,q=1;
IdxTy rcup=0, rcdown=0;
StrTy up,down;
if (upok) {
up=m_st(in->up());
rcup= Convert( dup,  q, up, sfx,StrTy());
dup=1.0/dup;
}
if (downok) { 
down=m_st(in->down());
 rcdown= Convert( ddown,  q, down, sfx,StrTy()); 
ddown=1.0/ddown;
}
//if (debugg()) 
{
MM_ERR("FUDD " << MMPR4(iter,upok,downok,oor)<<MMPR4(sfx,up,dup,rcup)<<MMPR4(down,rcdown,ddown,v)) } 
const bool could_up=upok&& (dup>0) &&(!rcup) &&(fabs(v)>(dup)) ;
const bool could_down= downok&&(ddown>0) &&(!rcdown)&& (fabs(v)<(ddown));
if (could_up&&could_down)
{
MM_ERR(" auto range logic error "<<MMPR4(v,dup,ddown,sfx))
} 
if (could_up) {++dx;  oor=true; v=v/dup; sfx=up; } 
if (could_down) { --dx; oor=true; v=v/ddown; sfx=down;  }
//if (upok&& (dup>0) &&(!rcup) )
//{ 
//MM_ERR(" FUDD IUP "<<MMPR2(v,(dup)))
//if (v>=(dup)) {++dx;  oor=true; v=v*dup; sfx=up; } }
//else 
//if ( downok&&(ddown>0) &&(!rcdown) )
//{ 
//MM_ERR(" FUDD DOWN "<<MMPR2(v,(ddown)))

//if (v<=(ddown)) { --dx; oor=true; v=v*ddown; sfx=down; } }

{ MM_ERR("FUDD "<<MMPR2(could_up,could_down) << MMPR4(iter,upok,downok,oor)<<MMPR4(sfx,up,dup,rcup)<<MMPR4(down,rcdown,ddown,v)) } 


if (iter>10) break; 


} while (oor);

return  dx; 

} // AutoRange

  
// members
St m_st;
StrTy m_fn;
Ragged m_defs;
units_map m_map;
SimpleUnits m_simple;
}; // mjm_unit_crap

//////////////////////////////////////////////

template <class Tr>
class mjm_unit_crap_map : public std::map<typename Tr::StrTy, mjm_unit_crap< Tr > >  
{
 typedef mjm_unit_crap_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_unit_crap< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_unit_crap_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_unit_crap_map


template <class Tos,class Tcrap>  Tos& operator<<(Tos & os, const typename mjm_unit_crap<Tcrap>::qty_dim & q)      
{
os<<q.dump();
return os;
}





////////////////////////////////////////////
#ifdef  TEST_MJM_UNIT_CRAP
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_unit_crap <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_UNIT_CRAP "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}
int main(int argc,char **args)
{
about();
typedef mjm_unit_crap<Tr>  Myt;
typedef Myt::qty_dim Qdim;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="fn") { x.fn(cip.p1); MM_ERR(x.dump()) }
if (cmd=="load") { x.load(); MM_ERR(x.dump()) }
if (cmd=="save") { x.save(); MM_ERR(x.dump()) }
if (cmd=="parse") { x.parse(); MM_ERR(x.dump()) }
if (cmd=="q") { 
 MM_ERR(MMPR4(cip.p1,cip.p2,cip.wif(3),cip.wif(4)))
if( cip.p1=="")
{
Qdim y;
MM_ERR("defauylt"<<MMPR3(y.qty(),y.sfx(),y.dump()))
}
else if( cip.p2=="")
{
Qdim y(cip.p1);
MM_ERR(" one param "<< MMPR3(y.qty(),y.sfx(),y.dump()))
}
else if( cip.wif(3)=="")
{
Qdim y(atof(cip.p1.c_str()),cip.p2);
MM_ERR(MMPR3(y.qty(),y.sfx(),y.dump()))
}
else // if( cip.wif(4)=="")
{
Qdim y(cip.p1,cip.p2,cip.wif(3));
MM_ERR(MMPR3(y.qty(),y.sfx(),y.dump()))
}
//else { MM_ERR(MMPR4(cip.p1,cip.p2,cip.wif(3),cip.wif(4))) } 

} // q

if (cmd=="eval") { x.intensive(cip.p1); MM_ERR(x.dump()) }
if (cmd=="to") { double v=0;  IdxTy rc=x.to(v,cip.p1,cip.p2,cip.wif(3)); 
MM_ERR(MMPR4(rc,v,cip.p1,cip.p2))
MM_ERR(x.dump()) }
//IdxTy  to(D & r, const StrTy & to, const StrTy & from, const StrTy & v)
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_UNIT_CRAP_H__ 
