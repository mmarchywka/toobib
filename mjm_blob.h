#ifndef MJM_BLOB_H__
#define MJM_BLOB_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_read_buffer.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri Sep 13 16:34:07 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_blob   
// g++ -std=gnu++11 -DTEST_MJM_BLOB -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_blob.h  -lpthread -lreadline

template <class Tr>
class mjm_blob 
{
 typedef mjm_blob Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef char Tdata;
typedef std::ofstream MyOs;

// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_blob() {Init(); }
mjm_blob(const StrTy & s) {Init(); copy(s); }

// non const wrecks things
//mjm_blob( Myt & that) {Init(); Adopt(that); }

~mjm_blob() {delete [] m_data; }

Myt& operator=( Myt & that) { Adopt(&that);  return *this; } 
Myt& operator=( const StrTy & s) { copy(s);  return *this; } 
// this keeps binary data... 
// and differs from the privat operator wtf 
// this is NOT const 
// this is a mess... 
 operator StrTy()
{
Ss ss;
if (m_data!=0){ ss.write(m_data,m_sz); } 

return ss.str();
}
private:
mjm_blob(const  Myt & that) { }

public:

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
IdxTy accept(const Tdata * p, const IdxTy n) { return Accept(p,n); }

//IdxTy accept(const StrTy & s ) { 
//const char * p=s.c_str(); const IdxTy n=s.length(); 
//return Accept(p,n); }
IdxTy copy(const StrTy & s) 
{
Release();
const IdxTy slen=s.length();
Size(slen+2);
memcpy(m_data,s.c_str(),slen+1);
m_sz=slen;
return 0; 
}

IdxTy size( ) const { return m_sz; }  
Tdata* ptr() { return m_data;}
const Tdata* ptr() const { return m_data;}
typedef mjm_read_buffer<Tr> RdBuf;
IdxTy load(const StrTy & fn)
{
RdBuf x(10); // make 1k default block size for now 
x.load(fn);
//Release();
const IdxTy sz=x.size();
adopt(x.ptr(),x.size(),x.alloc());
x.release();
return sz; // x.size();
}
RdBuf * rdbuf(const IdxTy pad, const IdxTy block)
{
RdBuf * x= new RdBuf(ptr(),size(),m_alloc,pad,block);
leak();
return x;
} // rdbuf
void leak()
{
//Adopt;
Myt & that= (*this);
that->m_data=0;
that->m_sz=0;
that->m_alloc=0;

}
IdxTy no_trailing_crlf() 
{
IdxTy n=0;
IdxTy i=m_sz;
while (i>0)
{
--i;
if (m_data[i]=='\n') { ++n;   m_data[i]=0; } 
else if (m_data[i]=='\r') { ++n;  m_data[i]=0; } 
else break;

}
m_sz-=n; // needed to eliminate crap from the string... 
return  n;
} // no_trailing_crlf

IdxTy nocrlf() 
{
Tdata * p=m_data;
if (p==0) return 0; 
m_data=0;
const IdxTy sz=m_sz;
const IdxTy alloc=m_alloc;
m_alloc=0;
Size(alloc);

IdxTy j=0;
IdxTy i=0;
IdxTy n=0;
while (i<sz)
{
if ((p[i]!='\n') &&(p[i]!='\r'))  { m_data[j]=p[i]; ++j; } 
//else ++n;
else{  ++n;  m_data[j]=' '; ++j;  } 
++i; 
}
m_data[j]=0; ++j; 
m_sz=j; // needed to eliminate crap from the string... 
MM_ERR(MMPR3(m_sz,m_alloc,m_data))
delete[]  p;
return  n;

} // nocrlf



void adopt( Tdata * p, const IdxTy n, const IdxTy na)
{
//Release();
Adopt(p,n,na);
}
IdxTy save(const StrTy & fn, const IdxTy flags=0 )  const 
{
const bool append=Bit(flags,0);
// TODO see if anyone relied on this only-write-if-non-zero thing 
//if (m_data==0) return 0 ; 
  MyOs f(fn.c_str(), append?std::ios_base::app:std::ios_base::trunc ); 

//std::ofstream ost {outputfile, std::ios_base::app};

f.write(m_data,m_sz); 
if (f.good()) return 0;
else MM_ERR(" failed to save blob "<<MMPR4(fn,flags,m_sz,m_alloc))
return 1;
} 
 operator StrTy () const {
if (m_data==0) return StrTy("");
if (m_alloc<=m_sz) return StrTy("");
if ( m_sz==m_alloc) 
{
MM_ERR(" failure in alloc padding "<<MMPR2(m_sz,m_alloc))

}
m_data[m_sz]=0;
 return StrTy(m_data); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
// find the location of s in p starting at first. 
static IdxTy find_blob(const char * p, const IdxTy sz, const IdxTy first, const char * s)
{ return FindBlob( p, sz, first, s); } 

void clear() { Release(); Init(); } 
void reset() { m_sz=0; } 

int * lines(const IdxTy flags)
{
if (m_data==0) return 0;
if (m_sz==0) return 0;
int * p= new int[2*m_sz+15];
IdxTy n=0;
// this treats the first one differently, pathological cases
// with blank lines and crlf combinations 
//if (m_data[0]!=0) 
//{ p[0]=0; ++n; }
for(IdxTy i=0; i<m_sz; ++i)
{
const IdxTy i0=i;
while ((i<m_sz)&&((m_data[i]!='\r')&&(m_data[i]!='\n'))) { ++i;}
if (i!=i0) { p[n]=i0; ++n; } 
//while ((m_data[i]=='\n') ||(m_data[i]=='\r'))  ++i;
//if ((m_data[i]=='\r')) {  m_data[i]=0; continue; }   
//if ((m_data[i]=='\n') )  
//{ ++i;  m_data[i0]=0; if(m_data[i]!=0) { p[n]=i; ++n;} }

} // i 
p[n]=~0;
return p; 
} // lines 
template <class Td> void line_vector( Td & dest)
{
int * na=lines(0);
if (na==0) return;
char * p= new char[2*m_sz+15];
int * naz=na;
while (*na!=(~0))
{
//dest.push_back(StrTy(m_data+(*na)));
IdxTy j=0;
IdxTy i=(*na);
while ((i<m_sz)&&((m_data[i]!='\r')&&(m_data[i]!='\n'))) 
{  p[j]=m_data[i]; ++j;++i;}
p[j]=0;
dest.push_back(StrTy(p));
++na;
}
delete[] naz;
delete[] p; 
return;

} // line_vector

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
StrTy Dump(const IdxTy flags=0) {Ss ss; 
if (m_data!=0)
{

ss.write(m_data,m_sz);
}

 return ss.str(); }
void Init() { 
m_data=0;
m_sz=0;  
m_alloc=0;
} 
//void Release() { delete [] m_data; m_data=0;   } 
// TODO this m_alloc=0 is a bug fix for string assign of or "Copy"
// of zeor length. Not sure what is screews up /
void Release() { delete [] m_data; m_data=0; m_alloc=0;  } 
static IdxTy FindBlob(const char * p, const IdxTy sz, const IdxTy first, const char * s)
{
const IdxTy slen=strlen(s);
for (IdxTy i=first; i<sz; ++i)
{
if (strncmp(p+i,s,slen)==0) return i;
}
return ~0;
}

void Size(const IdxTy n)
{
// TODO if m_data==0, m_alloc is now zero but nt sure what that does 
if (m_data!=0) if ( n<m_alloc) return ;
delete [] m_data;
m_data= new Tdata[n];
m_alloc=n;
}
void Adopt(Myt * that)
{
Adopt(that->m_data, that->m_sz,that->m_alloc);
that->m_data=0;
that->m_sz=0;
that->m_alloc=0;

}
void Adopt( Tdata * p, const IdxTy n, const IdxTy na)
{
Release();
m_data=p;
m_sz=n;
m_alloc=na;
}

IdxTy Accept(const Tdata * p, const IdxTy n)
{
Size(n+1);
m_sz=n; // assure a string guard 
memcpy(m_data,p,n); 
return 0; 
}
Tdata * m_data;
IdxTy m_sz,m_alloc;
}; // mjm_blob

//////////////////////////////////////////////

template <class Tr>
class mjm_blob_map : public std::map<typename Tr::StrTy, mjm_blob< Tr > >  
{
 typedef mjm_blob_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_blob< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_blob_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_blob_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BLOB
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BLOB "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_blob<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BLOB_H__ 
