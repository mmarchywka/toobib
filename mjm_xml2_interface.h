#ifndef MJM_XML2_INTERFACE_H__
#define MJM_XML2_INTERFACE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_blob.h" 

extern "C" {
#define TESTHTML_HEADER 
//#include "junk/testHTML.c"
// added c++ code doh
//#include "testHTML.c"
}

#include "testHTML.c"

// Sun Oct 20 04:32:21 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_xml2_interface   
// g++ -std=gnu++11 -DTEST_MJM_XML2_INTERFACE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_xml2_interface.h  -lpthread -lreadline

template <class Tr>
class mjm_xml2_interface 
{
 typedef mjm_xml2_interface Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_xml2_interface() {Init();}
~mjm_xml2_interface() {Release();}
IdxTy size() const { return m_size; } 
void parse_html(const char * p, const IdxTy sz,const IdxTy flags=0) { ParseHtml(p,sz,flags); }

void err_dump_html(const IdxTy flags=0){  ErrDumpHtml( flags); } 
void print_html_names(const IdxTy flags=0) { PrintHtmlNames(flags); } 
template <class Ty> void html_kv(Ty & d, const StrTy & nm, const IdxTy flags) {Html2KV(d,nm,flags); } 


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
enum { MAP_MU=0 , MU_SZ};
//m_mutex_vector = MutexVector(MU_SZ);
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }

void PrintHtmlNames(const IdxTy flags)
{
    xmlNode *root_element = xmlDocGetRootElement(m_html_doc);
    print_element_names(root_element,0);
}


void ParseHtml(const char * p, const IdxTy sz,const IdxTy flags)
{
//const char * p=bp.ptr();
//const IdxTy sz=bp.size();
 xmlFreeDoc(m_html_doc );
//MM_ERR(MMPR3(cmd,fn,sz))
 htmlParserCtxtPtr             ctxt = htmlCreatePushParserCtxt(NULL, NULL,
                      p, sz, "anon", XML_CHAR_ENCODING_NONE);
   htmlParseChunk(ctxt, p, 0, 1);
  m_html_doc = ctxt->myDoc;
 htmlFreeParserCtxt(ctxt);
// http://www.xmlsoft.org/examples/tree1.c
xmlCleanupParser();
}
void ErrDumpHtml(const IdxTy flags)
{
int szz=~0;
unsigned char * mem;
htmlDocDumpMemory(m_html_doc,&mem,&szz);
MM_ERR(MMPR(szz));
MM_ERR(MMPR2(mem,szz));
delete [] mem;
}
class _Pruner
{
typedef unsigned char C;
public:
_Pruner() {Init();}
_Pruner(const StrTy & nm ) {m_nm=nm; Init();}

void property(const C * pafck, const int lvl) 
{
const char*  p=(const char *) pafck;
if (p==0) return ;
MM_ERR("property "<<MMPR2(p,m_state))
if (strcmp(p,"content") ==0 ) {m_state|=(4<<8); return; } 
if (strcmp(p,"name") ==0) { m_state|=(2<<8); } 
} 
template<class Ty> bool kv(Ty & d, const C * kafck, const C * vafck, const int lvl)
{
const char*  k=(const char *) kafck;
const char*  v=(const char *) vafck;
if (k==0) return false;
MM_ERR(MMPR2(k,m_state))
//if (v==0) return false;

if (m_state!=0) if (lvl<=m_lvl)
{
MM_ERR(" bad set "<<MMPR4(k,m_k,m_v,d.size()))
d[m_k]=m_v;
m_state=0;
// return value will be wrong 
//return true;
}
if (m_state==0) if (m_nm==StrTy(k)) { m_lvl=lvl; m_state=1; 
MM_ERR(" name hit "<<MMPR2(k,m_state))  
return false;  }
if (m_state==0) return false; 
//if (m_state==1) 
{ // see if this is a key or value 
if (strcmp(k,"text")==0)
{
if (( m_state&(4<<8))!=0) 
{ if (v!=0)  m_v=v; else m_v="";  m_state&=~(4<<8); m_state|=4; } 
if (( m_state&(2<<8))!=0) 
{ if (v!=0)  m_k=StrTy(v); else m_k="";  m_state&=~(2<<8); m_state|=2; } 
} // text

} // m_state==1

if (m_state==7){ 
MM_ERR("setting "<<MMPR3(m_k,m_v,d.size()) )   
d[m_k]=m_v; m_k=""; m_v="";  m_state=0;  return true; } 
return false; 
} // kv 

private:
void Init() { m_state=0;   } 

int m_state, m_lvl;
StrTy m_nm,m_k, m_v;
}; // _Pruner



typedef _Pruner Pruner;

template <class Ty> void Html2KV(Ty & d, const StrTy & nm, const IdxTy flags)
{
    xmlNode *root_element = xmlDocGetRootElement(m_html_doc);
	Pruner pr(nm);
	GatherElement(d,root_element,0,pr);

}
template<class Ty> 
void GatherElement(Ty & d, xmlNode * a_node, int lvl, Pruner & pr)
{
    xmlNode *cur_node = NULL;

    for (cur_node = a_node; cur_node; cur_node = cur_node->next) {
//        if (cur_node->type == XML_ELEMENT_NODE) {
//            printf("node type: Element, %d  name: %s content %s \n", lvl,cur_node->name,cur_node->content); }
//            else { printf("node type: Other, %d  name: %s content %s \n", lvl,cur_node->name,cur_node->content); }
        //print_properties(cur_node->properties,lvl+1);
	pr.kv(d,cur_node->name, cur_node->content,lvl);
        GatherProperty(d,cur_node->properties,lvl+1,pr);
        //print_element_names(cur_node->children,lvl+1);
        GatherElement(d,cur_node->children,lvl+1,pr);
    }
}

template<class Ty>  void GatherProperty(Ty & d,  xmlAttr*  p, int lvl, Pruner & pr )
{
xmlAttr*  c=NULL;
for ( c=p; c; c=c->next)
{
//printf("     property  name= %s value= %s content = %s \n",c->name,c->children->name,c->children->content);
//printf("     property %d   name= %s   \n",lvl,c->name);
pr.property(c->name,lvl);
GatherElement(d,c->children,lvl+1,pr);
}

}

void (*foo)(void*, const char*, ...);
int hse;
void Init()
{
MM_ERR(" fcking error code fcking run s")
hse=0;
m_html_doc=0;
m_size=0;

//xmlSchemaSetValidStructuredErrors(0, &foo, &hse);


xmlSetGenericErrorFunc(0,&Myt::xmlGenericErrorFunc);
foo=&Myt::xmlGenericErrorFunc;
initGenericErrorDefaultFunc(&foo);
xmlSetStructuredErrorFunc(0,&Myt::xmlStructuredErrorFunc);

}
void Release()
{
xmlFreeDoc(m_html_doc);
}

static void xmlStructuredErrorFunc(void * ud, xmlErrorPtr err)
{
MM_ERR( MMPR3(err->file,err->line, err->message))
}
static void xmlGenericErrorFunc(void * ctx, const char * msg, ...) //  ... ...  )
{
MM_ERR(MMPR(msg))
}



htmlDocPtr m_html_doc ;
IdxTy m_size;


}; // mjm_xml2_interface

//////////////////////////////////////////////

template <class Tr>
class mjm_xml2_interface_map : public std::map<typename Tr::StrTy, mjm_xml2_interface< Tr > >  
{
 typedef mjm_xml2_interface_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_xml2_interface< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_xml2_interface_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_xml2_interface_map




////////////////////////////////////////////
#ifdef  TEST_MJM_XML2_INTERFACE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_XML2_INTERFACE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_xml2_interface<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_XML2_INTERFACE_H__ 
