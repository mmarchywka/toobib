#ifndef MJM_MED2BIB_GUESSES_H__
#define MJM_MED2BIB_GUESSES_H__

#include "mjm_hier_two.h"
#include "mjm_bibtex_fields.h"
#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_cpp_regex.h"
#include "mjm_wovdb.h"
#include "mjm_blob.h"
#include "mjm_strings.h"
#include "mjm_collections.h"
#include "mjm_pawnoff.h"
#include "mjm_ext_things.h"
#include "mjm_has_bibtex.h"
#include "mjm_string_kvp.h"

#include "mjm_assemble_putative_bibtex.h"
#include "mjm_try_n_get.h"
#include "mjm_doi_scrape.h"
#include "mjm_scrape_xform.h"
#include "mjm_bibtex_entry.h"
#include "mjm_hierarchial_kvp.h"
#include "mjm_bomtex_json.h"
#include "mjm_jats_xml.h"
#include "mjm_marc_xml.h"
#include "mjm_mets_xml.h"
#include "mjm_wovdb.h"
#include "mjm_misc_parse.h"
#include "mjm_idiosyncratic_source_locator.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <cstdio>


// Fri Jan  8 20:53:53 EST 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_med2bib_guesses   
// g++  -Wall -std=gnu++11 -DTEST_MJM_MED2BIB_GUESSES -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_med2bib_guesses.h  -lpthread -lreadline
/*

Use -M to list included files for extraction, note a lot of junk
included, 
 g++  -Wall -std=gnu++11 -DTEST_MJM_MED2BIB_GUESSES -I. -I../../mjm/hlib -I../../mjm/num -M  -gdwarf-3 -O0  -x c++ mjm_med2bib_guesses.h  -lpthread -lreadline | sed -e 's/ /\n/g'| grep "[a-zA-Z0-9]" | sort -r -i | uniq
*/



#define REGFUK (std::regex_constants::egrep | std::regex_constants::icase)
template <class Tr>
class mjm_med2bib_guesses  : public mjm_ragged_config
{
 typedef mjm_med2bib_guesses Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_wovdb<Tr,StrTy> WovDB;
typedef typename WovDB::vector_type Vt;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_blob<Tr> Blob;
typedef mjm_pawnoff<Tr> Hand;

typedef mjm_try_n_get<Tr> Getter;
typedef typename Getter::return_code Grc;
typedef mjm_doi_scrape<Tr> Scraper;
typedef typename Scraper::scraped_vector Scrapes;
typedef typename Scraper::result_code Src;
typedef mjm_scrape_xform<Tr> Xformer;
typedef typename Xformer::result_code Xrc;
typedef mjm_assemble_putative_bibtex<Tr> Finisher;
typedef typename Finisher::return_code Frc;
typedef typename Finisher::assem_opt Ao;
typedef mjm_ext_things<Tr> Ext;

typedef mjm_var_parse<Tr> ParseTable;
typedef typename ParseTable::Iv Iv;



typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibMap;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;

typedef mjm_hierarchial_kvp<Tr> HierKvp;
typedef mjm_hier_two<Tr> HierUtil;

typedef mjm_strings StrUtil;

typedef mjm_idiosyncratic_source_locator<Tr> IdioRL;

typedef mjm_bibtex_fields<Tr> Fields;
typedef mjm_jats_xml<Tr> JatsX;
typedef mjm_mets_xml<Tr> MetsX;
typedef mjm_marc_xml<Tr> MarcX;

typedef mjm_has_bibtex<Tr> HasBib;

typedef mjm_bomtex_json<Tr> BomTex;

typedef mjm_string_base_params<Tr> BaseParams;

class _attempt
{

static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
public:
_attempt(){ Init(); P();  } 
_attempt( const _attempt & that ) { Init(that); P();  } 
_attempt & operator=( const _attempt & that ) { Init(that); P(); return *this;  } 
// TODO no consistent way to copy the blob doh 
_attempt(const Blob & b, const StrTy & fn, const StrTy & name, const StrTy & uin,const StrTy & url,const StrTy & nm, const StrTy & date,  const IdxTy flags)
:m_result(StrTy(b)),m_fn(fn),m_name(name),m_handler(nm),m_date(date),m_srcurl(uin),m_citeurl(url),m_flags(flags) 
{P(); }
enum { BLOB=0,FN=1,PARSE=2,CHECK=3,PASS=4};
void set(const IdxTy b) { m_flags|=(1<<b); } 
void reset(const IdxTy b) { m_flags&= ~(1<<b); } 
void flag(const IdxTy b, const bool s) { s?set(b):reset(b); } 
void parsed(const IdxTy e) { m_errors=e; set(PARSE);  } 
void have_blob(const bool x) {flag(BLOB,x); } 
void have_fn(const bool x) {flag(FN,x); } 
void checked(const bool x) {set(CHECK); flag(PASS,x); } 
bool have_blob() const { return Bit(m_flags,BLOB); } 
bool have_fn() const { return Bit(m_flags,FN); } 
bool parsed() const { return Bit(m_flags,PARSE); } 
bool checked() const { return Bit(m_flags,CHECK); } 
bool passed() const { return Bit(m_flags,PASS); } 
const IdxTy errors() const { return m_errors; } 
const StrTy & name() const { return m_name; } 
const StrTy & file() const { return m_fn; } 
const StrTy & srcurl() const { return m_srcurl; } 
StrTy & srcurl()  { return m_srcurl; } 

//StrTy dump(const StrTy & uin, const IdxTy flags)
// TODO FIXME  this belonds in final assembly
// This never uses the file, the result comes from teh blob unless
// no_blob is set a zero blob is zero output.
StrTy dump( const IdxTy flags=0)
{
if (true) m_result.load(m_fn); // always reload result as post-ediiting may have occured see iastate for example 
//const bool no_blob=Bit(flags,0);
//const bool no_results=Bit(flags,1);
Ss ss;
const StrTy leader="% mjmhandler: ";
const StrTy uleader="% srcurl: ";
const StrTy nleader="% citeurl: ";
const StrTy dleader="% date ";
ss<<leader<<m_program<<" "<<m_handler<<CRLF;
ss<<dleader<<m_date<<CRLF;
ss<<uleader<<m_srcurl<<CRLF;
ss<<nleader<<m_citeurl<<CRLF;
//if (!no_results) 
{ ss<<StrTy(m_result); } 
//if (have_fn()) 
//if (!no_blob) { Blob b; b.load(m_fn); ss<<StrTy(b); }
return ss.str();
} // dump 
void P() { m_program="toobib"; if (StrTy(m_result)=="")
{m_result.load(m_fn); }
}
void Init()
{
m_flags=0;
}
void Init( const _attempt & that ) { 
m_result=StrTy(that.m_result); // TODO lol was never meant to copy doh
m_fn=that.m_fn;
m_name=that.m_name;
m_program=that.m_program;
m_handler=that.m_handler;
m_date=that.m_date;
m_srcurl=that.m_srcurl;
m_citeurl=that.m_citeurl;
m_flags=that.m_flags;
m_errors=that.m_errors;
} 
//AttemptTy a(b,fn,url,nm,date,flags);
// typically one of the other Blob or fn.
Blob m_result;
StrTy m_fn, m_name; 
StrTy m_program,m_handler;
StrTy m_date;
StrTy m_srcurl;
StrTy m_citeurl;
IdxTy m_flags,m_errors;
}; //_attempt
typedef _attempt  AttemptTy;
typedef mjm_wovdb<Tr,AttemptTy> AttWovDB;

// needs to use the cpp_regex def TODO FIXME 
typedef std::regex Regex;
class inputs
{
public:
inputs() { Init(); } 
inputs(const IdxTy f) { Init(); m_flags=f; } 
inputs( Myt * const mom, const IdxTy f, const IdxTy rflags) 
{ Init();m_mom=mom;  m_flags=f; m_rflags=rflags; } 
//inputs(const inputs & that, const StrTy uin) 
inputs(const inputs & that, const IdioRL & uin) 
//{(*this)=that; m_depth=that.m_depth+1;  m_uin=uin; }
{(*this)=that; m_depth=that.m_depth+1;  Uin(uin); }
inputs(const Ragged & r ) { Init(r); } 
inputs(const Ragged & r, const IdxTy f ) { Init(r); m_flags=f; } 

enum { SHOW_DEC=0, SHOW_TRY=1, KEEP_GOING=2, GET_ALL=3};

//const bool show_decisions=Bit(flags,0);
//const bool show_trial=Bit(flags,1);
//const bool keep_going=Bit(flags,2);



 Myt * mom() const { return m_mom; } 
const IdxTy rflags() const { return m_rflags; } 
void set( Getter & g, Scraper & s, Xformer & x, Finisher &  f)
{
m_pgetter=&g;
m_pscraper=&s;
m_pxformer=&x;  
m_pfinisher= &f; 
}
// needs to provide filenames for handlers
// must have local temp and those to communicate
// with others ( uin normal get, variants, putative
// bibtex results, xformed etc ) 
IdxTy depth() const { return m_depth;} 
//void  uin(const StrTy & u )  {  m_uin=u;} 
void  uin(const StrTy & u )  {  Uin(u);} 
//const StrTy & uin() const { return m_uin;} 
const IdioRL & uin() const { return m_uin;} 
// really m_uin should only be set once and so all checks done at ctor..
//bool web_source() const { return true; } 
//bool local_source() const { return true; } 
//bool remote_source() const { return true; }
// doi,issbn , other etc  
//StrTy identifier() const { return StrTy(""); } 

void  dest(const StrTy & u )  {  m_dest=u;} 
const StrTy & dest() const { return m_dest;} 
void  skip_regex(const StrTy & u )  {  m_skip_regex=u;} 
const StrTy & skip_regex() const { return m_skip_regex;} 
void  use_only(const StrTy & u )  {  m_use_only=u;} 
const StrTy & use_only() const { return m_use_only;} 
void  flags(const IdxTy u )  {  m_flags=u;} 
const IdxTy & flags() const { return m_flags;} 
// most of these are obsolete, only the collect all is used. 
enum { SKP=0, ONE=1, COLLECT_ALL=2, PASTE=3, PUNT_PMC=4};
bool skip_some() const { return Bit(m_flags,SKP); } 
bool just_one() const { return Bit(m_flags,ONE); } 
bool collect_all() const { return Bit(m_flags,COLLECT_ALL); } 
// if bib can be recognized, past latex citation to clipboard 
bool paste_citation() const { return Bit(m_flags,PASTE); } 
bool punt_pmc() const { return Bit(m_flags,PUNT_PMC); } 

 Getter & getter() const { return *m_pgetter;}
Scraper & scraper() const { return *m_pscraper;}
Xformer & xformer() const { return *m_pxformer; } 
Finisher & finisher() const { return *m_pfinisher; } 


private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
//void  Uin(const StrTy & u )  {  
void  Uin(const IdioRL & u )  {  
m_uin=u;
m_uin.parse();
} 
void Init(const Ragged & r) 
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if (len<1) continue;



} // i 

} // Init
void Init() 
{
m_flags=0;
m_rflags=0;
m_depth=0;
 m_pgetter=0;
 m_pscraper=0;
 m_pxformer=0;
 m_pfinisher=0;
m_mom=0;
} // Init
StrTy Dump(const IdxTy flags) const
{
Ss ss;
ss<<MMPR4(StrTy(m_uin),m_dest,m_skip_regex,m_use_only);
ss<<MMPR3( m_flags,m_rflags,m_depth);
ss<<MMPR2( m_identifier,m_src_flags);

return ss.str(); 
}

IdxTy m_flags,m_rflags,m_depth;
IdioRL m_uin;
StrTy m_dest,m_skip_regex,m_use_only;
StrTy m_identifier;
IdxTy m_src_flags;

mutable Getter*  m_pgetter;
mutable Scraper* m_pscraper;
mutable Xformer* m_pxformer;
mutable Finisher*  m_pfinisher;
 Myt * m_mom;



}; // inputs
typedef inputs InpTy;
class outputs
{

typedef std::vector<StrTy> PartStack;
public:
enum { DEFER=0, CITE=1, RECURSE=2};
outputs(){ Init(); }
~outputs(){ delete_temps(); }
outputs(const outputs & that, const StrTy & nurl)
{  m_uin_stack=that.m_uin_stack; Init();  uin(nurl); m_handler_stack=that.m_handler_stack; m_seen=that.m_seen; }
void adopt( outputs & that) { Adopt(that); } 
void  uin(const StrTy & u )  {m_uin_stack.back()=u;   m_uin=u;} 
const StrTy & uin() const { return m_uin;} 
const StrTy & fn(const StrTy & nm,const IdxTy flags=0) { return Fn(nm,flags); } 
const StrTy & fn(const IdxTy flags=0) { return Fn(src(),flags); }
IdxTy delete_temps(const IdxTy flags=0) { return DeleteTemps(flags); } 
//const Vt * list=m_db.find("files",nm);
// TODO add specific file locations for the first download
// and original source bibtex to check processing 
//StrTy initial_fn() const { return m_initial_fn; }  
//StrTy as_received_fn() const { return m_as_received_fn; }  
const StrTy & src()const  { return m_source_stack.back(); } 
//IdxTy rcf= out.good_enough(b,fnbib,in,url,nm,0);
IdxTy insert_missing(const StrTy & fnbib, const std::map<StrTy, StrTy> & kv, const IdxTy flags)
{ return  InsertMissing( fnbib,  kv,  flags); } 
IdxTy good_enough(Blob & b, const StrTy & fnbib, const InpTy & in, 
const StrTy & url, const StrTy & nm, const IdxTy flags)
{ return GoodEnough(b,fnbib,in,url,nm,0); }
IdxTy id_count(const StrTy & type, const StrTy & id, const IdxTy bump=1) { 
MM_ERR( " forcing unseen due to differen tests "<<MMPR3(type,id,bump))
return 0; 
return IdCount(type+":::"+id,bump); } 
IdxTy id_count(const StrTy & id, const IdxTy bump=1) { return IdCount(id,bump); } 
void result(const Blob & b, const StrTy & fn, const StrTy & name,const StrTy & url,const StrTy & nm, const IdxTy flags)
{ Result(b,fn,name,url,nm,flags); } 
IdxTy found() const { return m_att.size(); } 
void punt() {m_flags|=(1<<DEFER);  } 
bool defer() const  { return Bit(m_flags,DEFER); }  
bool recurse() const  { return Bit(m_flags,RECURSE); }  
bool cite_anyway() const  { return Bit(m_flags,CITE); }  
void cite(const StrTy & s ) { m_misc=s; m_flags|=(1<<CITE); }
void nurl(const StrTy & s ) { m_nurl=s; m_flags|=(1<<RECURSE); }
const StrTy &  cite( ) const  { return  m_misc;}
const StrTy &  nurl( ) const  { return  m_nurl;}

StrTy preview(const IdxTy n) { return m_att[n].dump(1); } 
StrTy result_file(const IdxTy n) { return m_att[n].file(); } 
// if the name is changed during final asembly this needs to be fixed.. 
const StrTy&  name(const IdxTy n) const  { return m_att[n].name(); } 
void rewrite_name(const StrTy & nname, const IdxTy n)  
{ return m_att[n].name(nname); } 

Hand & hand() { return m_hand; } 
void push_source(const StrTy & nm) { m_source_stack.push_back(nm); } 
void pop_source() { m_source_stack.pop_back(); }
//void push(const StrTy & nm) { m_partial_stack.push_back(nm); } 
//void pop() { m_partial_stack.pop_back(); }
//StrTy partial() const { Ss ss;  MM_LOOP(ii,m_partial_stack) { ss<<"<-"<<(*ii); }
//return ss.str(); }   
/*
const StrTy & nm() const {
if (m_handler_stack.size()==0) { MM_ERR(" no name will bomb now ") return m_blank; } 
 return m_handler_stack.back(); } 
*/
void enter(const StrTy & nm ) { MM_ERR(" enter "<<MMPR(nm))   m_handler_stack.push_back(nm); } 
void exit(const StrTy & nm ) { 
MM_ERR(" exit "<<MMPR(nm))
if (m_handler_stack.back()!=nm) 
{MM_ERR(" stack bad "<<MMPR3(nm,m_handler_stack.back(),m_handler_stack.size())) } 
m_handler_stack.pop_back(); } 
const StrTy &  current() const { return m_handler_stack.back(); }   
StrTy nm() const { Ss ss;  
const IdxTy sz=m_handler_stack.size();
if (sz) ss<<m_handler_stack[0];
for(IdxTy i=1; i<sz; ++i)
{ ss<<"<-"<<m_handler_stack[i]; ; } 
return ss.str(); }   


//if (out.only(nm,in,"normalget")) return ~0;
bool only(const StrTy & nm, const InpTy & in, const StrTy & fn) const
{ return Only(nm,in,fn); }
private:
bool Only(const StrTy & nm, const InpTy & in, const StrTy & fn) const
{
const StrTy * p=CFn(src());
if (src()==fn ) return false;
if (p!=0) if (in.getter().exists(*p)) return false;
MM_ERR(" missing file suggests logic error. "<<MMPR(nm) <<" can only get normal get but source is "<<MMPR(src())<< " and missing file is "<<MMPR(((p==0)?"null":(*p))))
return true;

}
// the parsed entry could be used with simple adds to kv map but want to preserve
// original text for now 
 
IdxTy InsertMissing(const StrTy & fnbib, const std::map<StrTy, StrTy> & kv, const IdxTy flags)
{
const bool copy_value=Bit(flags,0);
MM_ERR("  terrible kluges  "<<MMPR4(copy_value,fnbib,flags,kv.size()))
Blob b;
b.load(fnbib);
//Frc frc=in.finisher().parse(b,fnbib,"",0);
BibMap bm;
bm.parse(fnbib);
if (bm.size()==0)
{
MM_ERR(" no bib entries found "<<MMPR(fnbib))
return ~0;
// AFCK 
}
BibEntry & be=(bm[0]); // frc.be();
const IdxTy nentries=bm.entries(); // total entries not unique names 
const IdxTy nnames=bm.size(); // total entries not unique names 
const StrTy name=be.name();
const StrTy type=be.type();
const bool good_start=(name.length()&&type.length());
if (!good_start) { MM_ERR(" bad bib "<<MMPR4(fnbib,nentries,name,type)) ;  return ~0; } 
be.make_keys_uniform();
Ragged r;
r.splitter(8); // tokenize and hope to find the brace at end...
r.load(fnbib); 
Ss ss;
const IdxTy rsz=r.size(); // number of lines
typedef Ragged::word_iterator RagItor;
RagItor ir(r,true);
while (ir)
{ if ((*ir)=="}") {
--ir; // get the one before this
if (!ir) break;
const IdxTy line=ir.line(); const IdxTy word=ir.word();
RagItor it(r,!true); while (it) { 
ss<<(*it); 
// point before right brace, 
if ((it.line()==line) && (it.word()==word)) { MM_LOOP(ii,kv) {
const StrTy & key=(*ii).first;
StrTy  val=(*ii).second;
const bool missing=be.missing_canonical(key);
if (missing) { 
if (copy_value){  val=be[val]; };
MM_ERR(" InsertMissing add "<<MMPR4(fnbib,name,key,val))
ss<<","<<CRLF; ss<<key<<"={"+val+"}";  } // missing 
} // ii 
// probably not needed //ss<<CRLF;
} // eq
++it; if (it.word()==0) {  ss<<CRLF; } } // while it
break; }; // if
--ir; } // ir
b=ss.str(); b.save(fnbib);
return 0; 
} // InsertMissing

//  X-UA-Compatible access pagetitle publisher robots theme-color title viewport

typedef  std::map<StrTy, IdxTy > RejectMap;
RejectMap & reject_map() const
{
static RejectMap m;
if (m.size()==0)
{
m["X-UA-Compatible"]=1;
m["access"]=1;
m["pagetitle"]=1;
m["robots"]=1;
m["theme-color"]=1;
m["viewport"]=1;

} 
return m;
} // reject_map

// Crossref etal are returning usless entry names now.
// need to routinely fix the text... 
IdxTy GoodEnough(Blob & b, const StrTy & fnbib, const InpTy & in, 
const StrTy & url, const StrTy & nm, const IdxTy flags)
{  
const bool clean=!Bit(flags,0);
const bool insert_url=!Bit(flags,1);
// TODO FIXME this is trashing the input stuff now wtf... 
// https://www.nutraingredients-usa.com/Article/2020/08/19/Danish-population-study-further-bolsters-case-for-vitamin-K2#
//const bool rewrite=false ; // !Bit(flags,2);
// 2019-09-30 change back to get better names and fix other issues
// although not sure why it drops the json2 entries yet 
const bool rewrite= !Bit(flags,2);
// this parses the FIL not the blob 
//if (clean) in.finisher().light_clean(fnbib,fn("temp"),0);
Frc frc=in.finisher().parse(b,fnbib,"",0);
//Frc frcb=0; // in.finisher().validate(b,fnbib,"",0);
BibEntry & be=frc.be();
const IdxTy nentries=frc.bm().entries(); // total entries not unique names 
const IdxTy nnames=frc.bm().size(); // total entries not unique names 
// hopefully these will be ok 
StrTy name=be.name();
StrTy type=be.type();
IdxTy nonx=be.non_x(reject_map());
// unfortunately these are now defaulting... 
//const bool good_start=be.has_good_name()&&be.has_good_type()&&be.size(); // (name.length()&&type.length());
// it can fix the name later if enough entries... 
// these are all inserted though no help... 
//const bool good_start=(be.has_good_name()||(be.size()>4))&&be.has_good_type()&&(be.size()>1); // (name.length()&&type.length());
const bool good_start=(nonx>2); // (name.length()&&type.length());
MM_ERR(" GoodEnough "<<MMPR4(good_start,nentries,nnames,IdxTy(frc))
<<MMPR(nonx)<<MMPR4(name,type,be.size(),be.has_good_type())<<MMPR(be.key_str()))
if (!good_start)
{
//MM_ERR("GoodEnough NO  "<<MMPR3(fnbib,nentries,nnames)<<MMPR4(good_start,IdxTy(frc),name,type))
//MM_ERR(MMPR3(be.has_good_name(),be.has_good_type(),be.size()))
}
else
{
//MM_ERR("GoodEnough "<<MMPR3(fnbib,nentries,nnames)<<MMPR4(good_start,IdxTy(frc),name,type))
}
// keep anyway for edit
//if (frc==0)
// this belongs in final assembly.. 
if (good_start)
{
// if b and fnbib both have contents both written doh... 
//out.result( b, fnbib, url, nm,  0);
// this is in-place AFA user us concerned 
// this is too late for things like ampersands etc. 
if (clean) in.finisher().light_clean(fnbib,fn("temp"),0);
if (rewrite)
{
// 20210-09-04 messing up on upper case  0-> 1 for make_lc 
 //in.finisher().rewrite_parse(fnbib,fn("temp"),1);
 in.finisher().rewrite_parse(fnbib,fn("temp"),9);
// now reparse the thing ... doh 
Frc frc=in.finisher().parse(b,fnbib,"",0);
be=frc.be();
const IdxTy nentries2=frc.bm().entries(); // total entries not unique names 
const IdxTy nnames2=frc.bm().size(); // total entries not unique names 
MM_ERR(MMPR4(nentries,nnames,nentries2,nnames2))
// hopefully these will be ok 
name=be.name();
type=be.type();

} // rewrite

//else fnbib=fntemp;
// Check the entry for common miscellaneous problems
// if found, correct the TEXT not the entry...
if (insert_url)
{
// alternatively keep a distinct conformed index ( replace
// m_map with a wovsb.
// this does not  work righht 
//be.make_keys_uniform();
// this seems to fail on "URL" 
// 2021-05-27 actually it may worj, there is likely a proble
// with source bibtex not having a comma before "URL" or something
// reverting back... 
//const bool missing_url=be.missing("url") && be.missing("URL");
//const bool missing_url=be.missing("url"); //  && be.missing("URL");
// 2021-07-28 it is failing doh 
// 2021-08-19 the fields are not lower cased by default now...
// still will miss cased but that is f-ed up lol 
//const bool missing_url=be.missing_canonical("url"); //  && be.missing("URL");
const bool missing_url=be.missing_canonical("url") && be.missing("URL");
const bool missing_surl=be.missing_canonical("srcurl");
const bool missing_curl=be.missing_canonical("citeurl");
const bool  missing_download_date=be.missing_canonical("toobib-date");
const bool fix=missing_url|missing_surl|missing_curl;
if (fix)
{ // NB: note that "},} " is a valide end doh 
Ragged r;
r.splitter(8); // tokenize and hope to find the brace at end...
r.load(fnbib); 
// find a trailing "}" hopefully this is clean enough to work... 
Ss ss;
//ss<< r.dump(18,""); // no sequences and use the zero length separateor 
const IdxTy rsz=r.size(); // number of lines
typedef Ragged::word_iterator RagItor;
RagItor ir(r,true);
while (ir)
{
if ((*ir)=="}")
{
--ir; // get the one before this
// except that the last field value could have a -ing comman "},}" is valid
// remove it if present 
if (!ir) break;
//  trailing comma  wth 
if ((*ir)==",") --ir;
if (!ir) break;
const IdxTy line=ir.line();
const IdxTy word=ir.word();
RagItor it(r,!true);
while (it) { 
ss<<(*it); 
// remove any bad thing from the name line
// TODO downcit is putting url as name, it works but dumb 

// point before right brace, 
if ((it.line()==line) && (it.word()==word))
{
// TODO also may have authors instead of author

//ss<<","; ss<<CRLF;
const StrTy uin=m_uin; // m_source_stack.front();
//if (missing_url) {ss<<","<<CRLF; ss<<"url={"+in.uin()+"}"; } // <<CRLF;
//if (missing_url) {ss<<","<<CRLF; ss<<"url={"+uin+"}"; } // <<CRLF;
const bool missing_toobib_cred=true;
if (missing_toobib_cred) {ss<<","<<CRLF; ss<<"final_assembly ={ TooBib handler "+nm+"}"; } // <<CRLF;
if (missing_url) {ss<<","<<CRLF; ss<<"url={"+m_uin_stack[0]+"}"; } // <<CRLF;
//if (missing_surl) {ss<<","<<CRLF; ss<<"srcurl={"+in.uin()+"}"; } // <<CRLF;

if (missing_surl) {ss<<","<<CRLF; ss<<"srcurl={"+m_uin_stack[0]+"}"; } // <<CRLF;
if (missing_surl) {ss<<","<<CRLF; ss<<"xsrcurl={"+uin+"}"; } // <<CRLF;
if (missing_curl) {
StrTy urlx=Myt::MutateOnly(url,"awk '{print $1}'",*this);
ss<<","<<CRLF; ss<<"citeurl={"+urlx+"}"; } // <<CRLF;

if (missing_download_date) {
Blob d,o,e;
StrTy cmd_date=" ( echo -n `date \"+%Y-%m-%d:%H:%M:%S\"` `date` ) ";
const IdxTy rc=m_hand.fileio(o,e,d,cmd_date);
const StrTy ddd=StrTy(o)+StrTy(e)+StrTy(d);
ss<<","<<CRLF; ss<<"toobib-date={"+ddd+"}"; } // <<CRLF;
ss<<CRLF;
} // eq
++it; if (it.word()==0) {  ss<<CRLF; }

  } // while it

break; 
}; // if

--ir;
} // ir

b=ss.str();
b.save(fnbib);

} // fix 
}// insert_url

b.load(fnbib);
result( b, fnbib, name,url, nm,  0);
} // frc==0
return frc;
} // GoodEnough 

IdxTy IdCount(const StrTy & id, const IdxTy bump) { 

const IdxTy rc=m_seen[id];
//return IdCount(id,bump); 
m_seen[id]+=bump;
return rc;

} 


void Result(const Blob & b, const StrTy & fn, const StrTy & name, const StrTy & url,const StrTy & _nm, const IdxTy flags)
{
StrTy  nm=(*this).nm();
const bool diff=(_nm!=current());
const bool stem=(0==strncmp(_nm.c_str(),nm.c_str(),strlen(nm.c_str())));
//if (_nm!=current())
if (diff)
{
MM_ERR(" logic error or modifiication  "<<MMPR4(diff,stem,_nm,current()))
if (stem) nm=_nm;
}
Blob d,o,e;
StrTy cmd_date=" ( echo -n `date \"+%Y-%m-%d:%H:%M:%S\"` `date` ) ";
const IdxTy rc=m_hand.fileio(o,e,d,cmd_date);
const StrTy date=StrTy(o)+StrTy(e)+StrTy(d);
AttemptTy a(b,fn,name,m_uin,url,nm,date,flags);
//MM_MSG(" adding a result "<<MMPR4(b.size(),fn,name,m_uin)<<MMPR(found()))
const IdxTy loc=m_att.add(a);
m_att.index(loc,"source",nm);
//MM_MSG(" added a result "<<MMPR4(b.size(),fn,name,m_uin)<<MMPR(found()))

}
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// may want a temp, specific location or most recent or first
// fn in the catagory 
// 
const StrTy * CFn(const StrTy & nm,const IdxTy flags=0) const  { 
const Vt * list=m_db.find("files",nm);
bool add=(list==0); 
if (!add) add=((*list)[0]==(~0U));
if (add) return 0; 
return &( m_db[(*list)[0]]); 
} // CFn

IdxTy Remove(const StrTy & fn, const IdxTy flags=0) //const
{
//Blob out,err,data;
//StrTy cmd=StrTy("rm \"")+fn+StrTy("\"");
//IdxTy c=m_hand.fileio(out,err,data,cmd);
//if (StrTy(err).length()!=0) { MM_ERR(MMPR3(c,cmd,StrTy(err))) }
std::remove(fn.c_str());
return 0; // atoi(StrTy(out).c_str());
} //Remove 



IdxTy DeleteTemps(const IdxTy flags)
{
// this test is not performed consistently in output dtor.. 
if (!mjm_global_flags::mm_delete_temps )  return 1; // out.delete_temps();
const IdxTy sz=m_db.size();
MM_ERR("deleting temps "<<MMPR(sz))
for(IdxTy i=0; i<sz; ++i)
{
const StrTy nm=m_db[i];
MM_ERR("deleting temps "<<MMPR2(nm,i))
Remove(nm,flags); 
} // i 
m_db= WovDB();
return 0;
}// DeleteTemps

const StrTy & Fn(const StrTy & nm,const IdxTy flags) { 
// TODO kind of a kluge but some file name types 
// are just really temps. Need a scheme here.. 
const bool append_new_file=(nm=="bibtex")|| Bit(flags,0);
if (append_new_file)
{
const StrTy fn=Fgen();
const IdxTy loc=m_db.add(fn);
m_db.index(loc,"files",nm);
return m_db[loc];

}

const Vt * list=m_db.find("files",nm);
bool add=(list==0); 
if (!add) add=((*list)[0]==(~0U));
if (add) {

const IdxTy loc= m_db.add(Fgen());  m_db.index(loc,"files",nm);
return m_db[loc]; 
 }
return m_db[(*list)[0]]; 

} 
StrTy Fgen() const
{
char c[1+((L_tmpnam+1)|255)] ;
return StrTy(tmpnam(c))+StrTy(".outguesses");
}

void Init()
{ 
m_source_stack.push_back("normalget");
m_flags=0;
m_uin_stack.push_back(StrTy());
} // Init 

//const StrTy fout=tmpnam(c);
//char c[1+((L_tmpnam+1)|255)] ;
//const StrTy fin=tmpnam(c);
//const StrTy fout=tmpnam(c);
//const StrTy ferr=tmpnam(c);
//const StrTy frc=tmpnam(c);

void AdoptOld(const outputs & that) 
{ 
// eh, this trashes all the existing ones... doh
// that was ok when you only had old ones...
// a += operator almost works but not quite. 
m_att=that.m_att;
//MM_SZ_LOOP(i,m_att,sz)
const IdxTy sz=m_att.size();
for(IdxTy i=0; i<sz; ++i)
{
//typedef _attempt  AttemptTy;
AttemptTy & at= m_att[i];
at.srcurl()+=" "+m_uin;
}
} 
void Adopt( outputs & that) 
{ 
// eh, this trashes all the existing ones... doh
// that was ok when you only had old ones...
// a += operator almost works but not quite. 
//m_att=that.m_att;
//MM_SZ_LOOP(i,m_att,sz)
const IdxTy szoff=m_att.size();
m_att.re_index(that.m_att);
const IdxTy sz=that.m_att.size();
for(IdxTy i=0; i<sz; ++i)
{
//typedef _attempt  AttemptTy;
AttemptTy  at= that.m_att[i];
at.srcurl()+=" "+m_uin;
const IdxTy loc=m_att.add(at);
// could just reindex but see below 
} // i
// save the temp files...

// Delete
{const IdxTy sz=that.m_db.size();
MM_ERR("adopting  temps "<<MMPR(sz))
for(IdxTy i=0; i<sz; ++i)
{
const StrTy nm=that.m_db[i];
const IdxTy loc=m_db.add(nm);
m_db.index(loc,"files","added");
} // i 
that.m_db= WovDB();
} 
// now get the indexes...
// really they are just offset...
// find all the index entries and add szoff to 
// them in the new 
//MM_LOOP(ii,that.m_seen) 
m_seen=that.m_seen; // this should have picked up initial counts on entry. 
} // Adopt 

// MEMBERS
StrTy m_uin;
WovDB m_db;
AttWovDB m_att;
Hand m_hand;
IdxTy m_flags;
StrTy m_misc,m_nurl;
PartStack m_source_stack;
PartStack m_partial_stack;
PartStack m_handler_stack;
PartStack m_uin_stack;
typedef std::map<StrTy, IdxTy> IdMap;
IdMap m_seen;
StrTy m_blank;
}; // outputs
typedef outputs OutTy;

//typedef  IdxTy ( * Gfunc)(const InpTy & , OutTy & ); 
typedef  IdxTy ( * Gfunc)(const InpTy & , OutTy &, const IdxTy flags  ); 
// m_guesses.push_back(GuessPair(func,exp));
class guesses
{

public:
guesses (const Gfunc  p, const StrTy & s): m_f(p),m_r(s.c_str(),REGFUK),m_string(s) {}
guesses (const StrTy & nm, const Gfunc  p, const StrTy & s): m_f(p),m_r(s.c_str(),REGFUK),m_nm(nm),m_string(s) {}
guesses (const char * nm, const Gfunc  p, const StrTy & s): m_f(p),m_r(s.c_str(),REGFUK),m_nm(nm),m_string(s) {}
const Regex & regex() const { return m_r; } 
Gfunc func() const { return m_f; } 
const StrTy & name() const { return m_nm; } 
const StrTy & pattern() const { return m_string; } 
StrTy dump(const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR2(m_nm,m_string); 
return ss.str();
}
private:

Gfunc m_f;
Regex m_r;
StrTy m_nm,m_string;
};
typedef guesses GuessPair;

typedef std::vector<GuessPair> GuessPairs;

public:
mjm_med2bib_guesses() {Init(); }
~mjm_med2bib_guesses() {}
void set_chromate_launch_flags(const IdxTy f) 
{ m_getter.set_chromate_launch_flags(f); } 
IdxTy configure(const Ragged & r) { return Init(r); } 
IdxTy configure( RaggedCursor & rc) { return Init(rc); } 
// format the bib entires in file and output or put on clipboard
IdxTy ref(const StrTy & file,const IdxTy flags)  
{ return Ref(file,flags); }
// append the bib entry in file entry to bib file "file"
IdxTy add(const StrTy & file,const StrTy & entry,const IdxTy flags)  
{ return Add(file,entry,flags); }
// guess at source(s) for bibtex based on url uin and store in dest
IdxTy guess(const StrTy & uin,const StrTy & dest,const IdxTy flags)  
{ return Guess(uin,dest,flags); }
// guess using url or filename on clipboard
IdxTy clip(const StrTy & dest, const IdxTy flags)  
{ return Guess(m_ext.get_clipboard(),dest,flags); }
// execute the search for possibly useful bibtex entries 
IdxTy guess(const InpTy & in , OutTy & out,const IdxTy flags=0 )  const
{ return Guess(in,out,flags); }
// set some regex's for selecting search strategy components 
void select(const StrTy & s, const IdxTy flags) { Select(s,flags); } 
// concert internal settings to a human readable terse string
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
static StrTy flag_to_string(const IdxTy v, const IdxTy flags)
{ return FlagToString( v, flags); } 

private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Select(const StrTy & s, const IdxTy flags)  
{
const bool skip=Bit(flags,0);
const bool only=Bit(flags,1);
const bool force=Bit(flags,2);
 try{
if( skip ) { m_skip=s; m_skipr=Regex(m_skip.c_str(),REGFUK); } 
if (only) { m_only=s; m_onlyr=Regex(m_only.c_str(),REGFUK); } 
if (force) { m_force=s; m_forcer=Regex(m_force.c_str(),REGFUK); }
MM_ERR(MMPR4(skip,only,force,flags)<<MMPR3(m_skip,m_only,m_force));
} catch (std::exception & e)
{
MM_ERR(" wtf "<<e.what()<<" Select "<<MMPR4(skip,only,force,flags)<<MMPR3(m_skip,m_only,m_force));
//throw e;
}

MM_ERR(" Select "<<MMPR4(skip,only,force,flags)<<MMPR3(m_skip,m_only,m_force));

} // Select


static  IdxTy Footest(const InpTy & in , OutTy & out )  { MM_ERR(" not impl")  return 0; } 


//void set( Getter & g, Scraper & s, Xformer & x, Finisher &  f)


static StrTy FlagToString(const IdxTy v, const IdxTy flags)
{

Ss ss;
if (flags==0) {
if (Bit(v,0)) {ss<<"show_decisions "; }
if (Bit(v,1)) {ss<<"show_trial "; }
if (Bit(v,2)) {ss<<"keep_going "; }
if (Bit(v,3)) {ss<<"collect_all "; }
if (Bit(v,4)) {ss<<"paste_citation "; }
if (Bit(v,5)) {ss<<"punt_pmc "; }
if (v>63) { ss<<"unued_bits "<<(v>>5)<<" "; } 
}
//0 : show decisions  not passed to In
//1 : show trial not passed to In
//2 : keep going after first found or defer,  not paassed to in 
//3 : collect_all hits in each handler,   becomes Bit 2 in In flags 
//4 : paste citation to clipboard at end   becomes Bit 3 in In flags
return ss.str();
} // FlagToString


// Try to find a bibtex entry for work on resource "uin" 
// and store results in dest. Validation only up to a 
// name and type  
IdxTy Guess(const StrTy & uin,const StrTy & dest,const IdxTy flags)  //  const
{
// 2023-09-29 
// needs to be url encoded? doh... 
// https://www.researchgate.net/profile/Hui-Lian-Xu/publication/360981559_Intestinal_Microflora_Changes_in_Patients_with_Mild_Alzheimer's_Disease_in_a_Chinese_Cohort/links/643df02fe881690c4bdec6f4/Intestinal-Microflora-Changes-in-Patients-with-Mild-Alzheimers-Disease-in-a-Chinese-Cohort.pdf

MM_MSG(MMPR3(uin,dest,flags))
//enum { SHOW_DEC=0, SHOW_TRY=1, KEEP_GOING=2, GET_ALL=3};
const bool collect_all=Bit(flags,3);
const bool paste=Bit(flags,4);
const bool punt_pmc=Bit(flags,5);
// TODO once one caller sets these they were  set, use a temp  doh
IdxTy mif=m_in_flags;
if (collect_all) mif|=(1<<InpTy::COLLECT_ALL);
if (paste) mif|=(1<<InpTy::PASTE);
if (punt_pmc) mif|=(1<<InpTy::PUNT_PMC);
InpTy in(this,mif,flags);
OutTy out;
in.uin(uin);
in.dest(dest);
out.uin(uin);
in.set(m_getter, m_scraper,m_xformer,m_finisher);
IdxTy rc= Guess(in,out,flags); 
MM_ERR(" probably a waste if recursion "<<MMPR(in.depth()))
IdxTy rc2= GuessResult(in,out,rc,flags);

if (mjm_global_flags::mm_delete_temps )  out.delete_temps();

return rc2;

} // guess


bool Skip(  const GuessPair & gp,const bool show) const
{
//m_r(s.c_str(),REGFUK),m_string(s) {}
// need to save 
//const Regex & r=regex(m_skip.c_str(),REGFUK);
const bool has_skip=(m_skip.length())&& mjm_cpp_regex::stuff::has(gp.name().c_str(),m_skipr,0);
const bool has_only=(m_only.length())&& mjm_cpp_regex::stuff::has(gp.name().c_str(),m_onlyr,0);
const bool only_only=(m_only.length());
if (show) { MM_ERR(MMPR4(m_skip,gp.name(),m_only,has_skip)<<MMPR2(only_only,has_only))} 
return (has_skip||(only_only&&!has_only));
}
bool Force(  const GuessPair & gp,const bool show) const
{

const bool has_force=(m_force.length())&& mjm_cpp_regex::stuff::has(gp.name().c_str(),m_forcer,0);
if (show) { MM_ERR(MMPR2(m_force,gp.name()))} 
return has_force;
}
IdxTy Guess(const InpTy & in , OutTy & out,const IdxTy flags )  const 
{  
IdxTy rc=0;
const StrTy uin=in.uin();
bool skip_handlers=false;
bool skip_guesses=false;
bool ignore_skip_force=false;
//const bool  paste_citation=in.paste_citation(); // !false; 
//enum { SHOW_DEC=0, SHOW_TRY=1, KEEP_GOING=2, GET_ALL=3};
const bool show_decisions=Bit(flags,0);
const bool show_trial=Bit(flags,1);
const bool keep_going=Bit(flags,2);

MM_ERR(MMPR(flags)<<MMPR4(show_decisions,show_trial,keep_going,uin))
// domains may not work with normalget so
// let them fetch 
if (!skip_guesses) { 
MM_LOOP(ii,m_guesses)
{
const bool skip=Skip(*ii,show_decisions);
const bool force=Force(*ii,show_decisions);
if (skip&&!force) continue;

const Regex & r=(*ii).regex();
//MM_ERR(" checking  "<<MMPR2(uin,(*ii).dump()))
const bool has= mjm_cpp_regex::stuff::has(uin.c_str(),r,0);
if (show_decisions) { MM_ERR(" checking  "<<MMPR3(has,uin,(*ii).dump())) } 
if (has||force)
{
if (show_decisions||show_trial) { MM_ERR(" trying "<<MMPR3(has,force,(*ii).dump())) } 
rc=(*ii).func()(in,out,0);
if (show_decisions) { MM_ERR(" tried "<<MMPR3(out.found(),out.defer(),rc)) } 
if (!keep_going) if(out.found()||out.defer()) break; 
if (out.recurse()) // TODO this is obsolete not used recurse from within
{
MM_ERR(" obsolete  recursion specified may not work   "<<MMPR(in.depth()))
if (in.depth()>3) 
{
MM_ERR(" recursion too deep"<<MMPR(in.depth()))
break;
}
const StrTy & nurl=out.nurl();
InpTy in2(in,nurl);
OutTy out2(out,nurl);
rc=Guess(in2,out2,flags);
MM_ERR(" return from recurions adopting now ... ")
out.adopt(out2);
if (!keep_going) if(out.found()||out.defer()) break; 
} // recurse 
} // had
}// ii
} // skip_guesses

if (!keep_going) skip_handlers|=(out.found()||out.defer());
if (!skip_handlers) { //  return rc; 
// handlers will rely on a normalget except
// for a few like headless or variants 
const StrTy fn=out.fn("normalget"); // in.ZZ
// only if missing, debug flags
//Grc grc=in.getter().normalget(fn,in.uin(),16+(show_trial?32:0));
// in reality, a prior get may have been a robot capture or 403.
// these glags are not yet the same thought... doh 
in.getter().clear(fn,0);

// need to get ftp with wget already parsed uin()

// needs "1" to dump the dom doh although could also work with
// getting the pdf which seems to occur by accident now... 
// this appears to work on a pdf file preventing from doing the download
// but don't want download first 
// so just give bad return code if the "get" got "embed" or
// application/pdf etd
// simply downloading html may fail to get the important
// parts of the doucment 
Grc grc=in.getter().headlessget(fn,in.uin(),1+(show_trial?32:0));
// right now this will fail on pdf but should AFAICT time out and
// make a zed length file for now... 
const IdxTy fnsz=in.getter().size(fn,0);
const IdxTy htmlfake=in.getter().embedded_etc(fn,0);

bool headless_failed=(fnsz<100)||(IdxTy(grc)!=0)||(htmlfake!=0);
MM_ERR(" handler get "<<MMPR4(headless_failed,fnsz,fn,StrTy(in.uin())))
if (headless_failed) 
MM_MSG(" handler get failed  "<<MMPR4(headless_failed,fnsz,fn,StrTy(in.uin())<<MMPR(htmlfake)))

if (headless_failed)
{
MM_ERRF(" trying new chromate download  "<<MMPR2(fn,StrTy(in.uin())))
in.getter().clear(fn,0);
Grc grc=in.getter().headlessdownload(fn,in.uin(),16+(show_trial?32:0));
const IdxTy fnsz=in.getter().size(fn,0);
headless_failed=(fnsz<1)||(IdxTy(grc)!=0);
if (headless_failed) 
MM_MSG(" handler download  failed  "<<MMPR4(headless_failed,fnsz,fn,StrTy(in.uin())))

} 

if (headless_failed)
{
MM_ERRF(" trying wget fall back "<<MMPR2(fn,StrTy(in.uin())))
// headless fails on pdf, but wget is being blocked but
// now chromate download works but names are a trick.. 
// https://www.researchgate.net/profile/Stanley-Brodsky-2/publication/276243137_Exclusive_Processes_and_the_Fundamental_Structure_of_Hadrons/links/57b23bd308ae15c76cbb3dfc/Exclusive-Processes-and-the-Fundamental-Structure-of-Hadrons.pdf
in.getter().clear(fn,0);
Grc grc=in.getter().normalget(fn,in.uin(),16+(show_trial?32:0));
const IdxTy fnsz2=in.getter().size(fn,0);
MM_ERR(" handler wget "<<MMPR4(headless_failed,fnsz2,fn,StrTy(in.uin())))
MM_MSG(" last chance  handler wget "<<MMPR4(headless_failed,fnsz2,fn,StrTy(in.uin())))

} // headless_failed

MM_LOOP(ii,m_handlers)
{
const bool skip=Skip(*ii,show_decisions);
const bool force=Force(*ii,show_decisions);
if (skip&&!force) continue;
if ( show_decisions||show_trial) { MM_ERR("trying "<<MMPR((*ii).name())) } 
const IdxTy rc=(*ii).func()(in,out,0);
if ( show_decisions) { MM_ERR(" tried "<<MMPR3(in.collect_all(),(*ii).name(),StrTy(in.uin()))<< MMPR4(in.depth(),out.found(),out.defer(),rc)) } 
if (!keep_going) if(out.found()||out.defer()) break; 
}// ii 
} // skip_handlers 
return rc;
}

IdxTy GuessResult(const InpTy & in , OutTy & out,IdxTy & rc, const IdxTy flags )  const 
{
const bool  paste_citation=in.paste_citation(); // !false; 
//const bool show_decisions=Bit(flags,0);
//const bool show_trial=Bit(flags,1);
const IdxTy nfound=(out.found()) ;
Ss ss;
for(IdxTy i=0; i<nfound; ++i)
{
ss<<out.preview(i);
ss<<CRLF;
} // found
MM_MSG(ss.str());
const StrTy & df=in.dest();
if (df.length()) 
{ Blob b(ss.str()); 
Blob s(ss.str());
Ao ao;
m_finisher.safe_final_assembly(b,s,ao);
b.save(df); 
MM_MSG(" saving to "<<MMPR(df));
} // df.length() 
//if ( paste_citation)
{
const bool something=(nfound ||out.cite_anyway());
//StrTy cite="\\cite{";
//if (out.found()) cite+=out.name(0);
//else if ( out.cite_anyway()) cite+=out.cite();
//cite+="}";
StrTy nm;
if (out.found()) nm=out.name(0);
else if ( out.cite_anyway()) nm=out.cite();
StrTy cite=MakeCitation(nm,0);

MM_MSG(" have citation  "<<MMPR4(nfound,cite,something,paste_citation))
if ( paste_citation&& something ) m_ext.paste(cite);

} 
return rc; 
} 

StrTy MakeCitation(const StrTy & n, const IdxTy flags) const
{
StrTy cite="\\cite{";
cite+=n;
cite+="}";
return cite;
}

void AddPair(const char * nm, const Gfunc  p, const StrTy & s) {
//MM_ERR(" adding "<<MMPR2(nm,s))
// TODO try-catch around ctor wtf 
try { 
m_guesses.push_back(GuessPair(nm,p,s)); 
} catch (std::exception & e)
{
MM_ERR(" wtf "<<e.what()<<" adding "<<MMPR2(nm,s))
//throw e;
}

} // AddPair
void AddHandlerPair(const char * nm, const Gfunc  p, const StrTy & s) {
//MM_ERR(" adding "<<MMPR2(nm,s))
// TODO try-catch around ctor wtf 
try { 
m_handlers.push_back(GuessPair(nm,p,s)); 
} catch (std::exception & e)
{
MM_ERR(" wtf "<<e.what())
throw e;
}

} // AddHandlerPair

#define COLOR_OUT typedef char Ch; const Ch  e1[]={Ch(27),'[','4','4','m',0}; const Ch  e1a[]={Ch(27),'[','4','2','m',0}; const Ch  e1b[]={Ch(27),'[','4','1','m',0}; const Ch  e2[]={Ch(27),'[','0','m',0}; StrTy _blue=StrTy(e1); StrTy _green=StrTy(e1a); StrTy _red=StrTy(e1b); StrTy _end=StrTy(e2);

IdxTy Ref(const StrTy & file,const IdxTy flags)  
{
COLOR_OUT
IdxTy rc=0;
const bool append_bad=Bit(flags,3); // continue if bad  
const bool paste_citation=Bit(flags,4); // update clipboard  
const bool return_long_form=Bit(flags,5); // update clipboard  
// first insure validity to some level
Blob b;
b.load(file);
Frc frc=m_finisher.parse(b,file,"",0);
Frc frcb=m_finisher.validate(b,file,"",0);
const IdxTy ifrc=IdxTy(frc);
const IdxTy ifrcb=IdxTy(frcb);
const IdxTy ift=ifrc+ifrcb;
if (ift) { MM_ERR(MMPR2(IdxTy(frc),IdxTy(frcb)))  }
const StrTy & rendered=frcb.rendered();
const StrTy & output=frcb.latex_output();
const StrTy & vfn=frcb.validation_fn();
// want to remove crlf except between refs.. 
MM_ERR(MMPR(rendered))
Hand hand;
Blob o,e,d;
d=rendered;
// with 200in paper all should be on one line and breaks are ambiguous 
StrTy cmd="awk 'BEGIN{p=0;idx=1}{ key=\"[\"idx\"]\"; if (p==1){y=$0; if ($1==key) {idx=idx+1; print x; x=$0;} else {x=x\" \"y;}  } else  { if ($0==\"References\") { p=1; } }}END{if (x!=\"\") print x } ' ";
 IdxTy rch=hand.fileio(o,e,d,cmd);
StrTy fixed=StrTy(o);
if (fixed.length()==0)
{
MM_MSG(" no output for ref but input was "<<MMPR(rendered))
}
StrTy err=StrTy(e);
if (err.length()) rc=1;
if (rc ) {  MM_MSG(_red<< err<<_end); } 
MM_MSG(CRLF<<fixed)
if (rc) if ( !append_bad) return rc;
const bool custom_from_entry=true;
if (custom_from_entry)
{
// copy to make canonical... 
BibEntry be=frc.be();
typedef typename Fields::parsed_names_class Pnc;
Pnc pnc;
Fields x;
x.parse_names(pnc,be.get("author"),0);
//MM_LOOP(ii,pnc){ MM_ERR(MMPR(*ii)) } 
StrTy sal=x.short_author_list(pnc,0);
StrTy jou=be.get("journal");
StrTy doi=be.get("doi");
 doi+=be.get("DOI"); // canonical keys?
StrTy title=be.get("title");
StrTy src=be.get("srcurl");
StrTy year=be.get("year");
 year+=StrTy(" ")+be.get("date");
Ss ss,sd;
sd<<MMPR4(src,title,jou,sal)<<MMPR(year) ;
ss<<"[1]"<<title<<", "<<sal<<"; "<<jou<<". "<<year<<CRLF ; // MMPR4(src,title,jou,sal)<<MMPR(year) ;
ss<<src<<CRLF;
//ss<<doi<<CRLF;
MM_MSG(" simple form "<<CRLF<<(ss.str())) 
MM_MSG(" simple form  alt "<<MMPR(sd.str())) 
if (paste_citation&&!return_long_form) m_ext.paste(ss.str());
return rc;
}

if (paste_citation) m_ext.paste(fixed);
return rc;
} // Ref

// Add entry to file if it is valid and not a duplicate
// in that file
IdxTy Add(const StrTy & file,const StrTy & entry,const IdxTy flags)  
{
COLOR_OUT

// for reference, lower bits used in Append 
//const bool stem_only=Bit(flags,0); // use old "non_pmc" prefix etc
//const bool show_dups=Bit(flags,1); // if there is a dup name show it 
//const bool append_dups=Bit(flags,2); // update file even if dup 
const bool append_bad=Bit(flags,3); // update file even if  bad 
const bool paste_citation=Bit(flags,4); // update file even if  bad 
// first insure validity to some level
Blob b;
b.load(entry);
Frc frc=m_finisher.parse(b,entry,"",0);
Frc frcb=m_finisher.validate(b,entry,"",0);
const IdxTy ifrc=IdxTy(frc);
const IdxTy ifrcb=IdxTy(frcb);
const IdxTy ift=ifrc+ifrcb;
if (ift) { MM_ERR(MMPR2(IdxTy(frc),IdxTy(frcb)))  }
const StrTy & rendered=frcb.rendered();
const StrTy & output=frcb.latex_output();
const StrTy & vfn=frcb.validation_fn();

//const IdxTy rcc=IdxTy(frc)+IdxTy(frcb);
const bool failed=(ift!=0)||(rendered.length()==0);
if (false&&failed) MM_ERR(output)
if (rendered.length()!=0) MM_MSG(rendered)
MM_MSG( " see "<<MMPR(vfn)<< " for more details on latex ")
if (failed) {
if (IdxTy(frc)!=0)
{
const BibEntry & be=frc.be();
MM_MSG(be.dump_errors(3)) ;
} 
if (!append_bad) {MM_MSG(_red<<" bad bib not adding "<<MMPR3(ifrc,ifrcb,rendered.length())<<_end ) 
return ift;
}
else {
MM_MSG(_blue<<" bad bib adding anyway  "<<MMPR3(ifrc,ifrcb,rendered.length())<<_end )
}
//if (!append_bad) return ift;
} // failed  

BibEntry&  bib=frc.be();
AppendBibtex(file,b,bib,flags);
if ( paste_citation) 
{
StrTy cite=MakeCitation(bib.name(),0);
m_ext.paste(cite);
}

return 0; 
} // Add

IdxTy AppendBibtex(const StrTy & file, const Blob & b,BibEntry & bib , const IdxTy flags)
{

COLOR_OUT
const bool stem_only=Bit(flags,0); // use old "non_pmc" prefix etc
const bool show_dups=Bit(flags,1); // if there is a dup name show it 
const bool append_dups=Bit(flags,2); // update file even if dup 
MM_ERR(MMPR4(flags,stem_only,show_dups,append_dups))
BibMap map;
// then see if file is complete or stem for pmc/non_pmc
StrTy fullfile=file;
if (fullfile.length()==0) 
{
MM_ERR(" blank file name just exit")
return 0;
}
if (stem_only)
{
Hand hand;
Blob o,e,d;
StrTy cmd="echo -n `basename \""+file+"\"`";
 IdxTy rc=hand.fileio(o,e,d,cmd);
MM_ERR("basename "<<MMPR4(rc,StrTy(o),StrTy(e),StrTy(d)))
StrTy basefile=StrTy(o);
cmd="echo -n `dirname \""+file+"\"`";
rc=hand.fileio(o,e,d,cmd);
MM_ERR("dirname "<< MMPR4(rc,StrTy(o),StrTy(e),StrTy(d)))
StrTy dirfile=StrTy(o);
//toobib$ echo PMC1234 | grep "^\(PMC\|PMIUD\)[0-9]*$"
OutTy out;
StrTy pmc=MutateOnly(bib.name(),"grep \"^\\(PMC\\|PMID\\)[0-9]*$\"",out);
if (pmc.length())
 fullfile=dirfile+StrTy("/pmc_")+basefile+StrTy(".bib");
else  fullfile=dirfile+StrTy("/non_pmc_")+basefile+StrTy(".bib");

} // stem_only  
MM_ERR(MMPR(fullfile))
// finally parse the file and make sure the name is
// not duplicated. 
map.parse(fullfile);
IdxTy total=map.size();
IdxTy exists=map.size(bib.name());
// then finally just append it
if (exists)
{
MM_MSG(_red<<" name already found "<<MMPR3(fullfile,exists,bib.name())<<_end)
BibEntry * bep=map[bib.name()];
if ( bep==0) 
{ MM_ERR(" logic or curruption, bibtex file messed up "<<MMPR(bib.name())) }
else{
if (show_dups) { 
MM_MSG(" existing entry "<<(*bep).format())
MM_MSG(" candidate  entry "<<StrTy(b))
} // show_dups
}
if (!append_dups)
{
MM_MSG(" add flag bit append_dups, 1<<2,  to add anyway ")
 return 1;
}
} // exists
if (file.length()!=0)
{
MM_MSG(_green<<" writing  "<<MMPR3(fullfile,exists,bib.name())<<_end )
std::ofstream ofs(fullfile,std::ios_base::app);
ofs<< StrTy(b);
ofs<<CRLF;
const bool ok=ofs.good();
if (!ok){ MM_MSG(" updating bibtex file "<<MMPR(fullfile)<< " may have failed") } 
return ok?0:1; 
}
else {  MM_MSG(_blue<<" blank file not saving "<<_end)  }
return 0;

} // AppendBibtex

#undef COLOR_OUT

#if 0
2101  cat `which med2bib` | grep -v "^#\||" |  grep regexname | sed -e 's/.*regexname//' | sed -e 's/"//g'  | awk '{print " static  IdxTy "$2"(const InpTy & in , OutTy & out )  { MM_ERR(\" not impl\")  return 0; }"}' >> mjm_med2bib_funcs.h

cat `which med2bib` | grep handlers= | sed -e 's/[^"]*"//'| sed -e 's/"//' | sed -e 's/.handlers//g'  |  awk '{print " static  IdxTy "$1"(const InpTy & in , OutTy & out )  { MM_ERR(\" not impl\")  return 0; }"}' >> mjm_med2bib_handlers.h


#endif

#include "mjm_med2bib_funcs.h"
#include "mjm_med2bib_handlers.h"
// not called by any ctor , just configure 
IdxTy Init( RaggedCursor & rc) { 
typedef mjm_ragged_config * CfgPtr;
typedef std::map<StrTy, CfgPtr> CfgMap;
CfgMap cfm;
cfm["getter"]=& m_getter;


return 0 ; // Init(rc); 
} 

IdxTy Init(const Ragged & r) { 

//GuessPairs m_guesses;
//GuessPairs m_handlers;
//StrTy m_skip,m_only,m_force;
//Regex m_skipr,m_onlyr,m_forcer;
//IdxTy m_in_flags;
//Getter m_getter; //  get things off the web like pages or crossref etc 
//Scraper m_scraper; // scrape doi or similar content from blob or file 
//Xformer m_xformer; // render or pdftotext etc format conversions 
//Finisher m_finisher; // clean up possible bibtex entries 
//mutable Ext m_ext; // execute external largely bash programs 
Init(RaggedCursor(r));

return 0; 

} // Init(Ragged) 

// called by ctor
void Init()
{
m_in_flags=0;
//Gfunc x=&Myt::Footest;
//MM_ERR(MMPR(x))
#if 0 
cat `which med2bib` | grep -v "^#\||" |  grep regexname | sed -e 's/.*regexname//' | sed -e 's/"//g'  | awk '{print " AddPair(\""$2"\",&Myt::"$2",\""$1"\"); "}' > mjm_med2bib_vector.h
cat `which med2bib` | grep handlers= | sed -e 's/[^"]*"//'| sed -e 's/"//' | sed -e 's/.handlers//g'  |  awk '{print " AddHandlerPair(\""$1"\",&Myt::"$1",\""$1"\"); "}' >> mjm_med2bib_hvec.h
#endif
// load the known search methods onto search stacks
// mostly domain specific things 
#include "mjm_med2bib_vector.h"
// handlers
#include "mjm_med2bib_hvec.h"
} // Init 
// MEMBERS
// domain related
GuessPairs m_guesses;
// general things to try for many domains 
GuessPairs m_handlers;

// include and exclude different types of tests
StrTy m_skip,m_only,m_force;
Regex m_skipr,m_onlyr,m_forcer;

IdxTy m_in_flags;

Getter m_getter; //  get things off the web like pages or crossref etc 
Scraper m_scraper; // scrape doi or similar content from blob or file 
Xformer m_xformer; // render or pdftotext etc format conversions 
Finisher m_finisher; // clean up possible bibtex entries 
mutable Ext m_ext; // execute external largely bash programs 

}; // mjm_med2bib_guesses

//////////////////////////////////////////////

template <class Tr>
class mjm_med2bib_guesses_map : public std::map<typename Tr::StrTy, mjm_med2bib_guesses< Tr > >  
{
 typedef mjm_med2bib_guesses_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_med2bib_guesses< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_med2bib_guesses_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_med2bib_guesses_map




////////////////////////////////////////////
#ifdef  TEST_MJM_MED2BIB_GUESSES
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_med2bib_guesses <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MED2BIB_GUESSES "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_med2bib_guesses<Tr>  Myt;
typedef mjm_pawnoff<Tr>  Hand;
typedef mjm_blob<Tr>  Blob;
Hand h;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="add") { x.add(cip.p1,cip.p2.c_str(),atoi(cip.wif(3).c_str()));  }
if (cmd=="select") { x.select(cip.p1,atoi(cip.p2.c_str()));  } // Select
if (cmd=="skip") { x.select(cip.p1,1);  } // Select
if (cmd=="only") { x.select(cip.p1,2);  } // Select
if (cmd=="force") { x.select(cip.p1,4);  } // Select
if (cmd=="guess") { x.guess(cip.p1,cip.p2.c_str(),atoi(cip.wif(3).c_str())); MM_ERR(x.dump()) }
if (cmd=="clip") {
MM_ERR(" in clip ")
 x.clip(cip.p1.c_str(),strtod(cip.p2.c_str(),0)); MM_ERR(x.dump()) 
MM_ERR(" done clip ")

}
if (cmd=="?") { 
MM_MSG(" quit dump add select skip only force guess clip ? h")

continue ; 
} // ? 
if (cmd=="h") { 
Blob d,o,e,c;
Blob cc;
cc.load(cip.p1.c_str());
StrTy rcmd=StrTy(cc);
IdxTy flag=strtod(cip.p2.c_str(),0);
IdxTy rc=h.fileio(o,e,d,rcmd,flag);
MM_ERR(MMPR3(rc,flag,rcmd)<<MMPR4(StrTy(d),StrTy(e),StrTy(o), StrTy(c))) 

}
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#undef REGFUK 
#endif // MJM_MED2BIB_GUESSES_H__ 
