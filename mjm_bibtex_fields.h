#ifndef MJM_BIBTEX_FIELDS_H__
#define MJM_BIBTEX_FIELDS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_collections.h"
#include "mjm_misc_parse.h"
#include "mjm_strings.h"
#include "mjm_unicode_latex.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Aug 26 09:58:07 EDT 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibtex_fields   
// g++  -Wall -std=gnu++11 -DTEST_MJM_BIBTEX_FIELDS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibtex_fields.h  -lpthread -lreadline


mjm_global_credits::credit __credit_mjm_bibtex_fields("mjm_bibtex_fields"
, " http://milde.users.sourceforge.net/LUCR/Math/data/unimathsymbols.txt ");




template <class Tr>
class mjm_bibtex_fields 
{
 typedef mjm_bibtex_fields Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_ragged_table Ragged;

typedef mjm_var_parse<Tr> ParseTable;
enum {UC=ParseTable::UC, LC=ParseTable::LC, DIGIT=ParseTable::DIGIT };

class _char_latex_desc
{
public:
_char_latex_desc(): m_u(~0) {}
_char_latex_desc(const IdxTy u, const StrTy & ltx, const StrTy & misc)
: m_u(u),m_latex(ltx),m_misc(misc) {}
const StrTy & latex() const { return m_latex;}
StrTy dump() const 
{
Ss ss;
ss<<MMPR3(m_u,m_latex,m_misc);
return ss.str();
} // dump

IdxTy m_u;
StrTy m_latex, m_misc;

}; // _char_latex_desc
typedef _char_latex_desc char_latex_desc;

typedef std::map<IdxTy, char_latex_desc> ConvMap;

#define GETSET(x,y) StrTy & x() { return y; } const StrTy & x() const { return y;} 
class DateClass
{
typedef std::map<StrTy,StrTy> MoTy;
static MoTy & month_lut()
{
static MoTy x=months();
return x; 
}
static MoTy & months()
{
static  MoTy m;
m["January"]= "1";
m["Jan"]= "1";
m["February"]= "2";
m["Feb"]= "2";
m["March"]= "3";
m["Mar"]= "3";
m["April"]= "4";
m["Apr"]= "4";
m["May"]= "5";
m["June"]= "6";
m["Jun"]= "6";
m["July"]= "7";
m["Jul"]= "7";
m["August"]= "8";
m["Aug"]= "8";
m["September"]= "9";
m["Sept"]= "9";
m["Sep"]= "9";
m["October"]= "10";
m["Oct"]= "10";
m["November"]= "11";
m["Nov"]= "11";
m["December"]= "12";
m["Dec"]= "12";
return m;
} // months

public:
DateClass()  { m_zed=true; } 
GETSET(year,m_y)
GETSET(month,m_m)
GETSET(day,m_d)
const bool is_zed() const { return m_zed; } 
const bool has_year() const { return m_y.length(); }
const bool has_month() const { return m_m.length(); }
const bool has_day() const { return m_d.length(); }
StrTy best(const StrTy & sep="/",const IdxTy flags=0) const 
{ return Best(sep,flags); } 
StrTy lexi(const StrTy & sep="/") const 
{ return Lexi(sep); } 
const bool valid(const IdxTy lvl=0) const { return Valid(lvl); }
const bool sepp(const StrTy & s) const { return (s=="/")||(s=="-"); } 
typedef std::vector<IdxTy> Pos;
template <class Ty, class P > IdxTy parse(const Ty & v, const P& clut)
{
// first see if this works, 
// dateaccepted = {2018-09-25T06:58:02Z},
const IdxTy vz=v.size();
if (vz==7) // yyyy-mm 
{
if (v[0].length()==4)if(sepp(v[1])) 
if (v[2].length()==2)
{
MM_LOOP(ii,v)  m_s+=(*ii); 
 m_y=v[0];
m_m=v[2];
m_zed=false; // 2022-11-01
return 0;
} // sizes 

} //  vz==3
if ( vz==12)
{
m_zed=false;
if (v[1]=="-") if (v[3]=="-") if (v[9]==":") if (v[7]==":") 
{
MM_LOOP(ii,v)  m_s+=(*ii); 
 m_y=v[0];
m_m=v[2];
m_d=v[4];
return 0; 
} // delims ok 
} // 12 
//Pos m_alpha,m_col,m_bad,m_sep,n_one,m_four,m_two;
//Pos alpha,col,bad,sep,one,four,two;
Pos& alpha=m_alpha;
Pos& col=m_col;
Pos& bad=m_bad;
Pos& sep=m_sep;
Pos& one=m_one;
Pos& four=m_four;
Pos& two=m_two;

IdxTy i=0;
MM_LOOP(ii,v)
{
const auto & x=(*ii);
m_s+=x;
if (x.length()) m_zed=false;
const char * p=x.c_str();
const IdxTy sz=x.length();
// typename ParseTable::Iv cc=clut.lut(*p);
if (clut.mask(*p,UC|LC)) {
alpha.push_back(i);
}
else if (clut.mask(*p,DIGIT)) {
if (sz==2) two.push_back(i);
else if (sz==4) four.push_back(i);
else if (sz==1) one.push_back(i);
 }// DIGIT
else if (*p=='/') sep.push_back(i);
else if (*p=='-') sep.push_back(i);
else if (*p==' ') sep.push_back(i);
else if (*p==',') sep.push_back(i);
else if (*p==':') col.push_back(i);
else bad.push_back(i);

++i;
} // ii 
const IdxTy szf=four.size();
const IdxTy szt=two.size();
const IdxTy szo=one.size();
const IdxTy szs=sep.size();
const IdxTy sza=alpha.size();
if ( szs==0){  if(szf==1) { m_y=v[four[0]]; return 0; } }
else if ( szs==1)
{
 if(szf==1) { m_y=v[four[0]]; return 0; } 
 if(szt==1) { m_m=v[two[0]]; return 0; } 

} // sz==1
else if ( szs==2)
{
 if(szf==1) { m_y=v[four[0]];  } 
if (sza==1)
{
m_m=month_lut()[v[alpha[0]]]; 
if (szo==1) m_d=v[one[0]];
if (szt==1) m_d=v[two[0]];

return 0;
} 
if(szt==2) { m_m=v[two[0]]; m_d=v[two[1]]; return 0; } 
 if(szo==2) { m_m=v[one[0]]; m_d=v[one[1]]; return 0; } 
 if(szo==1)if (szt==1)  { 
if(one[0]<two[0]) { m_m=v[one[0]]; m_d=v[two[0]];  }
else{ m_d=v[one[0]]; m_m=v[two[0]]; }

return 0; } 

} // sz==2

return 0; 
}
StrTy dump(const IdxTy flags=0) const 
{
Ss ss;
ss<<MMPR(m_zed);
ss<<MMPR4(m_s,m_y,m_m,m_d);
ss<<MMPR4(best(),has_day(),has_month(),has_year());
return ss.str();
} // dump 
StrTy Best(const StrTy & sep="/",const IdxTy flags=0) const 
{
StrTy a;
if (m_y.length()==0) { return m_s;}
// 
a=m_y;
if (m_d.length()) a=m_d+"/"+a;
if (m_m.length()) a=m_m+"/"+a;
return a;
} // Best
StrTy Lexi(const StrTy & sep="/") const 
{
return m_y+sep+m_m+sep+m_d; 
} // Lexi

const bool Valid(const IdxTy lvl=0) const { 


return true; // Valid(lvl); 

}

StrTy m_s, m_y,m_m,m_d;
bool m_zed;
Pos m_alpha,m_col,m_bad,m_sep,m_one,m_four,m_two;

}; // DateClass


class NameClass
{
public:
NameClass() {}
NameClass(const StrTy & src) {m_src=src;}
//StrTy & first() { return m_first;}
GETSET(first,m_first)
GETSET(last,m_last)
GETSET(middle,m_middle)
GETSET(title,m_title)
void add_last(const StrTy x)
{
if (m_last.length()) m_last+=" ";
m_last+=x; 
}
void add_middle(const StrTy x)
{
if (m_middle.length()) m_middle+=" ";
m_middle+=x; 
}



StrTy dump( const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR4(m_first,m_last,m_middle,m_title)<<MMPR(m_src);
return ss.str();
}
StrTy format(const IdxTy flags=0) const
{
Ss ss;
const IdxTy ml=m_last.length();
const IdxTy mf=m_first.length();
const IdxTy mm=m_middle.length();
const IdxTy tt=m_title.length();
if (flags==0)
{
ss<<m_last;
if (tt) { if (ml) ss<<" "; ss<<m_title; } 
if ((ml||tt)&&(mf||mm)) ss<<" , ";
if (mf) ss<<m_first;
if (mm) ss<<" "<<m_middle;
return ss.str();
} // flags==0
{
ss<<m_first;
if (mf&&(mm+ml)) ss<<" ";
if (mm) ss<<m_middle;
if (ml&&(ss.str().length())) ss<<" ";
if (ml) ss<<m_last;
} 
return ss.str();
} // format
private:
void Init()
{
m_first=""; m_last=""; m_middle=""; m_title=""; m_src=""; 
}
StrTy m_first, m_last,m_middle,m_title;
StrTy m_src;

}; // NameClass

typedef mjm_strings StrUtil;
typedef mjm_unicode_latex<Tr> UniLa;
public:
mjm_bibtex_fields() {}
~mjm_bibtex_fields() {}

typedef NameClass name_type;
typedef DateClass date_type;
typedef std::vector<name_type> parsed_names_class;
typedef std::vector<date_type> parsed_dates_class;

typedef std::vector<StrTy> Sv;
template <class Ti>
IdxTy load_ragged(Ragged & r, Ti & ii, const Ti & ee) const
{ return  LoadRagged( r,  ii,  ee) ; } 

IdxTy load_xlate(const StrTy & fn, const IdxTy flags)
{ return  LoadXlate( fn,  flags); }

IdxTy utf8_to_latex(StrTy & d, const StrTy &s, const IdxTy flags) const
{
return UTF8ToLatex(d,s,flags) ; 
}
IdxTy html_to_latex(StrTy & d, const StrTy &s, const IdxTy flags) const
{
return HTMLToLatex(d,s,flags) ; 
}
// remove arcane or idiosyncratic latex in bib fields 
IdxTy latex_to_latex(StrTy & d, const StrTy &s, const IdxTy flags) const
{
return LatexToLatex(d,s,flags) ; 
}


IdxTy deal_with_non_ascii(StrTy & d, const StrTy &s, const IdxTy flags) const
{ return DealWithNonAscii( d, s, flags); }
IdxTy add_query(StrTy & d,  const StrTy &  urlq, const StrTy & s,const IdxTy flags)
{ return  Addquery( d , urlq, s, flags) ; }

IdxTy parse_dates(parsed_dates_class & pdc, const StrTy &s, const IdxTy flags)
{
return ParseDates(pdc,s,flags);

}

IdxTy parse_names(parsed_names_class & pnc, const StrTy & s, const IdxTy flags) const 
{
return ParseNames(pnc,s,flags);
}
StrTy short_author_list(const parsed_names_class & pnc, const IdxTy flags) const
{
return ShortAuthorList( pnc,  flags);
}
IdxTy fix_doi(StrTy& rc, const StrTy & d, const IdxTy flags) const 
{ return FixDoi(rc,d,flags); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
bool Mask(const IdxTy f, const IdxTy m) const  { return  ((f&m))!=0; }
static int myatoi(const StrTy & s ) { return myatoi(s.c_str()); }
static int myatoi(const char * c) { return ::strtol(c,0,0); }

IdxTy FixDoi(StrTy & rc,const StrTy & d, const IdxTy flags) const 
{
const bool warn_change=!Bit(flags,0);
const bool warn_bad=!Bit(flags,1);
const bool keep_bad=!Bit(flags,2);
const IdxTy len=d.length();
const char * p=d.c_str();
char c[len+1];
IdxTy pc=0;
IdxTy i=0;
bool saving=false;
while (i<len)
{
char cp=p[i];
if (cp<32) { ++i; continue; }
//MM_ERR("  "<< MMPR4(cp,p[i+1],(cp=='1'),(p[i+1]=='0')))
if (!saving ) if  (cp=='1') if (p[i+1]=='0') 
{
saving=true;
} 
if (saving) { c[pc]=p[i]; ++pc; ++i;  continue; }
++i;
} // i

c[pc]=0;
rc=StrTy(c);
//MM_ERR("  "<<MMPR2(rc,c))
IdxTy rci=0;
if (rc!=d) rci|=1;
if (!saving) rci|=2;

if (warn_change) if (rc!=d) { MM_ERR(" doi changed "<<MMPR2(rc,d)) } 
if (warn_bad) if (!saving) { MM_ERR(" doi may be bad  "<<MMPR2(rc,d)) } 
if (keep_bad) if (!saving) { rc=d; } 
return rci;
} // FixDoi


StrTy ShortAuthorList(const parsed_names_class & pnc, const IdxTy flags) const
{
//MM_LOOP(ii,pnc) { MM_MSG(MMPR((*ii).dump(0))) } 

const IdxTy sz=pnc.size();
if (sz==0) return "";
if (sz==1)  return pnc[0].format(0);
if (sz==2)  return pnc[0].format(0)+" and "+pnc[1].format(0);
return pnc[0].format(0)+"[ ...] "+pnc[sz-1].format(0);
} // ShortAuthorList
public:
StrTy canon_author_list(const parsed_names_class & pnc, const IdxTy flags) const
{
const IdxTy fc=0;
MM_LOOP(ii,pnc) { MM_ERR(MMPR((*ii).dump(0))) } 
Ss ss;
const IdxTy sz=pnc.size();
if (sz==0) return "";
ss<< pnc[0].format(fc);
for(IdxTy i=1; i<sz; ++i) ss<<" and "<<pnc[i].format(fc);
return ss.str();
} // canon_author_list



private:



IdxTy LoadXlate(const StrTy & fn, const IdxTy flags)
{
// http://milde.users.sourceforge.net/LUCR/Math/data/unimathsymbols.txt
Ragged r;
r.load_params(1,0,"^");
r.load(fn,0);
MM_ERR(r.dump())
for(IdxTy i=0; i<r.size(); ++i)
{
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
if (len<3) continue;
if (l[0].c_str()[0]=='#') continue;
if (l[0].length()!=5) continue;
const IdxTy u=myatoi(StrTy("0x"+l[0]));
const StrTy & latex=l[2];
StrTy desc="";
for(IdxTy j=3; j<len; ++j) desc+=l[j]+" ";
char_latex_desc cld(u,latex,desc);
m_conv[u]=cld;
MM_ERR(MMPR2(i,cld.dump()))
} // i 

return 0;
}
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// typename ParseTable::Iv v=m_clut.lut(c);
// Find things like long words, acronyms, etc in a title
// avoid vocab freq list
IdxTy ClassifyStr(const StrTy & s ,const IdxTy flags) const 
{
const IdxTy sz=s.length();
const char * p=s.c_str();


return 0;
} // ClassifyStr

// try to extract names from a bib entry author list
// TODO need to get "," used as " and "
/*

 http://www.cssjj.com.cn/EN/10.16265/j.cnki.issn1003-3033.2021.03.020
@article{LINXiaofei_Model_construction_analysis_2021,
author = {LIN Xiaofei  LIN Biyi SONG Shouxin YU Xiao , SHEN Fan},
author_orig = {LIN Xiaofei, LIN Biyi, SONG Shouxin, YU Xiao, SHEN Fan},
authors = {LIN Xiaofei, LIN Biyi, SONG Shouxin, YU Xiao, SHEN Fan},


*/


IdxTy ParseNames(parsed_names_class & pnc, const StrTy & s, const IdxTy flags) const 
{
Ragged r;
LoadRagged(r,s);
MM_ERR(MMPR(r.dump()))
MM_SZ_LOOP(i,r,rsz)
{
const Ragged::Line & l=r[i];
Sv w;
MM_SZ_LOOP(j,l,sz)
{
const StrTy & x=l[j];
// need to check spaces and really braces
// should not be any terminal ands'
const bool f=(j>0);
const bool e=((j+1)<sz);
// this should evaluate l to r lol 
// but doh! the white space concats... 
if ((f && e ) && (x=="and")&&(l[j-1].c_str()[0]==' ')&&(l[j+1].c_str()[0]==' ')) 
{ AssembleName(pnc,w,0); w.clear(); } 
else
{ // parsing was done on char groups, need to recreate latex commands etc. 
// either this is a space or the prior one is...
const char c=x.c_str()[0];
const bool delim=(c==' ')||(c==',');
bool can_cling=(w.size());
if (can_cling)
{
const StrTy & y=w.back();
const IdxTy ly=y.length();
const char *  py=y.c_str();
if (ly!=0)  { 
const bool ydelim=(py[ly-1]==' ')||(py[ly-1]==',');
if (ydelim) can_cling=false;

} // ly
else can_cling=false;
} // cling
if (!delim&&can_cling) w.back()+=x;
else w.push_back(x);

} // else 

} // j 
if (w.size()) AssembleName(pnc,w,0);
} // i 

return 0; 
} // ParseNames

IdxTy AssembleName(parsed_names_class & pnc, const Sv & w, const IdxTy flags) const
{
name_type nt;
const IdxTy rv=AssembleName(nt,w,flags);
pnc.push_back(nt);
MM_ERR(MMPR(nt.dump()))
return rv;
}
/*
types : f,m,l,t 
orders: f m l t  ; l t, f m ; l , f m t ; l , f t ; f l ; f l t 

F. M. Last Title 
McDonald vs PhD or MsC etc DVM etc 

Last names may be in pieces apparently

*/
class attrib_name
{
public:
attrib_name(): m_period(false),init_cap(false), non_init_cap(false), len(s.length()),ncaps(0) {} 
void set_period(const bool x) { m_period=x; } 
bool period() { return m_period; } 
bool single() const { return len==1; } 
bool nic() const { return non_init_cap; }
const StrTy & str() const { return s; }  
template <class Tl > void set_string(const StrTy & x, const Tl & clut)
{
const IdxTy xlen=x.length();
const char * pp=x.c_str();
IdxTy ucc=0;
IdxTy icc=0;
if  (*pp) { if (clut.mask(*pp,UC)) ++icc; ++pp; }
while (*pp) { if (clut.mask(*pp,UC)) ++ucc; ++pp; }
non_init_cap=(ucc);
init_cap=(icc);
len=xlen;
ncaps=ucc+icc;
s=x;
} // set_string 

//const IdxTy qlen2=q2.length();
//bool pfxmaybe= (qlen<qlen2);
//const char * pp=q2.c_str();
//IdxTy ucc=0;
//while (*pp) { if (m_clut.mask(*pp,UC)) ++ucc; ++pp; }
//bool allcaps=(ucc>=(qlen2-1))||(ucc>2);
//bool as_name=pfxmaybe||!allcaps;
StrTy dump()
{
Ss ss;
ss<<MMPR4(m_period,init_cap,non_init_cap,len);
ss<<MMPR2(ncaps,s);
return ss.str();

}

 StrTy s;
bool m_period, init_cap, non_init_cap;
IdxTy len,ncaps;

}; // attrib_name

class list_attrib_name
{
public:
list_attrib_name(): comma(false),pcomma(~0),non_init_cap(0), singles(0),periods(0) {} 

bool comma;
IdxTy pcomma;
IdxTy non_init_cap;
IdxTy singles,periods;
}; // list_attrib_name

// TODO FIXME multiple middle initials, A. B. are not handled
// right 
IdxTy AssembleName(name_type & name, const Sv & _w, const IdxTy flags) const
{
IdxTy rc=0;
list_attrib_name  lan;
std::vector<attrib_name> van;
Sv w;
FixParses(w,_w,0);
const IdxTy len=w.size();
for(IdxTy i=0; i<len; ++i) 
{ 
const StrTy & wi=w[i];
const IdxTy wilen=wi.length();
const char c =wi.c_str()[0];
if ( c==0 ) {continue; }
//if ( (unsigned char)(c)>127 ) {continue; }
if ( c==' ') {continue; }
if ( c=='\t') {continue; }
if ( c=='.') {   continue; }
if ( c==',') {if (lan.comma) rc|=1;  lan.comma=true; lan.pcomma=van.size();  continue; }
attrib_name an;
an.set_string(wi,m_clut);
// the period is now part of the initial too 
for (IdxTy ic=0; ic<wilen ; ++ic) {if ( wi.c_str()[ic]=='.') { ++lan.periods;  an.set_period(true); }  } 
if ( (i+1)<len) if (w[i+1]==".") { ++lan.periods;  an.set_period(true); } 
van.push_back(an);
if (len==1) ++lan.singles;
MM_ERR(MMPR2(van.size(),van.back().dump()))
} // i 
const IdxTy vsz=van.size();
const IdxTy pcomma=lan.pcomma; // this is "large" if no comma 

if ( pcomma>vsz)
{
IdxTy pc=0;
// [f] [m] l0 l1 ...  [t1]  [t2] ... 
if ( vsz>1) {name.first()=van[pc].str(); ++pc; } 
if ( vsz>(pc+1)) {
name.add_middle(van[pc].str()) ; ++pc;
while ( pc<vsz) { if (!van[pc].period()) break;
name.add_middle(van[pc].str()) ; ++pc;
 } }
//while (pc<vsz) { if ( van[pc].nic()&&(name.last()!="")) break;  name.last()+=" "+van[pc].str(); ++pc; } 
while (pc<vsz) { if ( van[pc].nic()&&(name.last()!="")) break;  name.add_last(van[pc].str()); ++pc; } 
while (pc<vsz) {  name.title()+=" "+van[pc].str(); ++pc; } 
return rc;
} // no comma
// comma...
IdxTy pc=0;
//while (pc<lan.pcomma) { if ( van[pc].nic()&&(name.last()!="")) break;  name.last()+=" "+van[pc].str(); ++pc; } 
while (pc<lan.pcomma) { if ( van[pc].nic()&&(name.last()!="")) break;  name.add_last(van[pc].str()); ++pc; } 
while (pc<lan.pcomma) {  name.title()+=" "+van[pc].str(); ++pc; } 
if ( pc<vsz) {name.first()=van[pc].str(); ++pc; } 
while (pc<vsz) {name.middle()=van[pc].str(); ++pc; } 
return rc;
} // AssembleName

// TODO FIXME this also needs to group latex constructs in names
// normally {\adf\'} or grouped in braces
IdxTy FixParses(Sv & w, const Sv & _w, const IdxTy flags) const
{
int  braces=0;
const IdxTy _len=w.size();
MM_SZ_LOOP(i,_w,_szlen)
{
// the parser will consider these different and
// they need to be reassembled. 
const IdxTy len=_w[i].length();
//const unsigned char c=_w[i].c_str()[0];
//if (c>127)
const IdxTy wsz=w.size();
const char c1=_w[i].c_str()[0];
bool concat=(c1&128)||(c1=='-')||(c1=='{')||(c1=='}');
// don't want to concat if either side is a white space
if (wsz)
{
// except now it was concatted doh !
const auto & doh=w.back().c_str();
const IdxTy lb=w.back().length(); 
if (lb) { 
const char c2=doh[lb-1]; // w.back().c_str()[0];
concat|=(c2&128)||(c2=='-')||(c2=='{')||(c2=='}');
// NB the white space concats and so needs to test chars not equal 
concat&=(c2!=' ')||(braces!=0);
}
} 
concat&=(c1!=' ')&&(c1!=',');
concat|=(braces!=0);
if (c1=='{') ++braces;
else if (c1=='}') --braces;

//if  (_w[i].c_str()[0]&128)
if (concat) 
{
if (wsz==0)w.push_back(StrTy());
// if (( i+1)<_szlen)
//{
//w.back()+=_w[i]+_w[i+1];
w.back()+=_w[i];
//++i;
//if (i>=szlen) break; 
}

else w.push_back(_w[i]);
} /// i 


return 0;
}
#if 0
IdxTy AssembleNameXXX(name_type & name, const Sv & _w, const IdxTy flags) const
{

Sv w;
const IdxTy _len=w.size();
MM_SZ_LOOP(i,_w,_szlen)
{
const unsigned char c=_w[i].c_str()[0];
if (c>127)
{
if (w.size()) if (( i+1)<_szlen)
{
w.back()+=_w[i]+_w[i+1];
++i;
}
}
else w.push_back(_w[i]);
} /// i 

const IdxTy len=w.size();
IdxTy pc=~0;
for(IdxTy i=0; i<len; ++i) { if ( w[i]==",") {pc=i; break; }}
std::vector<IdxTy> posi;
MM_SZ_LOOP(i,w,szlen)
{
MM_ERR(MMPR3(i,w[i],w[i].length()))
}
for(IdxTy i=0; i<len; ++i) 
{ 
// De Wolff is a problem taking "De" as last name and "Wolff" as a suffix
const StrTy & wi=w[i];
const char c =wi.c_str()[0];
if ( c==0 ) {continue; }
if ( (unsigned char)(c)>127 ) {continue; }
if ( c==' ') {continue; }
if ( c=='\t') {continue; }
// default punctuation parsing puts each one in diff string 
// Middle initial if one letter else title
// this may be a first name initail... 
// if this is here, it could be first or middle init but not concat 
if ( c=='.') {
if (i>0)
{
// this may be a first initial 
// except there is already a name on the stack, that is probably the first name
// doh... 
const StrTy & mi=w[i-1];
const IdxTy li1=mi.length();
if (li1==1)
{
if ((name.first()=="")&&(posi.size()<2))  name.first()+=mi;
else  name.middle()+=mi;
}
else name.title()+=mi;
posi.pop_back(); // no longer needed 
} 
else {MM_ERR(" bad dot in name "<<MMPR2(wi,i)) } 
continue;
// go ahead and add to name now as last thing is known... 
}

posi.push_back(i);

} // i 
const IdxTy fn=posi.size();
MM_ERR(name.dump())
MM_LOOP(ii,posi)
{
MM_ERR(MMPR2((*ii),w[(*ii)]))

} 
if ( pc==~0U)
{
IdxTy i=0;
if (i<fn){ 
if (name.first()=="")
name.first()+=w[posi[i]]; 
else name.middle()+=w[posi[i]]; 

++i;  

}
// m,l,title ; l,title, m , l etc 
/*
if (i<fn){ const StrTy x=w[posi[i]]; ++i;  
// this fails where first middle initial is used with full middle , 
if (x.length()==1) name.middle()+=x; 
else name.last()+=x;
} // 
// need to transfer from the comma case... 
if (i<fn){ name.last()=w[posi[i]]; ++i;  }
while (i<fn){ name.title()+=w[posi[i]]+" "; ++i;  }
*/
// next one is either a middle( initial or full ) or last name or partial
// last name Mc Donald
const IdxTy nleft=fn-i;
// if there is only one, this is a last name
if (nleft<2) {if (i<posi.size()) name.last()+=w[posi[i]];
else MM_ERR(" two x. y. names ???"<<MMPR(name.dump()))
 ++i; }
else // the at least two may be m,l l,t;  l1 l2 etc
{
const IdxTy pos=posi[i];
const StrTy & q=w[pos];
const IdxTy qlen=q.length();
if (qlen==1) { name.middle()+=q; ++i; } // but it could be a middle name
else
{
const IdxTy pos=posi[fn-1];
const StrTy & q2=w[pos];
const IdxTy qlen2=q2.length();
bool pfxmaybe= (qlen<qlen2);
const char * pp=q2.c_str();
IdxTy ucc=0;
while (*pp) { if (m_clut.mask(*pp,UC)) ++ucc; ++pp; }
bool allcaps=(ucc>=(qlen2-1))||(ucc>2);
bool as_name=pfxmaybe||!allcaps;
if( as_name) name.last()+=q2;
else name.title()+=q2;
IdxTy fneff=fn-1;
// now get everything in between
if (qlen>3) name.middle()+=q;
else name.last()=q+name.last();
++i;
// this can pickup things twice now.. 
while (i<fneff) 
{const StrTy & s= w[posi[i]];   name.last()=s+name.last(); ++i;  } 

i=fn;
}
} // nleft>=2
while (i<fn) { 
const IdxTy pos=posi[i];
//const bool have_mid=(name.middle().length()!=0);
// m,l,title ; l,title, m , l etc 
const StrTy & q=w[pos];
const IdxTy qlen=q.length();
bool pfxmaybe= (name.last().length()<qlen);
const char * pp=q.c_str();
IdxTy ucc=0;
while (*pp) { if (m_clut.mask(*pp,UC)) ++ucc; ++pp; }
bool allcaps=(ucc>=(qlen-1))||(ucc>2);
bool as_name=pfxmaybe||!allcaps;
if( as_name) name.last()+=w[posi[i]];
else name.title()+=w[posi[i]];
++i; 
} // while 

} // no comma
else
{

IdxTy i=0;
// take everything before the comma 
while (i<fn){ 
const IdxTy pos=posi[i];
if (pos>=pc) break;
// TODO look for PhD, ASDF allcaps etc
// don't get McDonald etc 
//bool allcaps=false; 
// De Wolff is a problem taking "De" as last name and "Wolff" as a suffix
//bool as_title= (name.last().length()!=0)||(allcaps);

// authors may also use first middle init
// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.617.9509&rep=rep1&type=pdf
//author = {Lowe , Susan E and t , Gregory J},
//author_orig = {Susan E. Lowe and J. Gregory Zeikust},


const StrTy & q=w[pos];
const IdxTy qlen=q.length();
bool pfxmaybe= (name.last().length()<qlen);
const char * pp=q.c_str();
IdxTy ucc=0;
while (*pp) { if (m_clut.mask(*pp,UC)) ++ucc; ++pp; } 
bool allcaps=(ucc>=(qlen-1))||(ucc>2); 
bool as_name=pfxmaybe||!allcaps;
if( as_name) name.last()+=w[posi[i]]; 
else name.title()+=w[posi[i]]; 

++i;  
}
++i;
if (i<fn){ name.first()=w[posi[i]]; ++i;  }
while (i<fn){ name.middle()+=w[posi[i]]+" "; ++i;  }


} // comma

MM_ERR(name.dump())

return 0l; 
} // AssembleNameXXX ????
#endif

// the string s is a putative date and is added as a single
// line into a ragged table parsed by char groups.
IdxTy ParseDates(parsed_dates_class & pdc, const StrTy &s, const IdxTy flags)
{

//r.splitter(8); // tokenize and remove junk 
//r.dynamic_split(); // create m_lip, move this crap to ragged doh 

Ragged r;
// this is all wrong
//LoadRagged(r,s);
r.splitter(8);
r.dynamic_split();
Ss ss;
ss<<s;
r.load(ss,true);
// this looks right.. 
MM_ERR(MMPR(r.dump()))
MM_SZ_LOOP(i,r,rsz)
{
const Ragged::Line & l=r[i];
const StrTy lz=(l.size())?l[0]:StrTy();
MM_ERR(MMPR3(i,l.size(),lz))
// so there need not be anything there ... doh!
//if (l.size()==0) continue; 
Sv w;
// try to find char groups for numeric dates only for 
// now, others should be handled by bash "date"
MM_SZ_LOOP(j,l,sz)
{
//const StrTy & x=l[j];
} // j
DateClass dc;
dc.parse(l,m_clut);
const bool has_year=dc.has_year();
const bool sort_of_valid=dc.valid(0);
const bool strict_valid=dc.valid(~0);
MM_ERR(MMPR3(has_year,sort_of_valid,strict_valid))
pdc.push_back(dc);

} // i 

return 0;
} // ParseDates

IdxTy UTF8ToLatex(StrTy & d, const StrTy &s, const IdxTy flags) const
{
const bool remove_all=false; // !Bit(flags,0);
UniLa ul;
std::vector<int> v;
IdxTy n=0;
bool threw=false;
try{
ParseTable::utf8_to_unicode(v,s.c_str(),0);
} catch (...) // could catch SIG whatever but not real likely
{
threw=true;
d=s;
return ~0;
}
Ss ss;
MM_LOOP(ii,v)
{
const int vv=(*ii);
const int page=(*ii)>>8;
const int val=(int((*ii)))&((1<<8)-1);
const bool odd=(page)||(threw&&(val>127));
const bool really_odd=(IdxTy(val)>127)&&remove_all;
//std::setfill('0') << std::setw(5)
//if (odd||really_odd) 
//{ ++n;  ss<<"Ux"<< std::setfill('0') << std::setw(4)<< std::hex<<(*ii); }
//else  
{
if (page||(val>127)){ ++n;
const StrTy ns=ul.latex(vv);
ss<<ns;
//if (ns.length()==0)
if (ns.length()==6) if (ns.c_str()[0]=='U') if (ns.c_str()[1]=='x')
{
++n;
MM_ERR(" bad cha r"<<MMPR2(vv,s))
ss<<"[bad char "<<MMPR(vv)<<"]";
}
} // page
else  ss<<char(vv); }
//if (0==page) { ss<<char((*ii)); continue; }
//else ss<<"Ux"<<std::hex<<(*ii); 
} // ii 
d=ss.str();
//return threw?1:0;

return n;
} // UTF8ToLatex

IdxTy LatexToLatex(StrTy & d, const StrTy &s, const IdxTy flags) const
{
d=s;
IdxTy n=0;
StrTy snew="";
Ragged r;
// this is html idio, go back to normal groups 
//r.load_params(0,3," ");
// tokenizer return all quote esc etc  
r.load_params(9,0," ");
Ss sss;
sss<<s;
r.load(sss,true);
Ss ss;
MM_LOOP(ii,r)
{
// if size is not one, there will be html things... 
const IdxTy sz=(*ii).size();
MM_ERR("FIX " << MMPR(sz))
Ragged::Line lx;
bool esc=false;
MM_LOOP(jj,(*ii))
{
MM_ERR(MMPR4(__FUNCTION__,(*jj),esc,snew)<<MMPR2(s,n))
if (esc)
{
if ((*jj)=="texttwosuperior") 
{ ++n;
snew+="$^2$";
}
esc=false;
continue;
}
if ((*jj)=="\\") esc=true;
} // jj

} // ii 
d=snew;
return n;
} // LatexToLatex

// needs to get these, but then may need another wierd char
// to latex convert... 
// https://www.fileformat.info/info/unicode/char/2074/index.htm
//Encodings
//HTML Entity (decimal) &#8308;
//HTML Entity (hex) &#x2074;

// this also needs to do html decode- % is a mess 
IdxTy HTMLToLatex(StrTy & d, const StrTy &s, const IdxTy flags) const
{
const bool remove_all=false; // !Bit(flags,0);
IdxTy n=0;
Ragged r;
r.load_params(0,3," ");
Ss sss;
sss<<s;
r.load(sss,true);
Ss ss;
MM_ERR(MMPR3(__FUNCTION__,s,r.size()))
MM_LOOP(ii,r)
{
// if size is not one, there will be html things... 
const IdxTy sz=(*ii).size();
Ss ssx; MM_SZ_LOOP(k,(*ii),szi) { ssx<<k<<"|"<<(*ii)[k]<<"|"; } 
MM_ERR("FIX " << MMPR2(sz,ssx.str()))
Ragged::Line lx;
MM_LOOP(jj,(*ii))
{
const StrTy & x=(*jj);
const char * xp=x.c_str();
MM_ERR("FIX " << MMPR2(x,sz))
if (x=="<sup>")
{
++n;
Scripts(lx,jj,(*ii),"</sup>","^");
if (jj==(*ii).end()) break;
}
else if (x=="<sub>")
{
++n;
Scripts(lx,jj,(*ii),"</sub>","_");
if (jj==(*ii).end()) break;
}
else if (x=="<i>")
{
++n;
Scripts(lx,jj,(*ii),"</i>","",1);
if (jj==(*ii).end()) break;
}
else if ((x=="amp")&&(lx.size()))
{ if ( HtmlIsm(lx,jj,*ii,"amp","&") ) ++n ; } // amp
else if ((x=="quot")&&(lx.size()))
{ if ( HtmlIsm(lx,jj,*ii,"quot","\"") ) ++n ; } // amp
//Assis Barros D\&#x27;Elia},
/*
https://pdfs.semanticscholar.org/0ee8/33694e13ddc65109305cc0a59c7545f8f9ce.pdf
./mjm_bibtex_fields.h1102 FIX  x=  sz=19
./mjm_bibtex_fields.h1102 FIX  x=D\ sz=19
./mjm_bibtex_fields.h1102 FIX  x=& sz=19
./mjm_bibtex_fields.h1102 FIX  x=#x27 sz=19
./mjm_bibtex_fields.h1102 FIX  x=; sz=19
./mjm_bibtex_fields.h1102 FIX  x=;Elia sz=19
*/
else if ((x.length()==4) &&(xp[0]=='#')&&(xp[1]=='x'))
{
int ci=::strtol(xp+2,0,16);
Ss ss; ss<<char(ci);
if ( HtmlIsm(lx,jj,*ii,x,ss.str()) ) ++n ;  // amp
}
else lx.push_back(x);

} // jj 
MM_LOOP(jj,lx) { 
// try to preserve some upper case 
//bool add_braces=((*jj).length()>1);
const char * p=(*jj).c_str();
const IdxTy sz=(*jj).length();
// not strictyl
MM_ERR(" embrace "<<MMPR(p))
IdxTy uc=0;
IdxTy lc=0;
IdxTy di=0;
bool nt=false;
for(IdxTy i=0; i<sz; ++i)
{
IdxTy iv=m_clut.lut(p[i]);
if (Mask(iv,UC)) {  ++uc; if (i) nt=true; } 
if (Mask(iv,LC)) ++lc;
if (Mask(iv,DIGIT)) ++di;
} // i 
bool embrace=false;
// Zotero does this, I guess it gets proper names etc... 
if (uc) embrace=true;

if (nt) embrace=true;
// so this picks up spaced and punc etc
if ((uc+di)&&!lc) embrace=true;
// someone is escaping later... 
if (embrace)
{
MM_ERR("embracing coded out "<<MMPR((*jj)))
embrace=false;
}
if (embrace) ss<<"{"<<(*jj)<<"}"; else ss<<(*jj); 

}
// wtf???? 
MM_ERR(" removing stupid CRLF in HTMLtoLatex???") 
//ss<<CRLF;
} // ii 
d=ss.str();

return n;
} // HTMLToLatex


template <class Ti>
void Scripts(Ragged::Line & lx, Ti & jj,const Ragged::Line & l,const StrTy & term,  const StrTy & cmd, const IdxTy flags=0 ) const
{
const bool is_it_style=Bit(flags,0);
if (lx.size()==0) lx.push_back(StrTy());
++jj;
StrTy v="";
while (jj!=l.end())
{
if ((*jj)==term) break;
v+=(*jj);
++jj;
} // jj
// just copy Zotero for now :) 
if (false) 
lx.back()=StrTy("${")+lx.back()+StrTy("}")+cmd+StrTy("{")+v+StrTy("}$");
else
{ // but beyond Zotero assume it should be braced
if (is_it_style)
{

lx.push_back(StrTy("")+cmd+StrTy("{\\it ")+v+StrTy("}"));
}
else
{
lx.back()=StrTy("{")+lx.back()+StrTy("}");
lx.push_back(StrTy("$")+cmd+StrTy("{\\textrm{")+v+StrTy("}}$"));
} // ! is_it_style


} // true



} // Scripts 


template <class Ti>
bool  HtmlIsm(Ragged::Line & lx, Ti & jj,const Ragged::Line & l,const StrTy & term,  const StrTy & cmd ) const
{
StrTy x=(*jj);
MM_ERR(MMPR2(__FUNCTION__,lx.back()))
if (lx.back()=="&") 
{
++jj;
// was leaving in semicolon 
//if (jj!=l.end()) if ((*jj)==";") { lx.back()=cmd; ++jj;  {MM_ERR(" ok ")}   return true; } 

if (jj!=l.end()) { // compile warn brace
	if ((*jj)==";") { lx.back()=cmd;   {MM_ERR(" ok ")}   return true; } 
	else { lx.push_back((x)); lx.push_back(*jj); return false  ; } 
}

lx.push_back(x);
return false  ;
} // back 
lx.push_back(x);

return false;
} // HtmlIsm 



IdxTy DealWithNonAscii(StrTy & d, const StrTy &s, const IdxTy flags) const
{
const bool remove_all=!Bit(flags,0);
std::vector<int> v;
bool threw=false;
try{
ParseTable::utf8_to_unicode(v,s.c_str(),0);
} catch (...) // could catch SIG whatever but not real likely
{
threw=true;
for(IdxTy i=0; i<s.length(); ++i) v.push_back((unsigned char )s.c_str()[i]);
}
Ss ss;
MM_LOOP(ii,v)
{
const int page=(*ii)>>8;
const int val=(int((*ii)))&((1<<8)-1);
const bool odd=(page)||(threw&&(val>127));
const bool really_odd=(IdxTy(val)>127)&&remove_all;
//std::setfill('0') << std::setw(5)
if (odd||really_odd)  ss<<"Ux"<< std::setfill('0') << std::setw(4)<< std::hex<<(*ii); 
else  { ss<<char((*ii)); }
//if (0==page) { ss<<char((*ii)); continue; }
//else ss<<"Ux"<<std::hex<<(*ii); 
} // ii 
d=ss.str();
return threw?1:0;
}

IdxTy Addquery(StrTy & d,  const StrTy &  urlin, const StrTy & s,const IdxTy flags)
{
enum { FOUND=0, LEFT=1, QUERY=2, FRAG=3, ADDED=4 };
Ragged::Line nl,temp;
IdxTy state=(1<<LEFT)|(1<<FOUND);
StrTy prior="";
Ragged rin;
rin.splitter(8);
Ss uu;
uu<<urlin;
rin.load(uu,0);
for(int dummy=0; dummy<1; ++dummy ) {
MM_LOOP(jj,rin[0]){ 
const StrTy & urlq=(*jj);
StrTy lc=StrUtil::fancy_to_lower(urlq);
//const char * lcp=lc.c_str();
MM_ERR(MMPR3(urlq,state,prior))
if (Bit(state,LEFT)&&(urlq!="}"))
{

if (lc=="#"){ state|=(1<<FRAG);
// meaning there is also no query... 
if (!Bit(state,ADDED))
{
state|=(1<<ADDED);
temp.push_back("?");
temp.push_back(s);
}
else if (temp.size()) if (temp.back()=="&") temp.pop_back(); // speculative ampersand... 
}

// add in front... easier than finding the end.. 
prior=urlq;
temp.push_back(urlq);
if (lc=="?"){
 state|=(1<<QUERY);
 state|=(1<<ADDED);
temp.push_back(s);
// this is speculative... 
temp.push_back("&");
}
continue;
} // LEFT 
else if (Bit(state,FOUND)&&(lc=="{")) {state|=(1<<LEFT); }
else if (lc=="}") {
// end if there was anything...
if (state)
{
if (!Bit(state,ADDED))
{
state|=(1<<ADDED);
temp.push_back("?");
temp.push_back(s);
}
else if (temp.size()) if (temp.back()=="&") temp.pop_back(); // speculative ampersand... 
MM_LOOP(kk,temp) { nl.push_back(*kk); }
temp.clear();
state=0;
}
}
else if ((prior=="\\")&&((lc=="href")||(lc=="url")))
{ state|=(1<<FOUND); } // url start 

prior=urlq;
nl.push_back(urlq);
}
} 
if (temp.size())
{ MM_ERR(" stuff remains in temp "<<MMPR(temp.size()))
MM_LOOP(kk,temp) { nl.push_back(*kk); } 
if (!Bit(state,ADDED))
{
state|=(1<<ADDED);
nl.push_back("?");
nl.push_back(s);
}
 }
d="";
MM_LOOP(ii,nl) d+=(*ii);
MM_ERR(MMPR2(d,s))

return 0; 
} // AddQuery

IdxTy LoadRagged(Ragged & r, const StrTy & s) const
{
Sv sv;
sv.push_back(s);
return LoadRagged(r,sv.begin(),sv.end());


} // LoadRagged;
template <class Ti>
IdxTy LoadRagged(Ragged & r, const Ti & _ii, const Ti & ee) const
{
Ti ii=_ii;
return LoadRagged(r,ii,ee);

}
template <class Ti>
IdxTy LoadRagged(Ragged & r, Ti & ii, const Ti & ee) const
{
r.splitter(8); // tokenize and remove junk 
r.dynamic_split(); // create m_lip, move this crap to ragged doh 
while (ii!=ee)
{
r.add(StrTy(*ii));
++ii;
} // ii 
MM_ERR(r.dump())
return 0; 
} // LoadRagged


// MEMBERS
ParseTable m_clut;
ConvMap  m_conv;


}; // mjm_bibtex_fields

//////////////////////////////////////////////

template <class Tr>
class mjm_bibtex_fields_map : public std::map<typename Tr::StrTy, mjm_bibtex_fields< Tr > >  
{
 typedef mjm_bibtex_fields_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bibtex_fields< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_fields_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bibtex_fields_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIBTEX_FIELDS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_bibtex_fields <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIBTEX_FIELDS "<<__DATE__<<" "<<__TIME__<<CRLF;
ss<< mjm_global_credits::about();

MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bibtex_fields<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
typedef mjm_ragged_table Ragged;
std::vector<StrTy> lines;
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//IdxTy load_xlate(const StrTy & fn, const IdxTy flags)
else if (cmd=="xtab") { x.load_xlate(cip.p1,0);  }
else if (cmd=="line") { lines.push_back(cip.p1);  }
else if (cmd=="load") { Ragged r; auto ii=lines.begin(); 
x.load_ragged(r,ii,lines.end()); MM_MSG(r.dump()) }
else if (cmd=="parse") { Myt::parsed_names_class pnc ; 
x.parse_names(pnc,cip.p1,0);
MM_LOOP(ii,pnc) { MM_ERR(MMPR((*ii).dump(0))) } 
} 
else if (cmd=="dates") { Myt::parsed_dates_class pnc ; 
x.parse_dates(pnc,cip.p1,0);
MM_LOOP(ii,pnc) { MM_ERR(MMPR((*ii).dump(0))) } 
} 



//IdxTy parse_names(parsed_names_class & pnc, const StrTy & s, const IdxTy flags) const 
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIBTEX_FIELDS_H__ 
