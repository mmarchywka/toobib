#ifndef MJM_TEMP_PROGRESS_H__
#define MJM_TEMP_PROGRESS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

// order is temporary get required includes in righ file 
#include "mjm_partial_cache.h"
#include "mjm_bibtex_features.h"
#include "mjm_blob.h"
#include "mjm_read_buffer.h"
#include "mjm_misc_parse.h"
#include "mjm_bibtex_entry.h"
#include "mjm_bibtex_parse.h"
// instead of pawnoff
#include "mjm_ext_things.h"
#include "mjm_collections.h"
#include "mjm_generic_iterators.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


#include "mjm_read_buffer.h"

// Tue Nov 19 06:57:30 EST 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibtex_find   
// g++ -std=gnu++11 -DTEST_MJM_BIBTEX_FIND -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibtex_find.h  -lpthread -lreadline
template <class Tr> 
class mjm_temp_progress
{

typedef mjm_temp_progress Myt;

 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef char Ch; 
typedef std::vector<StrTy> Vec;

typedef mjm_read_buffer<Tr> RdBuf;
typedef mjm_ext_things<Tr> ExtThings;
typedef mjm_bibtex_features<Tr> Features;
typedef std::map<StrTy, StrTy> Pmap;
typedef std::map<StrTy, IdxTy> Imap;
typedef mjm_partial_cache<Tr> ProgCache;
typedef mjm_ragged_table Ragged;
typedef mjm_blob<Tr> Blob;
typedef std::map<StrTy, Blob> BlobMap;

//template <class Key, class Value,int Zero=0>
//class mjm_vector_map_iter




//typedef std::vector<StrTy> Vec;
typedef std::map<StrTy,Vec> Vmap;
typedef std::map<StrTy, StrTy> Kvmap;
typedef std::vector<Kvmap> Vkv;
// each source of possible bibs can have a vector
// of bib maps containing the text and meta info like citeurl etc 
typedef std::map<StrTy,Vkv> VkvMap;
typedef  mjm_vector_map_iter<StrTy,Kvmap> BibIter;

//void GetAndTest(BibMap & bm, const StrTy & handler, const StrTy & url, const StrTy & thing, const IdxTy flags)

class suspect_entry
{

#define SETGET(u,m_u,Ty) void u(const Ty & x) { m_u=x; } const Ty &  u()const  {return  m_u; } 
public:
suspect_entry(): m_status(~0) {}
suspect_entry(const StrTy & h, const StrTy & t, const IdxTy flags)
:m_handler(h),m_thing(t), m_flags(flags),m_status(0) {}
SETGET(handler,m_handler,StrTy)
SETGET(thing,m_thing,StrTy)
SETGET(flags,m_flags,IdxTy)
bool valid() { return m_status!=(~0); } 
StrTy m_handler;
StrTy m_thing;
IdxTy m_flags;
IdxTy m_status; 
private:


};

typedef suspect_entry Suspect;
typedef std::vector<Suspect> Suspects;


public:
typedef Suspect suspect_type;
typedef Kvmap bib_map;
typedef Vkv bib_vector;
typedef VkvMap bib_vector_map;
mjm_temp_progress(): m_buf(10) { Init(); } 
~mjm_temp_progress() { Finalize(); } 
//void url(const StrTy & u) { m_url=u; } const StrTy &  url()const  {return  m_url; } 
SETGET(url,m_url,StrTy)
SETGET(page,m_page,Blob)
Blob & page() { return m_page; } 
SETGET(cache_in,m_cache_in,StrTy)
SETGET(cache_out,m_cache_out,StrTy)
Blob & page(const StrTy & nm) { return m_blobs[nm]; } 
void clear() { Clear(); } 
void dump_dois(const StrTy & Lbl) { DumpDOIS( Lbl) ; } 
void load_cache() { LoadFromCache(); }  
void add_doi(const StrTy & src, const char * p, const IdxTy s, const IdxTy e) {AddDOI(src,p,s,e);}

const Vec & dois(const StrTy & src) { return m_doi[src]; } 
Vkv & bibs(const StrTy & src) { return m_bibs[src]; } 
const IdxTy size() const { return m_bibs.size(); }
// may be slow 
const IdxTy nbibs() {IdxTy n=0; bibs_iter ii=begin(); while (ii) { ++n; ++ii; }  return n; }

bib_vector_map & bibs() { return m_bibs; } 
//typedef typename bib_vector_map::iterator bibs_iter; 
typedef BibIter bibs_iter; 
//bibs_iter  begin() { return m_bibs.begin(); } 
bibs_iter  begin() { return bibs_iter(m_bibs); } 
//bibs_iter  end() { return m_bibs.end(); } 
#undef SETGET
IdxTy nsuspects() const { return m_suspects.size(); } 
void add_suspect (const StrTy & h, const StrTy & t, const IdxTy flags) { AddSuspect (h, t,  flags); }
suspect_type  next_suspect() { return NextSuspect(); }
private:
void Init()
{
m_buf.clear(); 
}
void AddSuspect (const StrTy & h, const StrTy & t, const IdxTy flags)
{

Suspect s(h, t,  flags);
m_suspects.push_back(s); 
//void add_suspectsuspect_entry(const StrTy & h, const StrTy & t, const IdxTy flags)

}
suspect_type  NextSuspect() { 
if ( m_suspects.size()==0) return suspect_type(); 
suspect_type x= m_suspects[0];
// TODO FIXME  this is really stupid but ok for now
m_suspects.erase(m_suspects.begin());
return x; 
}

void DumpDOIS(const StrTy & lbl)
{

const auto & v = dois(lbl);
MM_LOOP(ii,v) { MM_ERR(lbl<<" "<<MMPR((*ii))) } 

}

void AddDOI(const StrTy & src, const char * p, const IdxTy s, const IdxTy e)
{
m_buf.clear();
m_buf.append(p+s,e-s);
//m_buf.cap();
m_doi[src].push_back(m_buf.string());
}

void Finalize()
{
if (m_cache_out.length()==0) return;
// the map is temp untilo end 
m_cache.cache_save("m_url",m_url);
//m_cache.cache_save("m_doi",m_doi);

// all the details are read from this file 
m_cache.save(m_cache_out);
}

void LoadFromCache()
{
if (m_cache_in.length()==0) return;
m_cache.load(m_cache_in);
m_cache.cache_load(m_url, "m_url");
// only cache downloads not extractions 
// m_cache.cache_load(m_doi, "m_doi");


}
void Clear()
{
m_cache_in="";
m_cache_out="";
m_cache.clear();
m_url="";
m_page.clear();
m_blobs.clear();
m_buf.clear();
m_doi.clear();
m_bibs.clear();
m_suspects.clear();
}

StrTy m_cache_in, m_cache_out;
ProgCache m_cache;

// cachable fields 
StrTy m_url;
// this may be text, html , or a binary such as a pdf. 
// what the src points to 
Blob m_page;
BlobMap m_blobs;

// scratch buffer
RdBuf m_buf;
// a map of vectors of doi's from various sources. 
Vmap m_doi;
// as above, but candidate bibtex results.
////Vmap m_bibs;
//typedef std::map<StrTy,Vkv> VkvMap;
VkvMap m_bibs;
Suspects m_suspects;

}; // temp_progress




#endif // MJM_TEMP_PROGRESS_H__ 
