#ifndef MJM_VV_MAP_H__
#define MJM_VV_MAP_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun Jan  3 07:46:40 EST 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_vv_map   
// g++  -Wall -std=gnu++11 -DTEST_MJM_VV_MAP -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_vv_map.h  -lpthread -lreadline

template <class Tr, class _Tkey, class _Tval, class _Tdb >
class mjm_vv_map 
{
 typedef mjm_vv_map Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef _Tkey Tkey;
typedef _Tval Tval;
typedef _Tdb Tdb;

typedef std::vector<Tval> Tvec;
typedef std::map<Tkey, Tvec> Tmap;
public:
typedef typename Tmap::iterator iterator;
typedef typename Tmap::const_iterator const_iterator;
typedef IdxTy Tidx;
// these rely on have no values with zero length vectors.. 
//template < class _Tikey >
class iter
{
typedef Tdb Super;
//typedef iter Myt;
//typedef _Tikey Tkey;
//typedef std::map<Tkey, Tidx> Tmap;
typedef typename Super::value_type Tgt;
public:
iter(Tmap & m, Super & s ) : m_map(m), m_super(s) {
m_ii=m_map.begin();
m_i=0;
while (*this) { if ((*m_ii).second.size()) break; ++m_ii;  } 

}
const Tkey & key() const { return (*m_ii).first; } 
const IdxTy vsize() const { return (*m_ii).second.size(); } 
const Tidx idx() const { return m_i; } 
Tgt & operator*() { return m_super[ (*m_ii).second[m_i]]; }
iter & next() 
{
m_i=0; 
while (*this) { ++m_ii; if ((*m_ii).second.size()) break;  } 
return *this; 
}
iter & operator++() { ++m_i;
//MM_ERR(MMPR3(m_map.size(),m_i,(*m_ii).second.size()))
if  (m_i>=(*m_ii).second.size()){ 
// ++m_ii; if (! (*this)) break;  m_i=0; }
m_i=0; 
while (*this) { ++m_ii; if ((*m_ii).second.size()) break;  } 
}

return *this;
}
 operator bool () {  return m_ii!=m_map.end(); }
void see_ok()
{
if (m_ii==m_map.end()) return;
if ((*m_ii).second.size()==0)
MM_ERR(" aero lengtrh vector "<<(*m_ii).first);

}
Tmap & m_map;
Super & m_super;
IdxTy m_i;
typename Tmap::iterator m_ii;

}; // iter

//template < class _Tikey >
class const_iter
{
typedef Tdb Super;
//typedef iter Myt;
//typedef _Tikey Tkey;
//typedef const std::map<Tkey, Tidx> Tmap;
typedef typename Super::value_type Tgt;
public:
const_iter() : m_map(0), m_super(0) {m_i=0; } 
const_iter(const Tmap & m, const Super & s ) : m_map(&m), m_super(&s) {
m_ii=(*m_map).begin();
m_i=0;
while (*this) { if ((*m_ii).second.size()) break; ++m_ii; } 

}
const Tgt & operator*() { return (*m_super)[ (*m_ii).second[m_i]]; }
const Tkey & key() const { return (*m_ii).first; } 
const IdxTy vsize() const { return (*m_ii).second.size(); } 
iter & next() 
{
m_i=0; 
while (*this) { ++m_ii; if ((*m_ii).second.size()) break;  } 
return *this; 
}
const_iter & operator++() { ++m_i;
if  (m_i>=(*m_ii).second.size()){ 
// ++m_ii; if (! (*this)) break;  m_i=0; }
m_i=0; 
while (*this) { ++m_ii;  if ((*m_ii).second.size()) break;  } 
}

return *this;
}
 operator bool () {if (m_map==0) return false;   return m_ii!=(*m_map).end(); }
void see_ok()
{
if (m_ii==(*m_map).end()) return;
if ((*m_ii).second.size()==0)
MM_ERR(" aero lengtrh vector "<<(*m_ii).first);

}
const Tmap * m_map;
const Super * m_super;
IdxTy m_i;
typename Tmap::const_iterator m_ii;

}; // const_iter


public:
mjm_vv_map() {m_size=0;}
~mjm_vv_map() {}
IdxTy count() const { return m_map.size(); } 
IdxTy size() const { return m_size; } 
void add( const Tkey & k, const Tidx & i) { ++m_size;  m_map[k].push_back(i); } 
typedef Tvec vector_type;
const Tvec * operator[] (const Tkey & k)const
 { auto ii= m_map.find(k); 
if (ii==m_map.end()) return 0;
return &((*ii).second); 
 } 
iterator begin() { return m_map.begin();}
iterator end() { return m_map.end();}
const_iterator begin() const  { return m_map.begin();}
const_iterator end() const { return m_map.end();}



template <class Ts> iter begin(Ts & s ) { return iter(m_map,s); } 
template <class Ts> const_iter begin(Ts & s )const  { return const_iter(m_map,s); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// MEMBERS

Tmap m_map;
IdxTy m_size;
}; // mjm_vv_map

//////////////////////////////////////////////

template <class Tr,class Tkey, class Tval, class Tdb>
class mjm_vv_map_map : public std::map<typename Tr::StrTy, mjm_vv_map< Tr, Tkey, Tval, Tdb  > >  
{
 typedef mjm_vv_map_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_vv_map< Tr,Tkey,Tval, Tdb> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_vv_map_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_vv_map_map




////////////////////////////////////////////
#ifdef  TEST_MJM_VV_MAP
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_vv_map <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_VV_MAP "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_vv_map<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_VV_MAP_H__ 
