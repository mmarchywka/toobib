#ifndef MJM_STRING_KVP_H__
#define MJM_STRING_KVP_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

// pickup more parsing
#include "mjm_cpp_regex.h"
// really could use "contains" as most are exact string match 
#include "mjm_strings.h"

// throw in params here 
//#include "mjm_collections.h"
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Wed Feb 15 08:35:42 EST 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_string_kvp   
// g++  -Wall -std=gnu++11 -DTEST_MJM_STRING_KVP -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_string_kvp.h  -o mjm_string_kvp.out -lpthread -lreadline
/*

This was supposed to be a lightweight ui component to allow
flexible parameter passing with constant signatures.

It is expanding to contain a lot of parsing and becoming
more flexible. It is not quite JSON or URL query string
format and can become somewhat confusing. Bit strings,
field selection, array and list appear to be useful
here as well as things like file names and algorithm parameters. 

*/
mjm_global_credits::credit __credit__mjm_string_kvp("mjm_string_kvp"
, "  ");

template <class Tr>
class mjm_string_kvp 
{
 typedef mjm_string_kvp Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
enum {BAD=~0};
//typedef mjm_ragged_table Ragged;
//typedef Ragged::Line Line ;

// TYPEDEF
typedef std::map<StrTy, StrTy> Map;
typedef std::pair<StrTy, StrTy> Pair;
typedef std::vector<Pair> Vector;

typedef mjm_cpp_regex::stuff  Rx;
typedef Rx::Rx Regex;



// API
public:
mjm_string_kvp() {}
~mjm_string_kvp() {}
template < class Ty> IdxTy encode(StrTy & s, const StrTy & k, const Ty & v, const IdxTy flags=0)
{ return Encode(s,k,v,flags); } 
IdxTy parse(Map & m, const StrTy & s, const IdxTy flags=0)
{ return Parse(m,s,flags); } 
IdxTy parse(Vector & v,Map & m, const StrTy & s, const IdxTy flags=0)
{ return Parse(v,m,s,flags); } 



//IdxTy parse(Ragged & m, const StrTy & s, const IdxTy flags=0)
template <class Trag> IdxTy parse(Trag & m, const StrTy & s, const IdxTy flags=0)
{ return Parse(m,s,flags); } 


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
template < class Ty> IdxTy Encode(StrTy & s, const StrTy & k, const Ty & v, const IdxTy flags)
{
Ss ss;
const bool hi_prec=Bit(flags,0);
IdxTy nprec=16;
if (hi_prec)  ss<<std::setprecision(nprec);
ss<<s;
if (s.length()) ss<<";";
ss<<k<<"="<<v;
s=ss.str();
return 0; 
} // Encode
// TODO need parser from ragged for nested protected quote
// or json-esque stuff 
//IdxTy Parse(Ragged & d, const StrTy & s, const IdxTy flags=0)
template<class Trag> IdxTy Parse(Trag & d, const StrTy & s, const IdxTy flags=0)
{
IdxTy rc=9;
StrTy k="";
StrTy v="";
const IdxTy len=s.length();
char cc[len+1];
memcpy(cc,s.c_str(),len);
cc[len]=0;
IdxTy pc=0;
//IdxTy kz=0;
IdxTy vz=0;
typename Trag::Line l;
while (pc<len)
{
do
{
char c=cc[pc];
//if (c=='=') { cc[pc]=0; vz=pc+1; break; } 
if (c==' ') { cc[pc]=0;l.push_back(StrTy(cc+vz));  vz=pc+1;  break; } 
//if (c==';') { cc[pc]=0; m[StrTy(cc+kz)]+=StrTy(cc+vz); kz=pc+1;  break; } 
if (c==';') { cc[pc]=0; l.push_back(StrTy(cc+vz)); vz=pc+1;  break; } 
} while (false) ; 

++pc;
} // pc 
if (vz!=pc) { l.push_back(StrTy(cc+vz));} 
if (l.size()) d.add(l); 
//MM_LOOP(ii,m) { MM_ERR(MMPR2((*ii).first,(*ii).second)) } // ii 
MM_ERR(MMPR(d.size()))
return rc; 
} // Parse


IdxTy Parse(Map & m, const StrTy & s, const IdxTy flags=0)
{
Vector v;
return Parse(v,m,s,flags); 
}
IdxTy Parse(Vector & _v,Map & m, const StrTy & s, const IdxTy flags=0)
{
const bool do_dump=Bit(flags,0);
IdxTy rc=9;
StrTy k="";
StrTy v="";
const IdxTy len=s.length();
char cc[len+1];
memcpy(cc,s.c_str(),len);
cc[len]=0;
IdxTy pc=0;
IdxTy kz=0;
IdxTy vz=0;
while (pc<len)
{
do
{
char c=cc[pc];
if (c=='=') { cc[pc]=0; vz=pc+1; break; } 
if (c==';') { cc[pc]=0; 
StrTy kk=StrTy(cc+kz);
StrTy vv=StrTy(cc+vz);
//m[StrTy(cc+kz)]+=StrTy(cc+vz); 
m[kk]+=StrTy(vv); 
_v.push_back(Pair(kk,vv));
kz=pc+1;  break; } 
} while (false) ; 

++pc;
} // pc 
if (vz!=pc) { 
//m[StrTy(cc+kz)]+=StrTy(cc+vz);
StrTy kk=StrTy(cc+kz);
StrTy vv=StrTy(cc+vz);
//m[StrTy(cc+kz)]+=StrTy(cc+vz); 
m[kk]+=StrTy(vv); 
_v.push_back(Pair(kk,vv));
} 
if (vz<=kz) { 
//m[StrTy("")]+=StrTy(cc+vz);
StrTy kk=StrTy("");
StrTy vv=StrTy(cc+vz);
m[kk]+=StrTy(vv); 
_v.push_back(Pair(kk,vv));
} 
if ( do_dump) { MM_LOOP(ii,m) { MM_ERR(MMPR2((*ii).first,(*ii).second))}}// ii 
return rc; 
} // Parse

///////////////////////////////
// MEMBERS



}; // mjm_string_kvp

//////////////////////////////////////////////

template <class Tr>
class mjm_string_kvp_map : public std::map<typename Tr::StrTy, mjm_string_kvp< Tr > >  
{
 typedef mjm_string_kvp_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_string_kvp< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_string_kvp_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_string_kvp_map


template <class Tr>
class mjm_string_base_params
{

 typedef mjm_string_base_params Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
enum {BAD=~0};
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_string_kvp<Tr> StrKvp;

//typedef mjm_ragged_table Ragged;
//typedef Ragged::Line Line ;

typedef std::map<StrTy, StrTy> Map;
typedef std::pair<StrTy, StrTy> Pair;
typedef std::vector<Pair> Vector;

/*
typedef std::string StrTy;
typedef std::stringstream Ss;
typedef unsigned int IdxTy;
typedef double D;
*/


static int myatoi(const char * c)  { return ::strtol(c,0,0); }
static int myatoi(const StrTy & s)  { return myatoi(s.c_str()); }

public:

mjm_string_base_params() :m_s() {Init();}
mjm_string_base_params(const StrTy & s) :m_s(s) {Init();}
//void add(Ragged& d, const D & x, const D & y, const IdxTy flags) const
template <class Trag> void add(Trag & d, const D & x, const D & y, const IdxTy flags) const
{Add(d,x,y,flags); }
IdxTy vsize() const { return m_vector.size(); }
void debug() {m_flags|=1; }
// if the input string is just a literal it is itself :)
bool plain() const { StrTy x; get(x,m_s); return x==m_s; }
const Pair & kvp(const IdxTy i ) const { return m_vector[i]; } 
bool has(const StrTy  & n ) { return m_map.find(n)!=m_map.end(); } 
const IdxTy  get(IdxTy  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; }//  return 0;
// want to allow hex etc too myatoi
//d=atoi((*ii).second.c_str());
else d=myatoi((*ii).second.c_str());
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
const IdxTy  get(int  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; }//  return 0;
// want to allow hex etc too myatoi
//d=atoi((*ii).second.c_str());
else d=myatoi((*ii).second.c_str());
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
const IdxTy  get(bool  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; }//  return 0;
// want to allow hex etc too myatoi
//d=atoi((*ii).second.c_str());
else
{
 const StrTy & v=((*ii).second.c_str());
/*if (v=="1") { d=true; }
else if (v=="0") { d=false; }
else if (v=="true") { d=true; }
else if (v=="false") { d=false; }
else if (v=="TRUE") { d=true; }
else if (v=="FA:SE") { d=false; }
else if (v=="+") { d=true; }
else if (v=="-") { d=false; }
else if (v=="yes") { d=true; }
else if (v=="no") { d=false; }
*/
const auto&  m=BoolMap();
const auto ii=m.find(v);
if (ii!=m.end()) { d=((*ii).second!=0); }
else
{
MM_ERR(" bad bool "<<MMPR2(n,v))
return ~0; 
}
} // found 
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}

typedef std::map<StrTy,IdxTy> BoolWords;

const BoolWords &  BoolMap()  const 
{
static BoolWords m;
if (m.size()==0)
{
m["1"]=1;
m["0"]=0;
m["+"]=1;
m["-"]=0;
m["true"]=1;
m["false"]=0;
m["True"]=1;
m["False"]=0;
m["TRUE"]=1;
m["FALSE"]=0;
m["yes"]=1;
m["no"]=0;
m["y"]=1;
m["n"]=0;
m["YES"]=1;
m["NO"]=0;

} // zero 
return m;
} // BoolMap


const IdxTy  get(D & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0;} // return 0;
else d=atof((*ii).second.c_str());
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
const IdxTy  get(StrTy & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; } //  return 0;
else d=(*ii).second;
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
 
//const StrTy& get(const StrTy & n )const{ return (*(m_map.find(n))).second;} 
const StrTy get(const StrTy & n ) const { 
//const auto ii= (*(m_map.find(n))).second; 
const auto ii= m_map.find(n); 
if (ii==m_map.end()) return StrTy();
return (*ii).second;
} // get  

// more common parsing stuff
const IdxTy  get(std::vector<int>  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; } //  return 0;
else
{ StrTy v=(*ii).second;
EvaluateRange(d,v,0);
}
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d.size(),n)) } 
return rc;
}
const IdxTy  get(std::vector<IdxTy>  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; } //  return 0;
else
{ StrTy v=(*ii).second;
EvaluateRange(d,v,0);
}
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d.size(),n)) } 
return rc;
}
const IdxTy  get(std::vector<StrTy>  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; } //  return 0;
else
{ StrTy v=(*ii).second;
EvaluateArray(d,v,0);
}
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d.size(),n)) } 
return rc;
}


bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// needs nesting and protection logic escapes quote etc 
template<class Tv>
bool EvaluateArray(Tv & selvec,const StrTy & fn, const IdxTy flags) const
{
const bool clear_first=Bit(flags,0);
if (clear_first) selvec.clear();
const IdxTy sz=fn.length();
const char * px=fn.c_str();
char pa[sz+1];
memcpy(pa,px,sz+1);
char * p=&pa[0];
int start=0;
int  prior= -1;
bool r=false;
bool minus=false;
for(IdxTy i=0; i<=sz; ++i)
{
const char c=p[i];
if ((c==0)||(c==',')) {
p[i]=0;
//int n=myatoi(p+start);
selvec.push_back(StrTy(p+start));
#if 0
if (r) {
for(int  j=prior; j<=n; ++j) selvec.push_back(j);
MM_ERR(" selecting "<<MMPR3(minus,prior,n))
r=false;
}
else
{ selvec.push_back(n); MM_ERR(" selecting "<<MMPR(n)) }
#endif

start=i+1;
//prior=n;

} // comma  
// now accomodate negatives... 
#if 0
if (c=='-' )
{ 
//if ((i==start)) { minus=true; }
if ((i==start)||r) { minus=true; }
else {p[i]=0; int n=myatoi(p+start); r=true; prior=n; start=i+1; }
} // dash
#endif
} // i 
//const IdxTy szs=selvec.size();
//if (szs!=0){ cu.ptr(selvec.back()); }
return r;
} //EvaluateArray 



// ranges info 
// copied from mjm_misc_parse.h
template<class Tv>
bool EvaluateRange(Tv & selvec,const StrTy & fn, const IdxTy flags) const
{
const bool clear_first=Bit(flags,0);
if (clear_first) selvec.clear();
const int sz=fn.length();
const char * px=fn.c_str();
char pa[sz+1];
memcpy(pa,px,sz+1);
char * p=&pa[0];
int start=0;
int  prior= -1;
bool r=false;
bool minus=false;
for(int i=0; i<=sz; ++i)
{
const char c=p[i];
if ((c==0)||(c==',')) {
p[i]=0;
int n=myatoi(p+start);
if (r) {
for(int  j=prior; j<=n; ++j) selvec.push_back(j);
MM_ERR(" selecting "<<MMPR3(minus,prior,n))
r=false;
}
else
{ selvec.push_back(n); MM_ERR(" selecting "<<MMPR(n)) }
start=i+1;
prior=n;
} // comma  
// now accomodate negatives... 
if (c=='-' )
{ 
//if ((i==start)) { minus=true; }
if ((i==start)||r) { minus=true; }
else {p[i]=0; int n=myatoi(p+start); r=true; prior=n; start=i+1; }
} // dash
} // i 
//const IdxTy szs=selvec.size();
//if (szs!=0){ cu.ptr(selvec.back()); }
return r;
} //EvaluateRange 



void Init()
{
StrKvp kvp;
kvp.parse(m_vector,m_map,m_s);
m_nprec=18;
m_flags=0;
// note these may confluct with user fields... 
get(m_nprec,"nprec"); 
get(m_flags,"m_flags"); 
}
StrTy dump() const
{
Ss ss;
MM_LOOP(ii,m_map)
{
const StrTy k=(*ii).first;
const StrTy v=(*ii).second;
ss<<MMPR2(k,v)<<" ";
} // ii 
return ss.str();
} // dump

// void Add(Ragged& d, const D & x, const D & y, const IdxTy flags) const
template <class Trag> void Add(Trag & d, const D & x, const D & y, const IdxTy flags) const
{
typename Trag::Line l;
{Ss ss; ss<<std::setprecision(m_nprec); ss<<x; l.push_back(ss.str()); } 
{Ss ss; ss<<std::setprecision(m_nprec); ss<<y; l.push_back(ss.str()); } 
d.add(l);
} // Add

private:
Map m_map;
Vector m_vector;
StrTy m_s;
IdxTy m_nprec;
IdxTy m_flags;
}; // _params




////////////////////////////////////////////
#ifdef  TEST_MJM_STRING_KVP
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_string_kvp <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_STRING_KVP "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_string_kvp<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_STRING_KVP_H__ 

