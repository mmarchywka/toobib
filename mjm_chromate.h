#ifndef MJM_CHROMATE_H__
#define MJM_CHROMATE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
//unsigned int microseconds;
//usleep(microseconds);
#include <unistd.h>

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include <mjm_pawnoff.h>
// this is now shared... 
#include <mjm_wscat_bot.h>
#include <mjm_strings.h>
#include <mjm_idiosyncratic_source_locator.h>
#include <../mjsonu/mjsonu.h>

#include <mjm_dir_watch.h>
// random port number ROFL
#include <iostream>
#include <cstdlib> // For rand() and srand()
#include <ctime>   // For time()

// Tue Jan  4 07:47:10 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_chromate   


// QUICKCOMPILE  g++   -MMD -MF chromate.deps -Wall -std=gnu++11 -DTEST_MJM_CHROMATE -I. -I../../mjm/hlib -I../../mjm/num  -I../../pkg/include -Wno-unused-variable -Wno-misleading-indentation  -gdwarf-3 -O0  -x c++ mjm_chromate.h  -lpthread -lreadline -o chromate.out

// g++  -Wall -std=gnu++11 -DTEST_MJM_CHROMATE -I. -I../../mjm/hlib -I../../mjm/num  -I../../pkg/include -Wno-unused-variable  -gdwarf-3 -O0  -x c++ mjm_chromate.h  -lpthread -lreadline -o chromate.out

// g++  -Wall -std=gnu++11 -DTEST_MJM_CHROMATE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_chromate.h  -lpthread -lreadline

template <class Tr>
class mjm_chromate 
{
 typedef mjm_chromate Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
enum { BAD=~0};
typedef mjm_pawnoff<Tr> Hand;
typedef mjm_wscat_bot<Tr> WsCat;
typedef mjm_idiosyncratic_source_locator<Tr> IdioRl;
// needs to use pawn def 
typedef mjm_blob<Tr> Blob;
typedef pthread_t ThreadId;
typedef mjm_mjsonu JsonTy;
typedef mjm_dir_watch<Tr> DirWatch;
typedef mjm_strings StrUtil;
class FetchInfo {
public:
FetchInfo(): rc(~0),eline(0),right_one(false),actual_doc(false) {}
FetchInfo & line(const int x) {eline=x; return *this; } 
StrTy dump() const
{
Ss ss;
ss<<MMPR4(rc,eline,error,root_node_id);
ss<<MMPR3(back_end_node,right_one,actual_doc);
ss<<MMPR(doc);
return ss.str();
} // dump
void reset_error() {error=""; }
IdxTy rc,eline;
StrTy error,doc;
StrTy root_node_id;
//fl.back_end_node_il[sz-1];
StrTy back_end_node;
bool right_one;
bool actual_doc;
}; // FetchInfo


class CmdParam
{
public:
typedef std::vector<StrTy> var_type;
typedef std::map<StrTy, StrTy  > Kv;
typedef std::map<StrTy, IdxTy  > Kp;
void add(const StrTy & k, const StrTy & v){ m_kv[k]=quote(escape(v)); }
template <int n> void add(const StrTy & k,  const char  v[n]){ m_kv[k]=quote(escape(StrTy(v))); }
void add(const StrTy & k, const IdxTy & v){ Ss ss; ss<< v;  m_kv[k]=ss.str(); }
void add(const StrTy & k, const bool & b){ m_kv[k]=b?"true":"false"; }
void add(const StrTy & k, const CmdParam & p){ m_kv[k]="{"+p.str()+"}"; }
StrTy str() const { return str(var_type()); } 
StrTy str(const var_type & vv) const
{
Ss ss;
StrTy sep="";
MM_LOOP(ii,m_kv)
{
StrTy v=(*ii).second;
const char * p=v.c_str();
// these are quoted on input doh... 
if (p[1]=='#') 
{
const IdxTy loc=atoi(p+2);
bool num=false;
if (v.length()>3) num=p[v.length()-2]=='.';
MM_ERR(" ave var "<<MMPR3(v,loc,num))
if (loc<=vv.size())
{
if (num )  v=vv[loc-1];
else   v="\""+vv[loc-1]+"\"";

}
else v=StrTy();
}
ss<<sep<<"\""<<(*ii).first<<"\""<<":"<<v; // (*ii).second;
sep=",";
} // ii 
return ss.str();
} // str
StrTy quote(const StrTy & s) const { return StrTy ("\"")+s+StrTy("\""); } 
StrTy escape(const StrTy & s) const
{
typedef std::vector<char> Cv;
Cv temp;
const char * p=s.c_str();
const IdxTy len=s.length();
for(IdxTy i=0; i<=len; ++i)
{
const char c=p[i];
if (c=='\\') temp.push_back('\\');
if (c=='\"') temp.push_back('\\');
temp.push_back(c);
} //i 
//temp.push_back(0);
StrTy x=StrTy(&temp[0]);
return x; 
} // escape
Kv m_kv;
Kp m_kp;
}; // CmdParam 
class CommandInfo
{
public:
typedef CmdParam params_type;
typedef typename params_type::var_type Vt;
typedef typename params_type::var_type var_type;
//typedef std::vector<CmdParam>  Params;
CommandInfo(const StrTy &n, const CmdParam p, const bool s,const bool aid) 
: m_nm(n),m_params(p),add_session(s),add_id(aid) {}
//CommandInfo() : m_nm(),m_params(),add_session(true),add_id(true) {}
CommandInfo() : m_nm(),m_is_string(false),m_params(),add_session(true),add_id(true) {}
void set_string(const StrTy &s) { m_string=s;m_is_string=true; } 
StrTy str(const IdxTy id,const StrTy & session) const {Vt zv; return str(id,session,zv); } 
StrTy str() const {Vt zv; return str(~0,StrTy(),zv); } 
StrTy str(const IdxTy id,const StrTy & session, const Vt & vars) const
{
//const bool add_id=true;
//const bool add_session=true; 
//MM_ERR(MMPR2(id,vars.size()))
Ss ss;
ss<<"{";
if (add_session) { ss<<"\"sessionId\":\""+session+"\","; }
//ss<<"\"method\":\"";
ss<<"\"method\":\""+m_nm+"\",";
if (!m_is_string){ ss<<"\"params\":{"; ss<<m_params.str(vars); ss<<"}"; }
else ss<<"\"params\":{\"type\":\""<<m_string<<"\"}";
//else ss<<"\"type\":\""<<m_string<<"\"";
// move here? 
//StrTy jscmd=spfx+"Emulation.setScriptExecutionDisabled\",\"params\":{\"value\":"+StrTy("false")+"},\"id\":";
//{Ragged r=CmdGet(fi,IdAdd(jscmd),flags); }
if (add_id) { ss<< ",\"id\":"; ss<<id ;} 

ss<<"}";
return ss.str();
} // str

StrTy m_nm;
// for Page.ReferrerPolicy with string not params
StrTy m_string;
bool m_is_string;

params_type  m_params;
bool add_session;
bool add_id;
}; // CommandInfo

typedef typename CommandInfo::var_type var_type;
typedef std::map<StrTy, CommandInfo > ChromeCmdMap;




class _response
{

public:
_response() : m_valid(false) {}
const StrTy rid()  { return m_kvp["requestId"]; } 
const StrTy status()  { return m_kvp["status"]; } 
void add(const StrTy & k , const StrTy & v)
{
//if (k=="requestId") m_valid=true;
m_kvp[k]=v;
// this is partsing non-response json so it can get fuced up 
// and request inf verwritten ... 
m_valid=rid().length()&&status().length();
MM_ERR(" adding "<<MMPR4(m_valid,m_kvp.size(),k,v)) 
}
StrTy get(const StrTy & k) const
{
const auto ii=m_kvp.find(k);
if (ii==m_kvp.end()) return StrTy();
return (*ii).second; 
}
StrTy dump() const
{
Ss ss;
ss<<MMPR2(m_valid,m_kvp.size());
ss<<"{";
MM_LOOP(ii,m_kvp) { ss<<(*ii).first<<"="<<(*ii).second<< " "; } 
ss<<"}";
return ss.str();
} 
bool valid() const { return m_valid; } 
typedef std::map<StrTy, StrTy> Map;
Map m_kvp;
bool m_valid;
}; // _response
typedef std::map<StrTy,_response> RespMap;














// API 
public:
typedef FetchInfo fetch_info;
mjm_chromate() {Init();}
~mjm_chromate() {Free();}
void done() {Free();}
IdxTy launch() {
MM_ERR(" if this fails start in new bash window as ld path may be bad")
 return Launch();}
IdxTy close() { return Close();}
IdxTy use_user(const StrTy & u, const IdxTy flags=0)
{ return UseUser(u,flags); } 
// this needs to be called after launching although could fix... 
IdxTy set_user_agent(const StrTy ua, const IdxTy flags )
{return  SetUA( ua,  flags ); } 
// make a pdf file 
fetch_info print_page(const StrTy & fn, const StrTy & url, const IdxTy flags)
{ return PrintPage(fn,url,flags); } 
// put into zzzz
fetch_info fetch(const StrTy & url, const IdxTy flags) 
{ 
if (m_threw) { MM_ERR(" already threew ") return FetchInfo(); } 
try{ 
return Fetch(url,flags);
} catch (FetchInfo fi) {m_threw=true;  MM_ERR(" fetch threw "<<MMPR(fi.dump())) return fi; } 

}

fetch_info save(const StrTy & fn, const StrTy & url, const IdxTy flags)
{
if (m_threw) { MM_ERR(" already threew ") return FetchInfo(); } 
fetch_info fi;
try{ 
 fi=fetch(url,flags);
} catch (FetchInfo fi) {m_threw=true;  MM_ERR(" fetch threw "<<MMPR(fi.dump())) return fi; } 
MM_ERR("saving "<<MMPR3(fn,fi.doc.length(),url))
std::ofstream save(fn);
save<<fi.doc;
return fi;
} // save

void bro_cmd(const StrTy & url, const IdxTy flags) 
{ return BroCmd(url,flags);}
// if using this without the flag bit 0 set it will not wait and 
// likely fail 
fetch_info download(const StrTy & fn,const StrTy & url, const IdxTy flags) 
{ return Download(fn,url,flags);}
// this will wait a long time if server fails but should wait for downlaod
fetch_info wget(const StrTy & fn,const StrTy & url,const IdxTy flags) 
{ return Download(fn,url,1);}
// int in seconds lol but scales for perforenacne 
void mysleep(const IdxTy n) const { const IdxTy tc=1000000>>2; usleep(n*tc); }


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

void renew_wscat(const IdxTy s1, const IdxTy s2,const IdxTy flags)
{
MM_ERR(" renew wsbast" )
m_wscat.kill();
sleep(s1); // sleep(5);
m_wscat=WsCat();
m_wscat.launch(m_url);
sleep(s2); // sleep(3);
fetch_info fi;
Ragged r=ExecBroCmd(fi,"attach",m_target);
StrTy sess=m_json.any_kv(r,"sessionId",0,flags);
m_session=sess;
MM_ERR(MMPR(sess))
MM_ERR(" done  renew wsbast" )
//WsCat m_wscat;

} // renew_wscat

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR4(m_port,m_fifo, m_bro_name, m_options);
ss<<MMPR4(m_port_option,m_user_dir,m_user_profile, m_bro);
ss<<MMPR3( m_download_path,m_tmp_dir,m_download_dir);
ss<<MMPR4( m_ua,  m_url, m_state,  m_id_cnt);
ss<<MMPR3( m_current_ua,m_target,m_session);
ss<<MMPR(m_wscat.dump());
//WsCat m_wscat;

return ss.str(); }
typedef mjm_thread_util<Tr> ThreadTy;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
StrTy Exec(const StrTy & cmd) 
{
Blob dest,err,data;
// no trailing crtlf
const IdxTy rc=m_hand.fileio(dest,err,data,cmd,1);
MM_ERR(MMPR4(rc,cmd,StrTy(dest),StrTy(err)))
return StrTy(dest);
}
//m_mutex_vector = MutexVector(MU_SZ);
class tpclass
{
public:
Myt * p;
StrTy cmd;
}; // tpclass
static void * LaunchBro (void * p)
{
tpclass * tpc=(tpclass*) p;
Myt * pp=tpc->p; // (Myt*) p;
pp->Exec(tpc->cmd);
pp->m_state=0;
MM_ERR(" bro thread exits doh ")
//Blob dest,err,data;
//pp->m_hand.fileio(dest,err,data,tpc->cmd);
//MM_ERR(MMPR2(StrTy(dest),StrTy(err)))
delete tpc;
return 0;
}
IdxTy Launch() { 
if (m_state)
{
MM_ERR(" mjm_chromate already launched ")
return 0;

} 
// this dettached.. 
StrTy aval=FindListener();
if (aval.length())
{
MM_ERR(" not launching browser as already a listener "<<MMPR2(aval,aval.length()))
return ~0; 
}
//StrTy cmd=StrTy("(")+m_bro +StrTy(" 2>&1 | tee /tmp/fifo >/dev/null) ");
StrTy cmd=StrTy("(")+m_bro +StrTy(" 2>&1 | tee bro_log.txt  | tee /tmp/fifo >/dev/null) ");
MM_ERR(MMPR(cmd))
tpclass* ptpc = new tpclass();
tpclass & tpc=*ptpc;
tpc.p=this;
tpc.cmd=cmd;
auto tp=ThreadTy::launch(& Myt::LaunchBro,&tpc);
m_thread=tp;
// DANGER WILL ROBINSON
// everyone on this thread is ok waiting for laucnh, no problem here 
m_state=1;
//Blob dest,err,data;
//m_hand.fileio(dest,err,data,cmd);
//MM_ERR(MMPR2(StrTy(dest),StrTy(err)))

StrTy pid;
IdxTy cnt=0;
while (pid=="")
{
if (m_state==0)
{
MM_MSG(" browser command died see log may have ld path bad ")
MM_ERR(" browser command died see log may have ld path bad ")
return ~0;
}// failed cmd 
++cnt;
if (cnt>10) 
{

return ~0; 
} //cnt
mysleep(1);
pid=FindListener();
} // while 
//File x=open(m_fifo.c_str(),O_RDONLY);
std::ifstream ifs(m_fifo);
MM_ERR(MMPR3(pid,ifs.good(),ifs.eof()))
// DevTools listening on ws://127.0.0.1:9222/devtools/browser/4fa153b9-25fd-471f-aa37-73f2a5450262
//while(ifs.good())
while(true)
{
if ( ifs.eof()||!ifs.good())
{
MM_ERR(MMPR3(pid,ifs.good(),ifs.eof()))
if (FindListener().length())
{
mysleep(1);
ifs.clear();
}
else break;
} // eof
StrTy xx;
ifs>> xx;
//MM_ERR(MMPR(xx))
if (xx=="DevTools")
{
ifs>> xx;
if (xx=="listening")
{
ifs >>xx;
ifs >>xx;
m_url=xx;
MM_ERR(MMPR(m_url))
m_wscat.launch(m_url);
return 0;
} // listening

}
} // while  

//close(x);
return 0;

} // Launch 
template <class Ty> void Check(Ty*  inf)
{
const bool eof=(*inf).eof();
const bool good=(*inf).good();
if ( eof ||!good)
{
MM_ERR(MMPR2(eof,good));
(*inf).clear();
mysleep(1);
}
} // Check
StrTy SRfck(const StrTy & cmd, const IdxTy flags)
{
StrTy x;
auto otf=m_wscat.out();
auto inf=m_wscat.in();
MM_ERR(MMPR(cmd))
(*otf)<<cmd<<"\n";
(*otf).flush();
StrTy xx;
Check(inf);
(*inf)>>xx;
MM_ERR("from wscat "<<MMPR(xx))
while (xx!=">") 
{
MM_ERR("looking for >" << MMPR(xx))
x=x+xx;
Check(inf);
(*inf)>>x;
} // xx
return x;
} // SR

StrTy SR(const StrTy & cmd, const IdxTy flags)
{
const bool no_wait=Bit(flags,0);
++m_id_cnt;
StrTy x;
FILE* otf=m_wscat.outfdd();
if (otf==0)
{
MM_ERR(" otf is null probably shutdown  and dynamic hazard lol ")
return StrTy(); 
}
MM_ERR(MMPR2(otf,cmd))
MM_ERR(MMPR(wscato(0,0,0)))
MM_ERR("")
StrTy carap=cmd+"\r";
fwrite(carap.c_str(),1,carap.length(),otf);
fflush(otf);
//(*otf)<<cmd<<"\n";
//(*otf).flush();
if (!no_wait) x=wscato(1,5,0);
MM_ERR(MMPR(cmd))
MM_ERR("")
MM_ERR(MMPR(x))

return x;
}
// this needs to return if disconnected.. 
//bool bro_connected()const { return (m_wscat.infdd()!=0); } 
bool bro_connected()const { return (m_wscat.inf_ok()); } 
StrTy  wscato(const IdxTy n, const IdxTy ns,const IdxTy flags)
{
StrTy x; 
FILE* inf=m_wscat.infdd();
MM_ERR(MMPR(inf))
if (inf==0)
{
// this happens during shutdown and leaks files... 
MM_ERR(" null file pointer "<<MMPR(inf))
return StrTy();
}
// this could still die though if inf is killed
/// try catch? ... 
long unsigned int fsz=1<<20;
long unsigned int fszlim=fsz-4;
char * line= new char[fsz];
IdxTy lines=0;
IdxTy sleeps=0;
IdxTy pos=0;

while (true)
{
int c=fgetc(inf);
if (c!=EOF)
{
line[pos]=c;
++pos;
//MM_ERR(MMPR4(c,char(c),pos,x.length()))
if (pos==fszlim)
{
line[pos]=0;
x+=StrTy(line);
pos=0;
} // pos 
if (c=='\r') ++lines;
else if (c=='\n') ++lines;
} // EOF 
else {
MM_ERR("EOF"<< MMPR3(x,lines,sleeps))
// this is the culprit maybe not the other one.. 
if (false) ReleaseDebug(1,0);
if (lines>=n)if ((ns==0)||(sleeps>0)) break;
if (sleeps>=ns) break;
if (AppearsAlive()) mysleep(1);
else MM_ERR(" wants to wait but no alive "<<MMPR2(__FUNCTION__,m_state))
++sleeps;
continue;
}
//sleep(1);
} // while 
line[pos]=0;
x+=StrTy(line);
MM_ERR("returns "<< MMPR2(__FUNCTION__,x))
delete[] line;
return x;
} //wscato 
////////////////////////////////////////

StrTy  xxxwscato(const IdxTy n, const IdxTy flags)
{
StrTy x; 
FILE* inf=m_wscat.infdd();
long unsigned int fsz=1<<20;
char * line= new char[fsz];
IdxTy lines=0;
while (true)
{
long unsigned int sz=fsz;
getline(&line,&sz,inf);
//x+=StrTy(line)+"\n";
x+=StrTy(line);
if (strlen(line)) ++lines;
MM_ERR(MMPR4(strlen(line),sz,x,x.length()))
int c=fgetc(inf);
ungetc(c,inf);
MM_ERR(MMPR2(c,char(c)))
if ( c==27){ fgetc(inf);  continue; }
// it outputs a > SPACE doh 
if ( c=='>'){
c=fgetc(inf); // get rid of the prompt 
c=fgetc(inf);
if (c==EOF) { if (lines>=n)  break; } 
else if (c==' ' ){ if (lines>=n)  break; } 
else ungetc(c,inf); // see if eof... 
}
if (c==EOF)
{
MM_ERR("EOF")
mysleep(1);
continue;
}
mysleep(1);
}
delete[] line;
return x;
} //xxxwscato 
////////////////////////////////////////

bool AppearsAlive() const { return bro_connected()&&Bit(m_state,0); } 
typedef mjm_ragged_table Ragged;
void FindResponses(RespMap & rm, const Ragged & r)
{
/*
23|GLOBAL|2||3|sessionId|=|6393F0DF5C007523A672AE3E19C1FFE6
24|GLOBAL|8|GLOBAL|=|method
25|GLOBAL|9|GLOBAL|=|Network.responseReceived
26|GLOBAL|10|GLOBAL|=|params
27|GLOBAL|11||12|requestId|=|DB9159208A634DA9998E6AC5943E1004
28|GLOBAL|11||12|loaderId|=|DB9159208A634DA9998E6AC5943E1004
29|GLOBAL|11||12|timestamp|=|702214
30|GLOBAL|11||12|type|=|Document
31|GLOBAL|11||12|response|13|url|=|https://www.uwmedicine.org/sites/stevie/files/2020-05/copper-deficiency-in-liver-diseases-a-case-series-and-pathophysiological-considerations.pdf
32|GLOBAL|11||12|response|13|status|=|200
33|GLOBAL|11||12|response|13|statusText|=|
34|GLOBAL|11||12|response|13|headers|14|accept-ranges|=|bytes
35|GLOBAL|11||12|response|13|headers|14|age|=|87279
36|GLOBAL|11||12|response|13|headers|14|cache-control|=|max-age=31536000, public
37|GLOBAL|11||12|response|13|headers|14|content-length|=|583154
38|GLOBAL|11||12|response|13|headers|14|content-type|=|application/pdf
39|GLOBAL|11||12|response|13|headers|14|date|=|Sat, 06 Apr 2024 19:34:47 GMT
40|GLOBAL|11||12|response|13|headers|14|expires|=|Fri, 19 Apr 2024 19:20:07 GMT
41|GLOBAL|11||12|response|13|headers|14|last-modified|=|Tue, 12 May 2020 01:53:34 GMT
42|GLOBAL|11||12|response|13|headers|14|server|=|nginx


*/

const bool field_dump=!false;
StrTy blob="";
StrTy rid="";
_response resp;
for(IdxTy i=0; i<r.size(); ++i)
{
if (field_dump) MM_ERR(" testing line "<<MMPR(i))
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
if (len<5) continue;
Ss ss;
if (field_dump) MM_ERR(" looking at  line "<<MMPR2(len,l[len-1]))
StrTy thisblob=l[1];
if (thisblob!=blob) 
{
if (resp.valid())  rm[rid]=resp;
resp=_response();
blob=thisblob;
}
StrTy k=l[len-3];
StrTy ty=l[4];
StrTy v=l[len-1];
MM_ERR(MMPR4(__FUNCTION__,k,ty,v))
if (k=="requestId") { resp.add(k,v);  rid=v; continue; } 
if (ty=="response") if (k=="status") { resp.add(k,v);   continue; } 
if (ty=="response") if (k=="content-type") { resp.add(k,v);  continue; } 
if (ty=="response") if (k=="content-length") { resp.add(k,v);  continue; } 
if (ty=="response") if (k=="url") { resp.add(k,v);  continue; } 


} // i 
if (resp.valid())  rm[rid]=resp;
MM_LOOP(ii,rm) { MM_ERR(MMPR2((*ii).first,(*ii).second.dump())) }
} // FindResponses


Ragged CmdGet(fetch_info & fi, const StrTy & cmd, const IdxTy flags)
{
const bool no_sleep=Bit(flags,8);
/*

1|GLOBAL|7||8|GLOBAL|=|34
2|GLOBAL|10||11|id|=|12
3|GLOBAL|10||11|result|12|root|13|nodeId|=|11
4|GLOBAL|10||11|result|12|root|13|backendNodeId|=|72
5|GLOBAL|10||11|result|12|root|13|nodeType|=|9
6|GLOBAL|10||11|result|12|root|13|nodeName|=|#document
7|GLOBAL|10||11|result|12|root|13|localName|=|
8|GLOBAL|10||11|result|12|root|13|nodeValue|=|
9|GLOBAL|10||11|result|12|root|13|childNodeCount|=|2

*/

// this incs m_id_cnt
const IdxTy tid=m_id_cnt;
Ss ssfck; ssfck<<tid;
StrTy ti=SR(cmd,flags);
Ragged r;
bool right_one=false;
IdxTy tries=0;
StrTy lastid="";
while (AppearsAlive()&&!right_one)
{
++tries;
if (tries>5) break; // return r;
//if (!no_wait) x=wscato(1,5,0);
Ss js(ti);
auto pr=m_json.dirty_parse(js,0);
//Ragged & r=pr.res;
r=pr.res;
MM_ERR(__FUNCTION__<<MMPR2(tries,tid))
MM_ERR(MMPR(r.dump()))
MM_ERR("testing for RESPONSES ")
RespMap rm;
//void FindResponses(RespMap & rm, const Ragged & r)
// this doesn't work because the requestId is not unique
// and being used to load the stpid page icon or other
// crap laeter.. 
if (false) FindResponses(rm,r);
MM_LOOP(ii,rm)
{
const auto & resp=(*ii).second;
const StrTy app=resp.get("content-type");
MM_ERR(" checking "<<MMPR2((*ii).first,app))
if (app=="application/pdf")
{
const StrTy rid=(*ii).first;
sleep(2);
Ragged s=ExecBroCmd(fi, "get_response",rid);
MM_ERR(MMPR(s.dump()))
MM_ERR(MMPR(fi.doc))
ExtractDoc(fi,"body");
MM_ERR(MMPR3(fi.error,fi.doc.length(),fi.actual_doc))
if (fi.error=="") 
{
fi.actual_doc=true;
return r;
} // found it 
}
} // ii


MM_ERR("testing for fail ")

/*
the new bro is returning two things one with id doh wtf 
 x=> {"method":"Target.targetCreated","params":{"targetInfo":{"targetId":"CB32E61B549F55A2715871E63385BAD2","type":"page","title":"about:blank","url":"about:blank","attached":false,"canAccessOpener":false,"browserContextId":"24DEFD879590AE1FB76552E7AD56B6E6"}}}
{"id":2,"result":{}}

getting parsed wrong, 
8|GLOBAL|6|GLOBAL|=|id
9|GLOBAL|7|GLOBAL|=|2
10|GLOBAL|8|GLOBAL|=|result


*/
const bool field_dump=false;

for(IdxTy i=0; i<r.size(); ++i)
{
if (field_dump) MM_ERR(" testing line "<<MMPR(i))
Ragged::Line & l=r[i];
const IdxTy len=l.size();
if (len<3) continue;
Ss ss;
if (field_dump) MM_ERR(" looking at  line "<<MMPR(l[len-1]))
//MM_LOOP(ii,l) ss<<(*ii)<<"|";
//MM_ERR(MMPR3(__FUNCTION__,i,ss.str()))
//MM_ERR(MMPR3(i,l[len-3],l[len-1]))
if (l[len-3]=="id")
{
lastid=l[len-1]; if (l[len-1]==ssfck.str()) right_one=true;  continue;  

} // id  
// new stuff 

if (l[len-1]=="id")
{
MM_ERR(" have new format id "<<MMPR(l[len-1]))
IdxTy locid=i+1;
if (locid<r.size())
{
Ragged::Line & l2=r[locid];
if (l2.size()>0)
{
lastid=l2[l2.size()-1]; 
MM_ERR(" lookgin for ne cod e "<<MMPR3(l2[0],l2[l2.size()-1],ssfck.str()))
if (lastid==ssfck.str()) right_one=true;  continue;  
} // zero 

} // locid 

} // newstuff 

if (l[len-3]=="errorText"){  fi.error+=l[len-1]; MM_ERR(" setting error "<<MMPR(l[len-3])) } 
//if (len<5) continue;
if (len>4) //  continue;
if (l[len-5]=="error"){  fi.error+=l[len-1]; MM_ERR(" setting error "<<MMPR(l[len-1])) } 
}
if (right_one) break;
if (!AppearsAlive()) break;
if (no_sleep) break;
if (!bro_connected())
{
MM_ERR(" does not seem connected so stop ")
break;
} // 
mysleep(1);
ti=wscato(1,5,0);
} // While

fi.doc=ti;
fi.right_one=right_one;
MM_ERR(":exiting"<< MMPR4(__FUNCTION__,right_one,tid,lastid)<<MMPR(tries))
return r;

} // CmdGet

StrTy IdAdd(const StrTy & cmd, const IdxTy flags=0)
{
StrTy cmds2="}";
Ss ss;
ss<<cmd;
ss<<m_id_cnt;
ss<<cmds2;
MM_ERR(MMPR(ss.str()))
return ss.str();
} // IdAdd
// only used by BroCmd for user intercace could delete.. 
StrTy  FinishBroCmd(const StrTy & u, const IdxTy flags) 
{
StrTy cmd=u;
const bool add_session=Bit(flags,0);
const bool add_id=Bit(flags,1);
if (add_session)
{
StrTy spfx="{\"sessionId\":\""+m_session+"\",\"method\":\"";
cmd=spfx+cmd;
} 
if (add_id)
{
Ss ss;
ss<< ",\"id\":";
cmd+=IdAdd(ss.str());
}
return cmd;
} /// FinishBroCmd
// only used for raw command input 
// TODO provide interface for serialized and sessioned cmd etc  
void BroCmd(const StrTy & u, const IdxTy flags) 
{

StrTy cmd=FinishBroCmd(u,flags);
MM_ERR(MMPR(cmd))
fetch_info fi;
Ragged r=CmdGet(fi,cmd,flags);

} // BroCmd


IdxTy  StartBrowser( const IdxTy flags) 
{
IdxTy rc=0;
fetch_info fi;
// new chrome apparently needs to create a target, will be ignored by old I hope lol 
Ragged r;
if (m_target=="") { 
{
// hide any errors for old bro 
fetch_info fi;
if ( !m_chrome_with_head) // ExecBroCmd(fi,"evaluate",
r=ExecBroCmd(fi,"create_target");
// TODO need to check output to see which one to use 
//auto tm=m_json.index(r,flags);
//StrTy tid=m_json.kvm(tm,"type","page","targetId");
//StrTy any_kv(const Ragged & r, const StrTy & k, const IdxTy n, const IdxTy flags)
StrTy tid=m_json.any_kv(r,"targetId",0,0);
MM_ERR(" create traget returnts "<<MMPR(tid))
m_target=tid;
} // new stuff 
// this had been set to false 
if (!false) if (m_target=="") 
{ 
if (!false) {  r=ExecBroCmd(fi,"discover_targets"); }

auto tm=m_json.index(r,flags);
StrTy tid=m_json.kvm(tm,"type","page","targetId");
m_target=tid;
MM_ERR(" target id="<<MMPR(tid))
} 

} // m_target



// https://stackoverflow.com/questions/45374377/not-able-to-maximize-chrome-window-in-headless-mode
if (m_session=="")
{

Ragged r=ExecBroCmd(fi,"attach",m_target);

StrTy sess=m_json.any_kv(r,"sessionId",0,flags);
m_session=sess;
MM_ERR(MMPR(sess))
StrTy ua= m_ua; //  "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36";
SetUA(ua,0);
// this fails.. 
if (false) if ( m_chrome_with_head) ExecBroCmd(fi,"evaluate",
//StrTy("driver.manage().window().minimize();")
//StrTy("webdriver.manage().window().minimize();")
//StrTy("window.minimize();")
StrTy("window.minimize;")
);
if (!false) if ( m_chrome_with_head) ExecBroCmd(fi,"evaluate",
StrTy("window.resizeTo(100,100);")
);

if (false) ExecBroCmd(fi,"navigator_override");
if (true) ExecBroCmd(fi,"delete_window");

// in head mode it downloads after verify into Download dir.. 
 // https://www.researchgate.net/profile/Arman-Mahboubi-Soufiani/publication/283729703_Optical_Properties_of_Photovoltaic_Organic-Inorganic_Lead_Halide_Perovskites/links/614b94473c6cb31069875863/Optical-Properties-of-Photovoltaic-Organic-Inorganic-Lead-Halide-Perovskites.pdf
fetch_info fi;
SetDownloadPath(fi,m_download_dir,1);


} // m_session 

return rc;

} // StartBrowser

IdxTy SetUA(const StrTy ua, const IdxTy flags )
{
fetch_info fi;
Ragged r=ExecBroCmd(fi,"ua",ua);
// 2025-04-15
Ragged r2=ExecBroCmd(fi,"uanet",ua);
Ragged r3=ExecBroCmd(fi,"uaweb",ua);
m_current_ua=ua;

return 0; 
} // SetUA

// eh TODO FIXME really good case for try/catch lol. 
fetch_info PrintPage(const StrTy & fn, const StrTy & url, const IdxTy flags) 
{
fetch_info fi;
MM_ERR(MMPR3(__FUNCTION__,fn,url))
try { 
IdxTy rc=GoToPage(fi,url,flags);
if (false) if ((rc!=0)||fi.error.length()) throw fi.line(__LINE__);
//{ MM_ERR(" aborting pageprint due to  due to problm.. "<<MMPR3(fn,url, fi.error)) fi.doc=""; return fi; }
// just the core let the thing finish it
//MM_ERR(" long sleep defeat ")
//sleep(10);


//StrTy u="Page.printToPDF\"";
//StrTy cmd=FinishBroCmd(u,3);
//Ragged r=CmdGet(fi,cmd,flags);
Ragged r=ExecBroCmd(fi,"print_pdf",url);

if (false) if (fi.error.length()) throw fi.line(__LINE__);


//{ MM_ERR(" aborting pageprint due to  due to problm.. "<<MMPR3(fn,url, fi.error)) fi.doc=""; return fi; }
// parse the return leave in the junk 
ExtractDoc(fi,"data");
if (false) if (fi.error.length()) throw fi.line(__LINE__);
// { MM_ERR(" aborting pageprint due to  due to problm.. "<<MMPR3(fn,url, fi.error)) fi.doc=""; return fi; }
typedef mjm_read_buffer<Tr>  RdBuff;
RdBuff  rd;
mjm_strings::base64_decode(rd,fi.doc);
std::ofstream fck(fn);
rd.write(fck,0);

} catch (fetch_info & fi)
{
 MM_ERR(" abort pageprint due to  "<<MMPR4(fi.eline, fn,url, fi.error))
 fi.doc=""; 

}
return fi;
} // PrintPage


IdxTy ExtractDoc(fetch_info & fi,const StrTy & field, const IdxTy flags=0)
{
IdxTy rc=0;
const bool put_error_in_doc=!Bit(flags,0);
const bool print_error=true;
Ss js(fi.doc);
auto pr=m_json.dirty_parse(js,0);
Ragged & r=pr.res;
MM_ERR(__FUNCTION__<<MMPR(field))
MM_ERR(MMPR(r.dump()))
bool found=false;
for(IdxTy i=0; i<r.size(); ++i)
{
const Ragged::Line & l = r[i];
const IdxTy len=l.size();
if (len<3) continue;
// the fcking euqals is in the furkc asdf asdf 
//Ss ss;
//MM_LOOP(ii,l) ss<<(*ii)<<"|" ; 
//MM_ERR(MMPR4(__FUNCTION__,ss.str(),i,l[len-3]))
//if (l[len-3]=="outerHTML") { fi.doc=l[len-1]; found=true; break ; } 
if (l[len-3]==field) { 
fi.doc=l[len-1]; 
found=true; break ; } 
}// i 
if (!found ) { fi.error+="not found"; if (put_error_in_doc)  fi.doc=r.dump(3); rc=1; } 
if (!found) if (print_error)
{
MM_ERR(MMPR(r.dump(3)))

}
return rc;
} // ExtractDoc



IdxTy GoToPage(fetch_info & fi,const StrTy & url, const IdxTy flags)
{
IdxTy rc=0;
try{ 
// NOTE this is bit eight not zero lol. 
const bool skip_dom=Bit(flags,8);

IdxTy sb=StartBrowser(flags);
if (m_state==0)
{

MM_ERR(" not trying as state is reset "<<MMPR3(url,flags,__FUNCTION__))
return 2;
} // m_state

// move here? 
ExecBroCmd(fi, "enable_scripts");
if (fi.error!="" ) return 1; 

const bool  inject_mouse=true;
if ( inject_mouse)
{ 
if (!false) { ExecBroCmd(fi,"enable_focus"); }
// https://github.com/chromedp/chromedp/issues/211
if (!false) { ExecBroCmd(fi, "enable_network" ,flags); }
if (!false) { ExecBroCmd(fi, "missing_headers" ,flags); }
// BeginFrameControl
if (!false) 
{
if (! m_chrome_with_head)
{ 
// TODO may not exist? 
if (false) ExecBroCmd(fi, "enable_frame_control" ,flags);
// this is only supported in headless mode... doh 
// seems to prevent rendering? 
if (false) ExecBroCmd(fi, "begin_frame" ,flags);
}
}
ExecBroCmd(fi, "enable_animation" ,flags);
ExecBroCmd(fi, "discover_targets" ,flags);
}
///////////////////////////////////////////////
const bool b_renew_wscat=true;
// wtf this is in the wrong place thought it was after naviaget lol 
if (m_chrome_with_head&& b_renew_wscat)
//if (renew_wscat)
{
renew_wscat(5,5,flags);
/*
MM_ERR(" renew wsbast" )
m_wscat.kill();
sleep(5);
m_wscat=WsCat();
m_wscat.launch(m_url);
sleep(3);
fetch_info fi;
Ragged r=ExecBroCmd(fi,"attach",m_target);
StrTy sess=m_json.any_kv(r,"sessionId",0,flags);
m_session=sess;
MM_ERR(MMPR(sess))
MM_ERR(" done  renew wsbast" )
//WsCat m_wscat;
*/
} // renew_wscat


///////////////////////////////////////
// this stops everything lol 
const bool new_junk=!true;
if (new_junk)
{
MM_ERR(" disable debugger")
ExecBroCmd(fi,"disable_debugger",flags); // needs to be a const not flags 
sleep(10);
MM_ERR(" endabe debugger")
ExecBroCmd(fi,"enable_debugger",flags); // needs to be a const not flags 
}

// 2025-04-19 does nothing still getting HeaclessChrome UA 
SetUA(m_ua,0);


// in head mode it downloads after verify into Download dir.. 
 // https://www.researchgate.net/profile/Arman-Mahboubi-Soufiani/publication/283729703_Optical_Properties_of_Photovoltaic_Organic-Inorganic_Lead_Halide_Perovskites/links/614b94473c6cb31069875863/Optical-Properties-of-Photovoltaic-Organic-Inorganic-Lead-Halide-Perovskites.pdf
fetch_info fi;
SetDownloadPath(fi,m_download_dir,1);


// navigate likely just causing a bad request 
// wrong cross origin fck up doh 
// this worked in one test case that was slently failing. 
// after all that it doesn't exist 
//ExecBroCmd(fi, "refpol",url);
if (m_use_ref)
{
StrTy ref="https://www.google.com"; 
MM_MSG(" vavigating with ref "<<MMPR2(url,ref))
ExecBroCmd(fi, "navigateref",url,ref);
}
else { ExecBroCmd(fi, "navigate",url); }

SetDownloadPath(fi,m_download_dir,1);
if (skip_dom) return 0; 


if (inject_mouse)
{

MM_ERR(" sleeping for input ")
sleep(3);
ExecBroCmd(fi,"mouse_moved","100","120");
sleep(3);
//fetch_info fi;

ExecBroCmd(fi,"get_targets",flags); // needs to be a const not flags 
ExecBroCmd(fi,"get_frametree",flags); // needs to be a const not flags 
if ( m_chrome_with_head)
{
// this appears to help render but then misses events lol 
ExecBroCmd(fi,"disable_debugger",flags); // needs to be a const not flags 
sleep(2);
ExecBroCmd(fi,"enable_debugger",flags); // needs to be a const not flags 
//}
}
if (fi.error!="" ) return 1; 
} // inject_mouse

if (skip_dom) return 0; 

// TODO danger will robinson? 
// this was called twice... 
ExecBroCmd(fi,"get_document");
Ragged r=ExecBroCmd(fi,"get_document");
// try it twice wth
//r=CmdGet(fi,IdAdd(gdcmd),flags);

if (fi.error!="" ) return 1; 
//r=CmdGet(fi,IdAdd(gdcmd),flags);

// need to get root node...
/*
./mjm_chromate.h372  r.dump()=0|GLOBAL|1||2|GLOBAL|=|2
1|GLOBAL|7||8|GLOBAL|=|34
2|GLOBAL|10||11|id|=|12
3|GLOBAL|10||11|result|12|root|13|nodeId|=|11
4|GLOBAL|10||11|result|12|root|13|backendNodeId|=|72
5|GLOBAL|10||11|result|12|root|13|nodeType|=|9
6|GLOBAL|10||11|result|12|root|13|nodeName|=|#document
7|GLOBAL|10||11|result|12|root|13|localName|=|
8|GLOBAL|10||11|result|12|root|13|nodeValue|=|
9|GLOBAL|10||11|result|12|root|13|childNodeCount|=|2

3|GLOBAL|12||13|result|14|root|15|nodeId|=|1
4|GLOBAL|12||13|result|14|root|15|backendNodeId|=|2
5|GLOBAL|12||13|result|14|root|15|nodeType|=|9
6|GLOBAL|12||13|result|14|root|15|nodeName|=|#document
7|GLOBAL|12||13|result|14|root|15|localName|=|
8|GLOBAL|12||13|result|14|root|15|nodeValue|=|
9|GLOBAL|12||13|result|14|root|15|childNodeCount|=|2
10|GLOBAL|12||13|result|14|root|15|children|16||17|nodeId|=|2
11|GLOBAL|12||13|result|14|root|15|children|16||17|parentId|=|1
12|GLOBAL|12||13|result|14|root|15|children|16||17|backendNodeId|=|81



*/
for(IdxTy i=0; i<r.size(); ++i)
{
const Ragged::Line &  l=r[i];
const IdxTy sz=l.size();
if ( sz<5) continue;
if ( l[sz-5]!="root") continue;
if ( l[sz-3]=="backendNodeId")
{
fi.back_end_node=l[sz-1];
 continue;
}
if ( l[sz-3]!="nodeId") continue;
fi.root_node_id=l[sz-1];

} /// i t
} 
catch (...)
{
MM_ERR(" failed "<<MMPR(__FUNCTION__))
return ~0; 
} // catch 
return rc;
} // GoToPage

IdxTy Close()
{
if (m_state==0)
{
MM_ERR(" alrady closed "<<MMPR(m_state))
return 0;
}
char c=3;
char d=4;
char cc[4];
cc[0]=c;
cc[1]=c;
cc[2]=d;
cc[3]=0;

StrTy ctrlc=cc;

fetch_info fi;
//ExecBroCmd(fi,"disable_debugger",flags); // needs to be a const not flags 
//StrTy ccmd="{\"method\":\"Browser.close\",\"id\":";
//Ragged r=CmdGet(fi,IdAdd(ccmd),0);
ExecBroCmd(fi,"close_browser",3); // needs to be a const not flags 
MM_ERR(" issued close to browser, now cleaning temps ")
mysleep(1);
// this is hanging... 
StrTy xxx=SR(ctrlc,1);
MM_ERR(MMPR(xxx))
// this may be causing io problems on bro thread 
//m_hand.clean();
return 0;
}
////////////////////////////////////////////////////////////////////////

StrTy LocalFile(IdioRl & irl)
{
// this needs to remove the file://
return irl.fs_path(); // StrTy(irl);
}
StrTy CompleteDest(const StrTy  & fn, const bool fix_output_location )
{
//m_tmp_dir="/tmp"; m_download_path="./chromate_downloads"; m_download_dir=m_tmp_dir+"/"+m_download_path;
StrTy base,file;
base=Exec("dirname \""+fn+"\"");
file=Exec("basename \""+fn+"\"");
MM_ERR(MMPR4(__FUNCTION__,fn,base,file))
return fn;
}
fetch_info Download(const StrTy & fn, const StrTy & url, const IdxTy flags) 
{
 
const bool fix_output_location=Bit(flags,0);
const bool parse_source_info=!Bit(flags,1);
fetch_info fi;

DirWatch dw;

IdioRl irl=url;
irl.parse();
MM_ERR(MMPR3(irl.dump(),irl.http(),irl.local()))
if (parse_source_info)
{
if (irl.local())
{
// this assumes "fix output location" 
Exec("cp \""+LocalFile(irl)+"\" \""+CompleteDest(fn,fix_output_location)+"\"");

return fi;
} // local

} // parse_source_info 

// this should be enought  but the cross origin crap kills it 
//IdxTy sb=StartBrowser(flags);
// this should just start browser I guess. 
// hopefully will make it same origin
IdxTy rc=GoToPage(fi,url,256);
//IdxTy rc=StartBrowser(flags);
if (m_state==0)
{
MM_ERR(" not trying as state is reset "<<MMPR3(url,flags,__FUNCTION__))
fi.error=" no browser";
return fi;
} // m_state


if ((rc!=0)||fi.error.length())
{
MM_ERR(" continue but should be aborting fetch due to problm.. "<<MMPR2(url, fi.error))
fi.doc="";
//return fi;
}

//m_tmp_dir="/tmp"; m_download_path="./chromate_downloads"; m_download_dir=m_tmp_dir+"/"+m_download_path;
//SetDownloadPath(fi,m_download_path,1);
SetDownloadPath(fi,m_download_dir,1);
MM_ERR(MMPR2(__FUNCTION__,m_download_dir))
dw.watch(m_download_dir,0);
const bool use_blank=false;
Ragged r;
//r=CmdGet(fi,IdAdd(use_blank?nocmd:nocmd2),flags);
r=CmdGet(fi,IdAdd(GetDownloadString(fn,url,use_blank?1:0)),0);
// fck not working now... 
//sleep(5);
// doh possible problem?
bool do_reload=false;
if (do_reload)
{
//StrTy u="Page.reload\"";
//StrTy cmd=FinishBroCmd(u,3);
//Ragged r2=CmdGet(fi,cmd,flags);
Ragged r2=ExecBroCmd(fi,"reload");
MM_ERR(MMPR3(__FUNCTION__,fix_output_location,r2.dump()))
}

if (fix_output_location)
{
// the file should be in m_download_path
// but needs to be in 
//Exec("cp \""+LocalFile(irl)+"\" \""+CompleDest(fn,fix_output_location)+"\"";
// first wait for file to appear
IdxTy nmax=100;
IdxTy niter=0;
MM_MSG(" waiting for download no failure detect "<<MMPR2(url,fn))
while (true)
{
StrTy output=m_wscat.drain(1,0,0);
MM_ERR(MMPR3(__FUNCTION__,niter,output))
if (niter>nmax) break;
++niter;
StrTy nm;
IdxTy stat=DirStats(nm,dw,0);
MM_ERR(MMPR4(niter,stat,dw.size(),nm))
if (stat==IdxTy(~0)) break;
//dw.check(0);
//if (dw.size()==0) { sleep(1); continue; } 
if (stat==0) { mysleep(1); continue; } 
// make sure it is "moved" and has no "crdownload" suffix... 
//const auto & e=dw.last();
//MM_ERR(MMPR(e.dump()))
//sleep(1);
//const StrTy fndest=e.name();
if (stat==1)
{
// this is the file detected by dir watch 
const StrTy fndest=nm; // e.name();
const StrTy movcmd="cp \""+m_download_dir+"/"+fndest+"\" \""+CompleteDest(fn,fix_output_location)+"\"";
MM_ERR(MMPR(movcmd))
Exec(movcmd);
break;
} // stat== 1
} // true;
// then move to final resting place...

} // fix_output_location 
return fi;
} // Download

IdxTy DirStats(StrTy&nm,DirWatch & dw, const IdxTy flags=0)
{
IdxTy checkrc=dw.check(0);
MM_ERR(MMPR2(__FUNCTION__,checkrc))
if (checkrc==IdxTy(~0)) return checkrc;
const IdxTy sz=dw.size(); 
if (sz==0) { return 0;  } 
IdxTy i=0;
const StrTy sfx=".crdownload";
StrTy n1,n2;
while (true)
{
const auto & e0=dw.event(i);
MM_ERR(MMPR(e0.dump()))
// this looks premature but we want i incremented
// for next test and there has to be one more or too early... 
{ ++i; if (i>=sz) return 0; } // down 
n1=e0.name();
const bool down=(0==StrUtil::ends_with(n1.c_str(),sfx.c_str()));
MM_ERR(MMPR4(i,n1,sfx,down))
if (down){ break;} 
} // true
IdxTy bnm=n1.length()-sfx.length();
MM_ERR(MMPR3(i,bnm,sz))
while (true)
{ // i already increments if safe 
const auto & e0=dw.event(i);
MM_ERR(MMPR(e0.dump()))
n2=e0.name();
const bool down=(0==StrUtil::ends_with(n2.c_str(),sfx.c_str()));
const bool moved=e0.moved();
// TODO check for spurs etc. does not play nice with other
// instances doh 
MM_ERR(MMPR4(moved,down,n1,n2))
if (moved&&!down){if (strncmp(n1.c_str(),n2.c_str(),bnm)==0)  break;} 
{ ++i; if (i>=sz) return 0; } // down 
} // true
nm=n2;
return 1;
} // DirStats


////////////////////////////////////////////////////////////////////////
// should use the cross origin code which avoids having to navigate
// to the domain first. 
#if 0 
// https://stackoverflow.com/questions/49474775/chrome-65-blocks-cross-origin-a-download-client-side-workaround-to-force-down
function forceDownload(blob, filename) {
  var a = document.createElement('a');
  a.download = filename;
  a.href = blob;
  // For Firefox https://stackoverflow.com/a/32226068
  document.body.appendChild(a);
  a.click();
  a.remove();
}

// Current blob size limit is around 500MB for browsers
function downloadResource(url, filename) {
  if (!filename) filename = url.split('\\').pop().split('/').pop();
  fetch(url, {
      headers: new Headers({
        'Origin': location.origin
      }),
      mode: 'cors'
    })
    .then(response => response.blob())
    .then(blob => {
      let blobUrl = window.URL.createObjectURL(blob);
      forceDownload(blobUrl, filename);
    })
    .catch(e => console.error(e));
}

downloadResource('https://giant.gfycat.com/RemoteBlandBlackrussianterrier.webm');
#endif
////////////////////////////////////////////////////////////////////////


StrTy GetDownloadString(const StrTy & fn, const StrTy & url, const IdxTy flags)
{
const bool use_blank=Bit(flags,0);
if (use_blank) { return ""; }
StrTy spfx= Spfx(); // "{\"sessionId\":\""+m_session+"\",\"method\":\"";
// https://stackoverflow.com/questions/3749231/download-file-using-javascript-jquery
StrTy expr="";
expr+="fetch(\'"+url+"\')";
expr+=".then(resp => resp.blob())";
expr+=".then(blob => {";
expr+=" const url = window.URL.createObjectURL(blob);";
expr+="  const a = document.createElement(\\\"a\\\"); a.style.display = 'none'; a.href = url; a.download = \'"+fn+"\'; document.body.appendChild(a); a.click(); "; 
expr+=" window.URL.revokeObjectURL(url);";
//    alert('your file has downloaded!'); // or you know, something with better UX...
 expr+=" }) .catch(() => alert(\'oh no!\'));";

expr=" var link = document.createElement(\'a\'); link.setAttribute(\'download\', \'"+fn+"\'); link.href = \'"+url+"\'; document.body.appendChild(link); link.click(); link.remove();";

expr=" var cursor = document.getElementById(\'cursor\');";
expr+=" var link = document.createElement(\'a\'); link.setAttribute(\'download\', \'"+fn;
expr+="\'); link.href = \'"+url+"\'; document.body.appendChild(link);";
//expr+="cursor.style.left=200;";
expr+=" link.click();";
//expr+="\'); link.href = \'"+url+"\'; document.body.appendChild(link); link.click(); link.remove();";
//expr+="console.log('xxxxxx');";

MM_ERR(MMPR(expr))
StrTy nocmd2=spfx+"Runtime.evaluate\",\"params\":{\"expression\":\""+ expr + "\"},\"id\":";

return nocmd2;

} // GetDownloadString

void SetDownloadPath(fetch_info & fi, const StrTy & path, const IdxTy flags)
{
const bool make_dir=Bit(flags,0);

MM_ERR(__FUNCTION__<< MMPR2(path,make_dir))
if (make_dir)
{
const StrTy mkcmd="mkdir -p ";
const StrTy mkstr=mkcmd+" \""+path+"\"";
Exec(mkstr);

} // make_dir
//StrTy nocmd3=Spfx()+"Page.setDownloadBehavior\",\"params\":{\"behavior\":\""+ "allow" + "\",\"downloadPath\":\""+path+"\"},\"id\":";
StrTy nocmd3=Spfx()+"Page.setDownloadBehavior\",\"params\":{\"behavior\":\""+ "allow" + "\",\"downloadPath\":\""+path+"\",\"eventsEnabled\":true},\"id\":";
Ragged rs;
rs=CmdGet(fi,IdAdd(nocmd3),flags);


} // SetDownloadPath

StrTy Spfx() const 
{ return "{\"sessionId\":\""+m_session+"\",\"method\":\""; }
IdxTy wait_4_response(fetch_info& fi)
{

return 0; 
} // wait_4_response
fetch_info Fetch(const StrTy & url, const IdxTy flags) 
{ 
const bool try_script_sbro= m_use_script_as_backup;
fetch_info fi;
IdxTy rc=GoToPage(fi,url,flags);
// see if pdf came back

if ((rc!=0)||fi.error.length())
{
MM_ERR(" may want to reconsider but aborting fetch due to problm.. "<<MMPR2(url, fi.error))
fi.doc="";
return fi;
}

MM_ERR(" wait for doc func"<<MMPR(fi.right_one))
mysleep(fi.right_one?2:10);
rc=~0;
StrTy spfx="{\"sessionId\":\""+m_session+"\",\"method\":\"";
Ragged r;
//StrTy htcmd=spfx+"DOM.getOuterHTML\",\"id\":";
// TODO this often fails due to wrong node Id, need to iterate... 
//fl.back_end_node_il[sz-1];
IdxTy nodex=0;

StrTy nodeid="1";
if (fi.root_node_id!="") nodeid=fi.root_node_id;
MM_ERR(MMPR2(fi.root_node_id,nodeid))
while (true)
{
// this misses events but may be ther other call  doh 
if (false) ReleaseDebug(1,0);
if (fi.actual_doc)
{
SaveDebug(fi);
return fi;
} // actual doc
// 2024-03-06
// if (false)  
mysleep(4);
//IdxTy gotit=wait_4_response(fi);
//if (gotit==0) mysleep(4);
MM_ERR(MMPR3(fi.root_node_id,nodeid,nodex))
// all  optional 
// https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getDocument
// but need at least one... 
//StrTy htcmd=spfx+"DOM.getOuterHTML\",\"params\":{\"nodeId\":1},\"id\":";
// all these are optional lol, 
// https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getOuterHTML

StrTy htcmd=spfx+"DOM.getOuterHTML\",\"params\":{\"nodeId\":"+nodeid+"},\"id\":";
StrTy htcmdone=spfx+"DOM.getOuterHTML\",\"params\":{\"nodeId\":1},\"id\":";
StrTy htcmdopt=spfx+"DOM.getOuterHTML\",\"id\":";
StrTy htcmdb=spfx+"DOM.getOuterHTML\",\"params\":{\"backendNodeId\":"+nodeid+"},\"id\":";
Ss snode;
snode<<nodeid;
StrTy nodestr=snode.str();
StrTy htcmds=spfx+"DOM.getOuterHTML\",\"params\":{\"objectId\":\""+nodestr+"\"},\"id\":";

//StrTy htcmd=spfx+"DOM.getOuterHTML\",\"params\":{},\"id\":";
//rc=TryOneNode(fi,r,htcmdopt,0); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }
//rc=TryOneNode(fi,r,htcmd,0); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }
rc=TryOutNode(fi,r,"get_outer_node",nodeid); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }
//rc=TryOneNode(fi,r,htcmdone,0); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }
rc=TryOutNode(fi,r,"get_outer_one",StrTy()); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }
// once rc==~0 the thing has stopped responding... 
//{rc=TryOneNode(fi,r,htcmdb,0); if(rc==~0U)break; if(rc==0){SaveDebug(fi);return fi;}}
rc=TryOutNode(fi,r,"get_outer_back",nodeid); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }
//{rc=TryOneNode(fi,r,htcmds,0); if(rc==~0U)break; if(rc==0){SaveDebug(fi);return fi;}}
rc=TryOutNode(fi,r,"get_outer_obj",nodeid); if (rc==~0U) break; if (rc==0U) { SaveDebug(fi); return fi; }

if (nodex>4) break;
++nodex;
Ss ss; ss<<nodex;
nodeid=ss.str();
fi.reset_error();
fi.doc="";
} // true;
#if 0 
IdxTy tries=0;
while (tries)
{
ExtractDoc(fi,"outerHTML",1);
if (0==fi.error.length()) break;
MM_ERR(" retry html outer "<<MMPR3(tries,fi.error,url))
fi.error="";
fi.rc=0;
Ragged rx;
fetch_info fix;
// this makes confusing errors
//rx=CmdGet(fix,IdAdd(""),flags);
rx=CmdGet(fix,StrTy(""),flags);
sleep(1);
--tries;
fi.reset_error();
} // true
#endif
// parse the return leave in the junk 
// the parser is returning the parsed json of the erro in doc lol
// This was ExtractDoc fixed now... 
//if (fi.doc.length()==0) 
if (try_script_sbro) if (rc!=0) // actually tautological now with save on exit... 
{
Blob dest,err,data;
// no trailing crtlf
const StrTy cmd="me -sbro \""+url+"\"";
MM_ERR("trying me -sbro "<<MMPR(url))
const IdxTy rc=m_hand.fileio(dest,err,data,cmd,1);
MM_ERR(MMPR4(rc,cmd,StrTy(dest),StrTy(err)))
fi.doc= StrTy(dest);
if (fi.doc.length()) fi.reset_error();
} // kluge 
MM_ERR(MMPR2(fi.doc.length(),fi.error.length()))

if (fi.error.length())
{
MM_ERR(MMPR2(fi.doc,fi.error.length()))

MM_ERR(" aborting fetch due to problm with outer html .. "<<MMPR2(url, fi.error))
fi.doc="";
return fi;
}




if (fi.error.length())
{
MM_ERR(" aborting fetch due to problm with ectract doc  .. "<<MMPR2(url, fi.error))
fi.doc="";
return fi;
}

SaveDebug(fi);
// fl.doc should have the response...
#if 0
/*
 {"sessionId":"63C71C4062A47C070D7C6A657B924B47","method":"Emulation.setUserAgentOverride","params":{"userAgent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36"},"id": 3}
> {"sessionId":"9DAB33A3A266547624932C7365585A83","method":"Emulation.setNavigatorOverrides","params":{"platform":""},"id": 3}
 {"sessionId":"9DAB33A3A266547624932C7365585A83","method":"Emulation.setNavigatorOverrides","params":{"platform":"__proto__"},"id": 3}

 {"sessionId":"63C71C4062A47C070D7C6A657B924B47","method":"Page.navigate","params":{"url":"https://www.mdpi.com/2072-6643/12/7/2130/htm"},"id": 5}



*/
#endif

return fi;
} //Fetch
// debug
void ReleaseDebug(const int n,const IdxTy _flags)
{
const IdxTy flags=0; // 9*256+1;
if (m_session=="") return; 
//if (true) return; 
if ( m_chrome_with_head)
{
static int n=0;
MM_ERR(" debug release "<<MMPR(n))
//if (n) return ; 
fetch_info fi;
//StrTy spfx="{\"sessionId\":\""+m_session+"\",\"method\":\"";
//void EvalRt(const StrTy & expr, const IdxTy flags)
++n;
ExecBroCmd(fi,"disable_debugger",flags); // needs to be a const not flags 
//{ StrTy nacmd1=spfx+"Debugger.disable\",\"params\":{},\"id\":";
//Ragged rq=CmdGet(fi,IdAdd(nacmd1),flags);
//}
sleep(1);
ExecBroCmd(fi,"enable_debugger",flags); // needs to be a const not flags 
//{ StrTy nacmd1=spfx+"Debugger.enable\",\"params\":{},\"id\":";
//Ragged rq=CmdGet(fi,IdAdd(nacmd1),flags);
//}
--n;
}


} // ReleaseDebug

void SaveDebug(fetch_info & fi)
{
MM_ERR("saving to zzzz"<<MMPR2(fi.actual_doc,fi.doc.length()))
std::ofstream save("zzzz");
if (fi.actual_doc)
{
typedef mjm_read_buffer<Tr>  RdBuff;
RdBuff  rd;
mjm_strings::base64_decode(rd,fi.doc);
//std::ofstream fck(fn);
rd.write(save,0);
MM_ERR(MMPR2(rd.size(),fi.doc.length()))
}
else save<<fi.doc;
}
/*
IdxTy TryOneNode(fetch_info & fi, Ragged & r, const StrTy & cmd, const IdxTy flags)
{
fi.reset_error();
fi.doc="";
MM_ERR(MMPR2(__FUNCTION__,cmd))
r=CmdGet(fi,IdAdd(cmd),flags);
MM_ERR(MMPR(fi.error))
ExtractDoc(fi,"outerHTML",1);
MM_ERR(MMPR(fi.error))
if (!fi.right_one) { return ~0; } 
if (fi.error.length()==0) if (fi.doc.length()) return 0;

return 2;
} // TryOneNode
*/

IdxTy TryOutNode(fetch_info & fi, Ragged & r, const StrTy & cmd, const IdxTy & p )
{
Ss ss;
ss<<p;
return TryOutNode(fi,r,cmd,ss.str()); 
} 

IdxTy TryOutNode(fetch_info & fi, Ragged & r, const StrTy & cmd, const StrTy & p )
{
fi.reset_error();
fi.doc="";
MM_ERR(MMPR2(__FUNCTION__,cmd))
//r=CmdGet(fi,IdAdd(cmd),flags);
r=ExecBroCmd(fi,cmd,p);
MM_ERR(MMPR(fi.error))
ExtractDoc(fi,"outerHTML",1);
MM_ERR(MMPR(fi.error))
if (!fi.right_one) { return ~0; } 
if (fi.error.length()==0) if (fi.doc.length()) return 0;

return 2;
} // TryOutNode






IdxTy UseUser(const StrTy & u, const IdxTy flags=0)
{
m_mode=flags;
m_use_user_creds=Bit(flags,0); // false;
m_chrome_with_head=Bit(flags,1);
m_use_script_as_backup =!Bit(flags,2);
m_use_ref =!Bit(flags,3);
m_no_clean=Bit(flags,8);
if (m_no_clean) mjm_global_flags::mm_delete_temps=!true;

MM_ERR(
MMPR4(m_mode, m_use_user_creds, m_chrome_with_head, m_use_script_as_backup)
<<MMPR2(m_use_ref,m_no_clean)
)


if (m_use_user_creds) MM_MSG(" enabling mjm_chromate user credentials ");
if (m_chrome_with_head) MM_MSG(" enabling mjm_chromate with head ");
ReInitSome();

return 0; 
}


void EvalRt(const StrTy & expr, const IdxTy flags)
{

Ragged r=ExecBroCmd("evaluatel",expr);
/*
StrTy spfx="{\"sessionId\":\""+m_session+"\",\"method\":\"";
StrTy nocmd=spfx+"Runtime.evaluate\",\"params\":{\"expression\":\""+ expr + "\"},\"id\":";
fetch_info fi;
Ragged r=CmdGet(fi,IdAdd(nocmd),flags);
// fl.doc should have the response...
*/

} // EvalRt

void MakeBroCmd()
{
// this works from "me' script , 
// MYBRO="/opt/google/chrome/chrome --headless --disable-gpu --user-data-dir=/home/marchywka/.config/google-chrome/ --profile-directory=Default  --disable-plugins  --dump-dom  "
//m_user_dir="/home/marchywka/.config/google-chrome/";

Ss ss;
StrTy user_info=StrTy("--user-data-dir=")+m_user_dir+StrTy(" ")+
" --profile-directory="+m_user_profile;
const bool disable_all_user_info=!true;
if (disable_all_user_info) user_info="";

ss<<m_bro_name<<" "<<m_options<<" "<<m_port_option<<m_port<<" "<<user_info;

//StrTy ddir=" --user-data-dir=/tmp --profile-directory=Headless " ;
//Ss ss;
//ss<<"/opt/google/chrome/chrome --headless --remote-debugging-port=";
//ss<<m_port;
//ss<<ddir;
//ss<<"  --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
m_bro=ss.str();
//MM_ERR(MMPR(m_bro))


} // MakeBroCmd
// TODO duplicated code alert, see also Init wtf.. 
void ReInitSome()
{
const bool use_my_creds=m_use_user_creds; // true;
if (use_my_creds)
{
m_user_dir="/home/marchywka/.config/google-chrome/";
m_user_profile="Default";
}
else { // --user-data-dir=/home/marchywka/.config/google-chrome/ --profile-directory=Default 
m_user_dir="/tmp/";
m_user_profile="Headless";
}
// https://stackoverflow.com/questions/13436855/launch-google-chrome-from-the-command-line-with-specific-window-coordinates 

     //--app="data:text/html,<html><body><script>window.moveTo(580,240);window.resizeTo(800,600);window.location='http://www.test.de';</script></body></html>"
// this works but then it pops up another window ...   
 StrTy wtf=" --app=\"data:text/html,<html><body><script>window.moveTo(10,10);window.resizeTo(100,100);</script></body></html>\"";

if ( m_chrome_with_head)
{
//m_options=" --start-minimized  --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
// HBRO="/opt/google/chrome/chrome --remote-debugging-port=9222 --user-data-dir=\"/tmp\" "

//m_options=" --start-minimized  --window-size=128x128 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
m_options=" --start-minimized  --window-size=128x128 --enable-logging=stderr --v=1  --crash-dump-dir=/tmp ";
m_options=" --disable-plugins --start-minimized  --window-size=128x128 --enable-logging=stderr --v=1  --crash-dump-dir=/tmp ";

//m_options="  --window-size=128x128 --enable-logging=stderr --v=1  --disable-gpu   --crash-dump-dir=/tmp ";

//m_options+="  --run-all-compositor-stages-before-draw --enable-begin-frame-control ";

// /opt/google/chrome/chrome --type=renderer --crashpad-handler-pid=324949 --enable-crash-reporter=370503c9-fda7-4065-a792-175cb7d24f51, --change-stack-guard-on-fork=enable --lang=en-US --num-raster-threads=3 --enable-main-frame-before-activation --renderer-client-id=82 --time-ticks-at-unix-epoch=-1710487259700130 --launch-time-ticks=800564007984 --shared-files=v8_context_snapshot_data:100 --field-trial-handle=0,i,17382412009564627707,14195804271934628612,262144 --variations-seed-version=20240322-165906.502000

// these options prevent debug port from attaching.. 
//m_options+=" --type=renderer --change-stack-guard-on-fork=enable --lang=en-US --num-raster-threads=2 --enable-main-frame-before-activation --renderer-client-id=82 --variations-seed-version=20240322-165906.502000 ";
// fail too 
//m_options+=" --type=renderer --lang=en-US --num-raster-threads=2  --renderer-client-id=82 --variations-seed-version=20240322-165906.502000 ";

m_options+=wtf;
}
else{
//m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp ";
//m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp --run-all-compositor-stages-before-draw --enable-begin-frame-control   --disable-browser-side-navigation ";
m_options="--headless=new --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp --run-all-compositor-stages-before-draw --enable-begin-frame-control   --disable-browser-side-navigation ";

m_options=headless_base(); // "--headless=new --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp ";

//m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp --run-all-compositor-stages-before-draw --enable-begin-frame-control  ";
//m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --crash-dump-dir=/tmp ";

}
// dup code warning, see also =new 
// this does nothing either  although the real ua seems to crach invokation 
const bool add_cmd_ua=!true;
if (add_cmd_ua)
{
//m_options+=" --user-agent=\""+m_ua+"\" "; 
m_options+=" --user-agent=foobar " ; 
//if ( !m_chrome_with_head) m_options+=" --headless=new"; 

}



MakeBroCmd();
} // ReInitSome

/*
1d0
< 
5,7d3
< sec-ch-ua: "Google Chrome";v="113", "Chromium";v="113", "Not-A.Brand";v="24"
< sec-ch-ua-mobile: ?0
< sec-ch-ua-platform: "Linux"
9c5
< User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36
---
> User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36
16d11
< Accept-Language: en-US,en;q=0.9



*/

// google AI code 
IdxTy port_mush() const
{
srand(time(0));
int  n=rand()&127;
if (n==0) n=1;
return 9222+n;
}
StrTy headless_base() 
{
// net::ERR_BLOCKED_... see headless on google  turned out to be refere
// policy doh 
return " --headless=new --window-size=1920,1080 --enable-logging=stderr --v=1 --v=1 --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp --run-all-compositor-stages-before-draw --disable-site-isolation-trials --disable-web-security  ";
//return " --headless=new --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp --run-all-compositor-stages-before-draw --enable-begin-frame-control   --disable-browser-side-navigation ";
//return "--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp ";

}

void Init()
{
m_no_clean=false;
m_mode=0;
m_use_script_as_backup=true; 
m_chrome_with_head= !true; 
m_use_ref= true;
//REPL="/opt/google/chrome/chrome --headless --remote-debugging-port=9222  --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp 
// https://posts.specterops.io/hands-in-the-cookie-jar-dumping-cookies-with-chromiums-remote-debugger-port-34c4f468844e
//  wget -S -v -O xxx "http://localhost:9222/json"
// ROFL 
m_port=port_mush(); // 9222;
MM_ERR(MMPR(m_port))
//m_bro="/opt/google/chrome/chrome --headless --remote-debugging-port=9222  --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
// --user-data-dir=/home/marchywka/.config/google-chrome/ --profile-directory=Default 
m_ua="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36";
m_ua="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36";
m_ua="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36";
m_ua="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36";
// may need to match the "Brand" info 
m_ua="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36";
m_bro_name="/opt/google/chrome/chrome";
// script to pickup ld path 
m_bro_name="/opt/google/chrome/mike-chrome";
// https://stackoverflow.com/questions/54398950/how-to-fix-chrome-headless-not-downloading-files
 //   chrome_options.add_argument('--window-size=1920,1080')
 //chrome_options.add_argument('--disable-dev-shm-usage')
/*
browser.command_executor._commands["send_command"] = ("POST", '/session/$sessionId/chromium/send_command')
params = {'cmd': 'Page.setDownloadBehavior', 'params': {'behavior': 'allow', 'downloadPath': path}}
command_result = browser.execute("send_command", params)
*/
//m_options="--headless --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";


// This  works but the other  FAILS  
//SOMEBRO="/opt/google/chrome/chrome --headless --disable-blink-features=AutomationControlled --disable-gpu  --disable-plugins  --dump-dom  "

if ( m_chrome_with_head)
m_options=" --start-minimized  --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
else{
//m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins  --crash-dump-dir=/tmp ";
m_options="--headless --window-size=1920,1080 --enable-logging=stderr --v=1  --disable-gpu  --disable-plugins --disable-blink-features=AutomationControlled --crash-dump-dir=/tmp ";

m_options=headless_base(); 


}


// consider crap like this see if it will fake it out, 
// Input.dispatchMouseEvent #
// https://www.zenrows.com/blog/undetected-chromedriver-user-agent#rotate-user-agent
// this does nothing... these options get re-inited later doh 
// but it still does nothing on cmdline.  
const bool add_cmd_ua=!true;
if (add_cmd_ua)
{
m_options+=" --user-agent=\""+m_ua+"\" "; 
if ( !m_chrome_with_head) m_options+=" --headless=new "; 

}


m_port_option="--remote-debugging-port=";
// --user-data-dir=/home/marchywka/.config/google-chrome/ --profile-directory=Default 
m_user_dir="/tmp/";
m_user_profile="Headless";
m_use_user_creds=false;
const bool use_my_creds=m_use_user_creds; // true;
if (use_my_creds)
{
m_user_dir="/home/marchywka/.config/google-chrome/";
m_user_profile="Default";
}

m_tmp_dir="/tmp";

//m_download_path="./chromate_downloads";
m_download_path="chromate_downloads";
m_download_dir=m_tmp_dir+"/"+m_download_path;
// fucking ignored now? FUCK
//m_download_path="Downloads";
//m_download_dir="/home/marchywka/"+m_download_path;
// fucking ignored now? FUCK


//m_download_dir=m_download_path;
MakeBroCmd();

m_state=0;
m_thread=0;
m_fifo="/tmp/fifo";
Exec(StrTy("mkfifo ")+m_fifo);
//mkfifo(m_fifo.c_str(),0777);
m_id_cnt=1;
InitChromeCmds();

} // Init
// this returns everyone on the port...
// but includes crlf 
StrTy FindListener()
{
Ss ss;
// wtf is that last fking thing erh.. fck 
// udp        0      0 224.0.0.251:5353        0.0.0.0:*                           30165/chrome --enab
// tcp        0      0 127.0.0.1:9222          0.0.0.0:*               LISTEN      64401/ --profile-di 

// ss<<"( netstat -anp| grep \"127.0.0.1:"<<m_port<<"[^0-9]\" | sed -e 's/.*\\([ \\t][0-9][0-9]*\\)\\/.*/\\1/' | sed -e 's/[^0-9]//g' | grep \"[0-9]\" ";
// ss<<"( netstat -anp| grep \"127.0.0.1:"<<m_port<<"[^0-9]\" | sed -e 's/.*\\([ \\t][0-9][0-9]*\\)\\/.*/\\1/' ";
//ss<<"( netstat -anp| grep \"127.0.0.1:"<<m_port<<"[^0-9]\" | awk '{print $NF}' | sed -e 's/[^0-9]//g' ";
ss<<"( netstat -anp| grep \"127.0.0.1:"<<m_port<<"[^0-9]\" | sed -e 's/\\/.*//' |  awk '{print $NF}' | sed -e 's/[^0-9]//g' ";
ss<<" | awk '{if ($1 !=\"\") x=x\" \"$1}END{printf \"%s\", x; } ' ";
ss<<" ) ";
const StrTy cmd=ss.str(); 
const StrTy pid=Exec(cmd);
MM_ERR("listeneners pids "<< MMPR2(pid.length(),pid))
return pid;
}
// FCK
StrTy FindOthers(const IdxTy flags=0)
{
const bool kill=!Bit(flags,0);
Ss ss;
 ss<<"( ps -fww ax | grep -v grep | grep \"chrome\" | grep \"remote-debugging-port="<<m_port<<"\"";
//ss<<"( ps ax | grep \"chrome\" ";
//ss<<"ps ax | grep chrome" ;
ss<<" | awk '{print $2}' ";
ss<<" ) ";
const StrTy cmd=ss.str(); 
const StrTy pid=Exec(cmd);
MM_ERR(MMPR2(cmd,pid))
if (!false) if (kill) if (pid.length())
{
Ss rr;
rr<<" ( kill "<<pid<< " ) ";
const StrTy fck=Exec(rr.str());
MM_ERR(MMPR2(rr.str(),fck))
}
MM_ERR(__FUNCTION__<<MMPR(pid))
return pid;
} // FindOthers


void Kill()
{
Close();
if (m_state) mysleep(1);
MM_ERR(" killing wscat "<<MMPR(m_state))
m_wscat.kill();
const StrTy pid=FindListener();
MM_ERR("killing if we have a pid "<< MMPR3(m_state, pid.length(),pid))
if (pid.length())
{

Exec("kill "+pid);
} // pid 
} // Kill 


void Free()
{
Kill();
mysleep(1);
if (!m_no_clean) m_hand.clean();
MM_ERR(" done cleaning hand ")
if (m_state)
{
MM_ERR(" sigterm  killing browser "<<MMPR2(m_state,m_thread))
// probably leaking temp files.. 
// this is killing the wrong f-ing thread AFAICT... 
// the bro is still running but only one leak if left out... 
//pthread_kill(m_thread,SIGTERM);
m_thread=0;
//m_state=0;
mysleep(1);
MM_ERR(" kill issued "<<MMPR(m_state))
} // m_state
// it still won't exit if we started browsers but never attached
FindOthers();

} // Free 

Ragged ExecBroCmd(fetch_info & fi, const StrTy & nm,  const IdxTy flags=0)
{
var_type vt;
return ExecBroCmd(fi,nm,vt,flags); 
}
Ragged ExecBroCmd(fetch_info & fi, const StrTy & nm, const StrTy & v,  const IdxTy flags=0)
{
var_type vt;
vt.push_back(v);
return ExecBroCmd(fi,nm,vt,flags); 
}
Ragged ExecBroCmd(fetch_info & fi, const StrTy & nm, const StrTy & v1, const StrTy & v2,  const IdxTy flags=0)
{
var_type vt;
vt.push_back(v1);
vt.push_back(v2);
return ExecBroCmd(fi,nm,vt,flags); 
}



IdxTy AddBroCmd(const StrTy & nm , const CommandInfo & v)
{
const auto ii=m_chrome_cmds.find(nm);
if (ii!=m_chrome_cmds.end())
{
MM_ERR(" duplicate  bmd name should not happen "<<MMPR2(nm,m_chrome_cmds.size()))
return BAD;
}
m_chrome_cmds[nm]=v;
return 0;
}  // AddBroCmd

Ragged ExecBroCmd(fetch_info & fi, const StrTy & nm, const var_type & vt, const IdxTy flags)
{
const auto ii=m_chrome_cmds.find(nm);
if (ii==m_chrome_cmds.end())
{
MM_ERR(" bad bmd name should not happen "<<MMPR2(nm,m_chrome_cmds.size()))
Ragged r; Ragged::Line l; 
l.push_back(" no cmd found "); 
r.add(l);
return r;
} 
const auto &  cc=(*ii).second;
//StrTy str(const IdxTy id,const StrTy & session, const Vt & vars) const
const StrTy cmd=cc.str(m_id_cnt,m_session,vt);
MM_ERR(" cmd send "<<MMPR2(vt.size(),cmd))
if (!bro_connected())
{
MM_ERR(" bro not connected ")
 throw fi.line(__LINE__);
}
//const bool no_sleep=Bit(flags,8);
Ragged r=CmdGet(fi,cmd,flags);
if (false) if (false) if (fi.error.length()) throw fi.line(__LINE__);
return r; 
} // ExecBroCmd

void NoParam(const StrTy& nm, const StrTy& str)
{
CmdParam p;
CommandInfo cc=CommandInfo(str, p, true,true);
//m_chrome_cmds[nm]=cc;
AddBroCmd(nm,cc);
} // NoParam
template <class Tv> void OneParam(const StrTy& nm, const StrTy& str,const StrTy & k, const Tv & v, const bool includesee=true )
{
CmdParam p;
p.add(k,v);
CommandInfo cc=CommandInfo(str, p, includesee,true);
//m_chrome_cmds[nm]=cc;
AddBroCmd(nm,cc);
} // OneParam
void StringParam(const StrTy& nm, const StrTy& str,const StrTy & s,  const bool includesee=true )
{
CmdParam p;
//p.add(k,v);
CommandInfo cc=CommandInfo(str, p, includesee,true);
cc.set_string(s);
//m_chrome_cmds[nm]=cc;
AddBroCmd(nm,cc);
} // StringParam




template <class Tv,class Tv2> void TwoParam(const StrTy& nm, const StrTy& str,const StrTy & k, const Tv & v, const StrTy & k2, const Tv2& v2, const bool includesee=true )
{
CmdParam p;
p.add(k,v);
p.add(k2,v2);
CommandInfo cc=CommandInfo(str, p, includesee,true);
//m_chrome_cmds[nm]=cc;
AddBroCmd(nm,cc);
} // TwoParam


template <class Tv,class Tv2,class Tv3> void ThreeParam(const StrTy& nm, const StrTy& str,const StrTy & k, const Tv & v, 
const StrTy & k2, const Tv2& v2, 
const StrTy & k3, const Tv3& v3, 
const bool includesee=true )
{
CmdParam p;
p.add(k,v);
p.add(k2,v2);
p.add(k3,v3);
CommandInfo cc=CommandInfo(str, p, includesee,true);
//m_chrome_cmds[nm]=cc;
AddBroCmd(nm,cc);
} // TwoParam



 void MissingHeaders(const StrTy& nm )
{
/*
sec-ch-ua: "Google Chrome";v="113", "Chromium";v="113", "Not-A.Brand";v="24"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Linux"
StrTy hdrs=
StrTy("\"headers\":") +StrTy("{") +StrTy("\"sec-ch-ua\"")
+StrTy(":\"\\\"Google Chrome\\\";v=\\\"113\\\", \\\"Chromium\\\";v=\\\"113\\\", \\\"Not-A.Brand\\\";v=\\\"24\\\"\"")
+StrTy(",") +StrTy("\"sec-ch-ua-mobile\"") +StrTy(":\"?0\"") +StrTy(",")
+StrTy("\"sec-ch-ua-platform\"") +StrTy(":\"\\\"Linux\\\"\"") +StrTy("}")
;
//StrTy nacmd1=spfx+"Network.setExtraHTTPHeaders\",\"params\":{"+hdrs+"},\"id\":";
//Ragged rq=CmdGet(fi,IdAdd(nacmd1),flags);

*/
CmdParam v;
//sec-ch-ua: "Not;A=Brand";v="99", "Google Chrome";v="139", "Chromium";v="139"
//v.add("sec-ch-ua",StrTy("\"Google Chrome\";v=\"113\", \"Chromium\";v=\"113\", \"Not-A.Brand\";v=\"24\""));
// needs to match ua string
v.add("sec-ch-ua",StrTy("\"Google Chrome\";v=\"139\", \"Chromium\";v=\"139\", \"Not-A.Brand\";v=\"99\""));
v.add("sec-ch-ua-mobile",StrTy("\"?0\""));
v.add("sec-ch-ua-platform",StrTy("\"Linux\""));
const bool refer_policy_ok=false;
if (refer_policy_ok) 
	v.add("Referer",StrTy("https://www.google.com/search?q=referer+header&ie=UTF-8"));
CmdParam p;
p.add("headers",v);
CommandInfo cc=CommandInfo("Network.setExtraHTTPHeaders", p, true,true);
//m_chrome_cmds[nm]=cc;
AddBroCmd(nm,cc);
} // MissingHeaders 



void InitChromeCmds()
{

//StrTy u="Page.printToPDF\"";
//StrTy cmd=FinishBroCmd(u,3);
//Ragged r=CmdGet(fi,cmd,flags);
//if (fi.error.length()) throw fi.line(__LINE__);
//CommandInfo(const StrTy & nm, const CmdParam p, const bool s,const bool aid) 
//{
//CmdParam p;
//CommandInfo cc=CommandInfo("Page.printToPDF", p, true,true);
//m_chrome_cmds["print_pdf"]=cc;
//}
//StrTy u="Page.reload\"";
NoParam("reload","Page.reload");
NoParam("print_pdf","Page.printToPDF");
NoParam("get_document","DOM.getDocument");

NoParam("disable_debugger","Debugger.disable");
NoParam("enable_debugger","Debugger.enable");
NoParam("get_targets","Target.getTargets");
NoParam("get_frametree","Page.getFrameTree");
NoParam("close_browser","Browser.close");


NoParam("enable_network","Network.enable");
NoParam("begin_frame","HeadlessExperimental.beginFrame");
NoParam("enable_animation","Animation.enable");

 MissingHeaders("missing_headers" );

{
CmdParam p;
p.add("type",StrTy("mouseMoved"));
p.add("x",StrTy("#1."));
p.add("y",StrTy("#2."));
CommandInfo cc=CommandInfo("Input.dispatchMouseEvent", p, true,true);
//m_chrome_cmds["mouse_moved"]=cc;
AddBroCmd("mouse_moved",cc);
}

StringParam("refpol","Page.ReferrerPolicy","unsafeUrl");
NoParam("get_outer","DOM.getOuterHTML");
OneParam("get_outer_node","DOM.getOuterHTML","nodeId",StrTy("#1."));
OneParam("get_outer_one","DOM.getOuterHTML","nodeId",1U);
OneParam("get_outer_back","DOM.getOuterHTML","backendNodeId",StrTy("#1."));
OneParam("get_outer_obj","DOM.getOuterHTML","objectId",StrTy("#1"));

OneParam("create_target","Target.createTarget","url",StrTy(""));

// probably does not exist
OneParam("enable_frame_control","Emulation.setBeginFrameControlEnabled","enabled",true);
OneParam("navigate","Page.navigate","url",StrTy("#1"));
//TwoParam("navigateref","Page.navigate","url",StrTy("#1"),"referrer",StrTy("#2"));
ThreeParam("navigateref","Page.navigate","url",StrTy("#1"),"referrer",StrTy("#2"),"referrerPolicy",StrTy("unsafeUrl"));

TwoParam("attach","Target.attachToTarget","targetId",StrTy("#1"),"flatten",true,false);

OneParam("ua","Emulation.setUserAgentOverride","userAgent",StrTy("#1"));
OneParam("uanet","Network.setUserAgentOverride","userAgent",StrTy("#1"));
// webViewInternal.overrideUserAgent - from strings on chrome executable lol 
OneParam("uaweb","webViewInternal.overrideUserAgent","userAgent",StrTy("#1"));

OneParam("navigator_override","Emulation.setNavigatorOverrides","platform",StrTy("__proto__"));
OneParam("delete_window","Runtime.evaluate","expression",StrTy("delete window.navigator.webdriver"));

OneParam("evaluate","Runtime.evaluate","expression",StrTy("#1"));

OneParam("discover_targets","Target.setDiscoverTargets","discover",true);

OneParam("enable_scripts","Emulation.setScriptExecutionDisabled","value",false);
OneParam("enable_focus","Emulation.setFocusEmulationEnabled","enabled",true);

OneParam("get_response","Network.getResponseBody","requestId",StrTy("#1"));


} // InitChromeCmds

// MEMBERS
volatile bool m_threw;
ChromeCmdMap m_chrome_cmds;
IdxTy m_mode;
Hand m_hand;
JsonTy m_json;
IdxTy m_port;
StrTy m_fifo;
StrTy m_bro_name, m_options,m_port_option,m_user_dir,m_user_profile;
StrTy m_bro;
StrTy m_ua,m_current_ua;
StrTy m_url;
StrTy m_download_path,m_tmp_dir,m_download_dir;
ThreadId m_thread;
volatile IdxTy m_state;
WsCat m_wscat;
int m_id_cnt;
bool m_use_user_creds;
bool  m_chrome_with_head; 
bool  m_use_script_as_backup; 
bool m_use_ref;
bool m_no_clean;
StrTy m_target,m_session;
}; // mjm_chromate

//////////////////////////////////////////////

template <class Tr>
class mjm_chromate_map : public std::map<typename Tr::StrTy, mjm_chromate< Tr > >  
{
 typedef mjm_chromate_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_chromate< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_chromate_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_chromate_map




////////////////////////////////////////////
#ifdef  TEST_MJM_CHROMATE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_chromate <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_CHROMATE "<<__DATE__<<" "<<__TIME__<<CRLF;
ss<<" MJM_CHROMATE "<<"manipulate browser may use "<<CRLF;
ss<<" MJM_CHROMATE "<<"wscat and rapidjson "<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_chromate<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") { x.done();  break; } 
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }
else if (cmd=="bro") { x.launch(); }
//IdxTy use_user(const StrTy & u, const IdxTy flags=0)
else if (cmd=="mode") { x.use_user("",atoi(cip.p1.c_str())); }
else if (cmd=="launch") { x.launch(); }
else if (cmd=="preserve") { mjm_global_flags::mm_delete_temps=!true; }
// great so where does it put it? Only zzzz
else if (cmd=="fetch") { x.fetch(cip.p1,0); }
else if (cmd=="save") { x.save(cip.p1,cip.p2,0); }
// fn,url
else if (cmd=="download") { x.download(cip.p1,cip.p2,0); }
// file, url
else if (cmd=="wget") { x.download(cip.p1,cip.p2,1); }
else if (cmd=="close") { x.close(); }
else if (cmd=="pdf") { x.print_page(cip.p1,cip.p2,0); }
else if (cmd=="cmd") { x.bro_cmd(cip.p1,atoi(cip.p2.c_str())); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_CHROMATE_H__ 
