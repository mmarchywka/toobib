#ifndef MJM_BIBTEX_MOTIF_H__
#define MJM_BIBTEX_MOTIF_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"


// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"

// #include "mjm_bibtex_motif.h"
#include "mjm_temp_progress.h"
#include "mjm_partial_cache.h"
#include "mjm_bibtex_features.h"
#include "mjm_blob.h"
#include "mjm_read_buffer.h"
#include "mjm_misc_parse.h"
#include "mjm_bibtex_entry.h"
#include "mjm_bibtex_parse.h"
// instead of pawnoff
#include "mjm_ext_things.h"
#include "mjm_collections.h"
#include "mjm_generic_iterators.h"
#include "mjm_read_buffer.h"
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Dec  5 15:08:31 EST 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibtex_motif   
// g++ -std=gnu++11 -DTEST_MJM_BIBTEX_MOTIF -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibtex_motif.h  -lpthread -lreadline

template <class Tr>
class mjm_bibtex_motif 
{
 typedef mjm_bibtex_motif Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef char Ch;
typedef std::vector<StrTy> Vec;

typedef mjm_read_buffer<Tr> RdBuf;
typedef mjm_ext_things<Tr> ExtThings;
typedef mjm_bibtex_features<Tr> Features;
typedef typename Features::parse_map Pmap; // pmap;
//typedef std::map<StrTy, StrTy> Pmap;
typedef std::map<StrTy, IdxTy> Imap;
typedef mjm_partial_cache<Tr> ProgCache;
typedef mjm_ragged_table Ragged;
typedef mjm_blob<Tr> Blob;
typedef std::map<StrTy, Blob> BlobMap;

//template <class Key, class Value,int Zero=0>
//class mjm_vector_map_iter
#if 0 
#endif

//typedef temp_progress TempProg;
typedef mjm_temp_progress<Tr> TempProg;
typedef typename  TempProg::bib_map BibMap;
typedef typename  TempProg::bib_vector BibVector;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;
typedef std::regex Regex;
#define HANDLER(x) static IdxTy x(Myt * mytp, TempProg & p, const IdxTy flags )
// avoid use of member functions for generality , parent can be null 
typedef IdxTy (*Guess)(Myt * mytp, TempProg & p, const IdxTy flags); 
class guess_domain
{

public:
guess_domain() : m_domain(0),m_dlen(0),m_guess(0),m_is_regex(false) {}
guess_domain(const Ch * d, const Guess & g) 
: m_domain(d),m_dlen(strlen(d)),m_guess(g), m_is_regex(false) {Init();}
// this defers checking so just get all that apply
guess_domain(const Ch * d, const Guess & g, const bool r) 
: m_domain(d),m_dlen(strlen(d)),m_guess(g), m_is_regex(r) {Init();}
// this defers checking so just get all that apply
bool try_domain(Myt * mytp, const Ch * s,const IdxTy slen,TempProg & prog, const IdxTy flags) const { 
if (!applies(s,slen) ) return false;
m_guess(mytp,prog,flags);

return true; 
}
bool applies(const Ch * s,const IdxTy slen) const { 
if (m_is_regex)
{
return mjm_cpp_regex::stuff::has(s,m_r,0);
}
const IdxTy loc=domain_grep(m_domain,m_dlen,s,slen);
if ( loc!=bad()) { MM_ERR(MMPR4(s,slen,m_domain,loc)) } 
return bad()!=loc;

}
static IdxTy bad() { return ~0; } 
// copied from "mjm_bibtex_features.h"  better off with instance or regex? 
IdxTy domain_grep(const char * p, const IdxTy sz, const IdxTy first, const char * s)
{
const IdxTy slen=strlen(s);
for (IdxTy i=first; i<sz; ++i)
{
if (strncmp(p+i,s,slen)==0) return i;
}
return bad();
}

IdxTy domain_grep(const char * p, const IdxTy plen,  const char * s,const IdxTy slen ) const
{
return DomainGrep(p,plen,s,slen); 
}
private:
IdxTy DomainGrep(const char * p, const IdxTy plen,  const char * s,const IdxTy slen ) const
{
IdxTy i=0;
IdxTy j=0;
if (plen<slen) return bad();
IdxTy lim=plen-slen;
for(; i<lim; ++i ) {
//while (true)
//{
// matching zero len does not matter... 
// this really can terminate strlen(s) earlier... 
//if (p[i]==0) break;
//if (i>=(plen-slen)) break;
IdxTy k=0;
while ( p[i+k]==s[k]) {
// these could both ==0 only if i==(lim)
//if (s[k]==0) return i; // the end is here. 
  ++k; }  
//if (s[k]==0) return i; // the end is here. 
if (k==slen) return i; // the end is here. 
}
for(IdxTy k=0; k<slen; ++k) 
{
if (p[i+k]!=s[k]) return bad();
}


return lim;
//return bad();
}
void Init()
{
if (m_is_regex) m_r = Regex(m_domain);

}
// could go to compiled regexZZ
const char * m_domain;
IdxTy m_dlen;
Guess m_guess;
Regex m_r;
bool m_is_regex;

}; // guess_domain
typedef guess_domain GuessDomain;

typedef std::vector<GuessDomain> GdVec;

//typedef 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_motif() {Init(); }
~mjm_bibtex_motif() {}


IdxTy check(TempProg & prog,const IdxTy flags=0) { return Check(prog,flags); } 
IdxTy check_domains(TempProg & prog,const IdxTy flags=0) { return CheckDomains(prog,flags); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }


private:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

/*
handlers="handlecitmgr"
handlers="$handlers handlespring"
handlers="$handlers handledowncit"
handlers="$handlers handlehighwire"
handlers="$handlers handledoi"
handlers="$handlers handlebibxml"
handlers="$handlers handledoixml"
handlers="$handlers handlepdf"
handlers="$handlers handlegsmeta"
*/




IdxTy Check(TempProg & prog, const IdxTy flags) { 

CheckHighwire(prog);
CheckBibLink( prog);



return 0; 
} 
/*



handlehighwire()
{
fn="$1"
uin="$3"
canhandle=`cat  "$fn" | sed -e 's/"/\n/g' | grep highwire | grep bibtex`
debugstrat handlehighwire with $fn and $uin greps for $canhandle
#echo highwite $canhandle
#http://rsta.royalsocietypublishing.org/content/342/1664/225.short
# cat  xxx | sed -e 's/"/\n/g' | grep highwire | grep bibtex
#/highwire/citation/10397/bibtex
if [ "$canhandle" != "" ]
then
base=`echo $uin | isolatedomain`
url="$base/$canhandle"
echo found something for $2  | smsg
# this is failing due to https redit
#lynx -source -dump "$url" > "$fn"

rm "$temp5"
if [ "$DEBUGFLAG" != "" ]
then
$WGET --no-check-certificate -O "$temp5" -S -v "$url"
else
$WGET --no-check-certificate -O "$temp5" -q "$url"
fi

citepastecat  "$temp5" "$uin" "$url" "$2"
handled=1
fi

}
*/

IdxTy CheckHighwire(TempProg & prog)
{
const StrTy nm="handlehighwire";
const bool debug_flag=true;
Blob & page = prog.page();
StrTy url=prog.url();
// the bash script uses a very simple slash based thing for domain only... 
Pmap pmap;
IdxTy rc=m_f.parse_url(pmap,url);
if (rc==0) { MM_LOOP(ii,pmap) { MM_ERR(MMPR2((*ii).first, (*ii).second)) }  } 
else { MM_ERR(" url apparently not valid") } 
Blob t,t2;
// this is probably safer than using the html parser can pickup js etc. 
m_ext.sed(t,page," -e 's/\"/\\n/g' ");
m_ext.grep(t2,t,"highwire");
t.clear();
m_ext.grep(t,t2,"bibtex");
// if there is anything left it is the url of the bibtex.. 
if ( t.size()!=0)
{
prog.add_suspect(nm,t,0);
// thing is either a doi or url, url used to be uin in the med2bib script  
// the flags could indicate doi, dos2unix, htmldecode, etc 
// flags : 0 - is_url_not_doi , 1 - skip analyze test results
//void GetAndTest(BibMap & bm, const StrTy & handler, const StrTy & url, const StrTy & thing, const IdxTy flags)

}
//m_ext.get_url(m_prog.page(),url,debug_flag?2:0);

return 0; 
} 

/*
# google books does this 
handlebiblink()
{
nm=handlebiblink
echo trying $nm $2 | smsg
fn="$1"
uin="$3"
fn2="$temp5"
fn3="$temp6"
biblinks=`cat "$fn" | sed -e 's/"/\n/g' | grep bibtex| htmldecode`
echo found `echo $biblinks | wc ` | smsg
biblinks=`cat "$fn" | sed -e 's/"/\n/g' | grep bibtex| head -n 1 | htmldecode `
rm "$fn3"
echo trying $biblinks | smsg
for f in $biblinks ; do
normalget "$fn2" "$f"
citepastecat  "$fn2" "$uin" "$f" "$2" >> "$fn3"
done
#canhandle=`cat  "$fn" | sed -e 's/"/\n/g' | grep highwire | grep bibtex`
if [ "$handled" != "" ]
then
cat "$fn3"
fi
#handled=1
}

*/
// this should be done after alt link usrs
IdxTy CheckBibLink(TempProg & prog)
{
const StrTy nm="handlebiblink";
const bool debug_flag=true;
Blob & page = prog.page();
StrTy url=prog.url();
// the bash script uses a very simple slash based thing for domain only... 
//biblinks=`cat "$fn" | sed -e 's/"/\n/g' | grep bibtex| htmldecode`
Blob t,t2;
// this is probably safer than using the html parser can pickup js etc. 
m_ext.sed(t2,page," -e 's/\"/\\n/g' | grep bibtex | htmldecode|wc ");
// these may be relative links 
m_ext.sed(t,page," -e 's/\"/\\n/g' | grep bibtex | htmldecode ");
MM_ERR(" found "<<nm<<MMPR(StrTy(t)))
//m_ext.grep(t2,t,"highwire");
//t.clear();
//m_ext.grep(t,t2,"bibtex");
// if there is anything left it is the url of the bibtex.. 
if ( t.size()!=0)
{
// this really needs to split multiples... 
prog.add_suspect(nm,t,0);
}
return 0;
}





IdxTy CheckDomains(TempProg & prog, const IdxTy flags)
{
const bool debug_flag=Bit(flags,0);
//Blob & page = prog.page();
StrTy url=prog.url();
const Ch * curl=url.c_str();
const IdxTy clen=strlen(curl);
// the bash script uses a very simple slash based thing for domain only... 
Pmap pmap;
IdxTy rc=m_f.parse_url(pmap,url);
// this just needs to be done once ... 
if (rc==0) { MM_LOOP(ii,pmap) { MM_ERR(MMPR2((*ii).first, (*ii).second)) }  } 
else { MM_ERR(" url not valid") } 

const StrTy & domain=pmap["domain"];
MM_LOOP(ii,m_gdv)
{
// could break on true but do not know if this one worked or not. 
(*ii).try_domain(this,curl,clen,prog,flags);
//bool try_domain(Myt * mytp, const Ch * p,TempProg & prog, const IdxTy flags) const { 
}



return 0; 
}

/*
// fast exact finder find "s" in "p" 
IdxTy ExactGrepLoc(const char * p, const IdxTy sz, const IdxTy first, const char * s)
{
const IdxTy slen=strlen(s);
for (IdxTy i=first; i<sz; ++i)
{
if (strncmp(p+i,s,slen)==0) return i;
}
return ~0;
}

*/


bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
void LoadDefaultGdV()
{

//typedef IdxTy (*Guess)(Myt * mytp, TempProg & p, const IdxTy flags); 
m_gdv.push_back(GuessDomain("",&Myt::NullGuess));
LoadGdV();


}
#include "mjm_bibtex_domains.h"
//IdxTy NullGuess(Myt * mytp, TempProg & p, const IdxTy flags )
HANDLER(NullGuess)
{

return 0;
}
#undef HANDLER
void Init()
{
LoadDefaultGdV();


}

ExtThings m_ext;
Features m_f;
RdBuf m_scratch,m_scratch2;
GdVec m_gdv;



}; // mjm_bibtex_motif

//////////////////////////////////////////////

template <class Tr>
class mjm_bibtex_motif_map : public std::map<typename Tr::StrTy, mjm_bibtex_motif< Tr > >  
{
 typedef mjm_bibtex_motif_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bibtex_motif< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_motif_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bibtex_motif_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIBTEX_MOTIF
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIBTEX_MOTIF "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bibtex_motif<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIBTEX_MOTIF_H__ 
