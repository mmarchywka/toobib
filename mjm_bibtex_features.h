#ifndef MJM_BIBTEX_FEATURES_H__
#define MJM_BIBTEX_FEATURES_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_cpp_regex.h"
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_misc_parse.h" 
#include "mjm_read_buffer.h" 

// Tue Nov 19 07:59:36 EST 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibtex_features   
// g++ -std=gnu++11 -DTEST_MJM_BIBTEX_FEATURES -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibtex_features.h  -lpthread -lreadline

template <class Tr>
class mjm_bibtex_features 
{
 typedef mjm_bibtex_features Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef std::vector<StrTy> Vec;
typedef char Ch;
typedef IdxTy ChCast;
typedef IdxTy Iv;
typedef mjm_var_parse<Tr,Ch,Iv> ParseTable;
typedef mjm_read_buffer<Tr> RdBuf;
typedef std::map<StrTy,StrTy> Pmap;

// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_features() {Init();}
~mjm_bibtex_features() {}
enum { BAD=~0 };
typedef Pmap parse_map;
static IdxTy bad()  { return BAD; } 

int find_doi(IdxTy & start, IdxTy & end, const Ch * p, const IdxTy s,const IdxTy flags=0)
{ return FindDOI(start,end,p,s,flags); } 

IdxTy parse_url(Pmap & m, const StrTy & s) { return  ParseURL( m, s); } 
void to_eol( Vec & v, const StrTy & pattern, const StrTy & src)
{ ToEol(v,pattern,src); }
IdxTy exact_grep_loc(const char * p, const IdxTy sz, const IdxTy first, const char * s)
{ return ExactGrepLoc(p,sz,first,s); }
private:

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
void Init()
{

// canhandle=`echo $uin | sed -e 's/.*\(\/10\.[0-9][0-9]*\/[^;&?#]*\).*/\1/' 
m_lut=m_pt.lut();
m_lutu=m_ptu.lut();
m_ubit=m_pt.ubit();
m_ubit2=m_pt.ubit();
//m_pt.set(1<<m_ubit,"^;&?#<>\'\"");
m_pt.set(1<<m_ubit2,"./-");

}

// fast exact finder find "s" in "p" 
IdxTy ExactGrepLoc(const char * p, const IdxTy sz, const IdxTy first, const char * s)
{
const IdxTy slen=strlen(s);
for (IdxTy i=first; i<sz; ++i)
{
if (strncmp(p+i,s,slen)==0) return i;
}
return ~0;
}


void ToEol( Vec & v, const StrTy & pattern, const StrTy & src)
{
//MM_ERR(" looking for "<<pattern<<" in doc of size "<<src.size())
// this now picks up zero is an EOL fwiw 
const  Iv mask=ParseTable::EOL;
const Ch * p=src.c_str();
const Ch * q=p;
const Ch * r=pattern.c_str();
const IdxTy sz=pattern.length();
//IdxTy i=0;

while ((*q)!=0)
{
IdxTy j=0;
// both are valid for j==0, if chars differ the thing stops at a valid point
while ( q[j]==r[j])
{
++j;
if (j==sz) 
{
// it is faster to do this on the stack probably as length is known 
m_scratch.clear();
IdxTy k=0;
while (true) { 
const unsigned char  c=q[k+j];
//MM_ERR(MMPR2(c,k))
if (!Mask(m_lut[ChCast(c)],mask)) {m_scratch.append(c); }
else { m_scratch.cap(); v.push_back(m_scratch.string());  break;}
++k; }

q+=k+j;
break;
} // j==sz 
} //j 
//++i;
++q;
}
return; 
}

// p[i] is invalid 
// canhandle=`echo $uin | sed -e 's/.*\(\/10\.[0-9][0-9]*\/[^;&?#]*\).*/\1/' 

int FindDOI(IdxTy & start, IdxTy & end, const Ch * p, const IdxTy s, const IdxTy flags)
{
IdxTy i=s;
IdxTy state=BAD;
const Iv mask=ParseTable::ALPHANUM;
const Iv mask2=ParseTable::ALPHANUM|(1<<m_ubit2);
//MM_ERR(MMPR4(start,end,p+s,s))
while (p[i]!=0)
{
const ChCast c= ( unsigned char)  ( p[i]) ;
//MM_ERR(MMPR3(i,Ch(c),int(state)))
switch (state)
{
case  BAD : { if (c=='1'){start=i;  state=1;}  break; }  
// allow leading junk 
case 1 :{ if (c=='0'){ state=2; break;} if (c=='1'){ start=i;  state=1;}  break;  }  
case 2 :{ if (c=='.'){ state=3; break;} if (c=='1'){start=i; state=1;break;  }state=BAD;  break;  }  
case 3 :{ if (c=='/'){ state=0; break;} if (!Mask(m_lut[c],mask)) state=BAD; break;  }  
case 0 :{ if (!Mask(m_lut[c],mask2)) { end=i; if (i>s) if ( p[i-1]=='.') end=i-1;  return state; }  break;  }  


} ; // switch 
++i;
} // i 
end=i;
return state;
}

IdxTy ParseURL(Pmap & m, const StrTy & s)
{
bool invalid=false;
const Iv INVMASK= ParseTable::PRINT;
const Iv INVMASK2= ParseTable::WHITE;
m_scratch.clear();
m_scratch.append(s);
const IdxTy len=m_scratch.size();
m_scratch.cap();

m_scratch2.clear();
IdxTy i=0;
//IdxTy fp=BAD; IdxTy lp=BAD; IdxTy pp=BAD; IdxTy frp=BAD; IdxTy state=BAD;
typedef std::vector<IdxTy> Lo;
Lo slashes,dots,qu,frag,col;
//const Ch * p=s.c_str();
Ch * p=m_scratch.ptr();
//while ( p[i]!=0)
for(i=0; i<len; ++i)
{
const unsigned char c=p[i];
if (!Mask(m_lut[c],INVMASK)) invalid=true;
if (Mask(m_lut[c],INVMASK2)) invalid=true;
Iv cc=m_lutu[ChCast(c)];
if ((cc&ParseTable::PUNC)==0) continue;
if (c=='/') slashes.push_back(i);
else if (c=='.') dots.push_back(i);
else if (c=='?') qu.push_back(i);
else if (c=='#') frag.push_back(i);
else if (c==':') col.push_back(i);
//++i;
}
// domain is from /[1] to min(:[1],/[2],?[0],#[0] )

bool have_protocol=!true;
// protocol is leading junk to ://
if ((col.size()>0)&&(slashes.size()>1))
{
IdxTy s1=col[0];
if ((slashes[0]=(s1+1))&&(slashes[1]==(s1+2)))
{
p[s1]=0;
m["protocol"]=p;
have_protocol=true;
} // protocol
}
IdxTy f=have_protocol?(slashes[1]+1):0;
IdxTy ed=len;
if (have_protocol)
{
if (slashes.size()>2) ed=slashes[2];
if (col.size()>1) if (col[1]<ed) ed=col[1];
if (qu.size()>0) if (qu[0]<ed) ed=qu[0];
if (frag.size()>0) if (frag[0]<ed) ed=frag[0];
}
else
{
if (slashes.size()>0) ed=slashes[0];
if (col.size()>0) if (col[0]<ed) ed=col[0];
if (qu.size()>0) if (qu[0]<ed) ed=qu[0];
if (frag.size()>0) if (frag[0]<ed) ed=frag[0];
}
p[ed]=0;

m["domain"]=p+f;
m["host"]=p+f;
// this is the first part of the path
f=have_protocol?2:0;
if (slashes.size()>f){  f=1+slashes[f];
IdxTy lp=slashes[slashes.size()-1];
if (lp>f) p[lp]=0;
m["path"]=p+f;
} // path
//ed=have_protocol?2:0;
if (slashes.size()>0)
{
IdxTy lp=slashes[slashes.size()-1];
f=lp+1;
ed=len;
if (qu.size()>0) if (qu[0]<ed) ed=qu[0];
if (frag.size()>0) if (frag[0]<ed) ed=frag[0];
p[ed]=0;
m["file"]=p+f;
}

//}
const bool do_dump=!invalid;
if (do_dump) { MM_LOOP(ii,m){ MM_ERR(MMPR2((*ii).first,(*ii).second)) }  } 

return invalid?~0:0; // state;

}




bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
bool Mask(const IdxTy f, const IdxTy m) const  { return  (f&m)!=0; }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }

ParseTable m_pt,m_ptu;
const Iv  * m_lut,*m_lutu;
IdxTy m_ubit,m_ubit2;
RdBuf m_scratch, m_scratch2;

}; // mjm_bibtex_features

//////////////////////////////////////////////

template <class Tr>
class mjm_bibtex_features_map : public std::map<typename Tr::StrTy, mjm_bibtex_features< Tr > >  
{
 typedef mjm_bibtex_features_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bibtex_features< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_features_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bibtex_features_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIBTEX_FEATURES
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIBTEX_FEATURES "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bibtex_features<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIBTEX_FEATURES_H__ 
