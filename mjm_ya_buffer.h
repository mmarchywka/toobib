#ifndef MJM_YA_BUFFER_H__
#define MJM_YA_BUFFER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

//#include "mjm_canned_methods.h"
//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
//#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2025 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Talking Rock GA 30175 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_ya_buffer.h},
  url = {},
  version = {0.0.0},
  date-started={2025-04-03},
}
*/

// Thu 03 Apr 2025 02:09:40 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ya_buffer   
// QUICKCOMPILE  g++  -MMD -MF mjm_ya_buffer.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_YA_BUFFER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ya_buffer.h  -o mjm_ya_buffer.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_ya_buffer("mjm_ya_buffer" , "  ");

template <class Tr>
class mjm_ya_buffer 
{
 typedef mjm_ya_buffer Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
//typedef mjm_ragged_table Ragged;
//typedef Ragged::Line Line;
//typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef char Data;

// API

public:
mjm_ya_buffer() {Init(); }
mjm_ya_buffer(const Myt & that ) {*this=that;}
mjm_ya_buffer(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
template <class Ragged> 
mjm_ya_buffer(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
template <class Ragged> 
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

StrTy xxx_test(const StrTy & sin, const IdxTy flags) 
{ return XXX_test(sin,flags); } 
~mjm_ya_buffer() {if (m_dump_on_exit) { MM_ERR(MMPR(dump())) } delete[] m_tgt; }
void no_dump_on_exit() { m_dump_on_exit=false; } 
StrTy dump(const IdxTy flags=0)const  { return Dump(flags); }
IdxTy size() const { return m_sz; }
void size(const IdxTy sz  )  { 
EnterSerial(0);
delete [] m_tgt;
m_rd_ptr=0;
m_wr_ptr=0;
m_tgt= new Data[sz];
m_sz=sz;
ExitSerial(0);
 }
IdxTy space() const {  // MM_ERR(" AFICK "<<MMPR2(m_sz,available()))  
IdxTy a=available();
//if (a==m_sz) return 0; 
return m_sz-a-1*0; } 
bool empty() const { return (m_wr_ptr==m_rd_ptr)&&!m_full; } 
IdxTy available() const  {

EnterSerial(0);
if (m_full) { ExitSerial(0);   return m_sz; } 
 const IdxTy n = Available(); 
ExitSerial(0);
 return n; }

void lock() { EnterSerial(0); }
void release() { ExitSerial(0); }

bool put(const Data c )
{
if (!Space()) return false;
m_tgt[m_wr_ptr]=c;
m_wr_ptr=(m_wr_ptr+1)%m_sz;
m_full= (m_wr_ptr==m_rd_ptr); //  m_full=true;
return true;
}
// not mutex protected.... 
void clear() { m_wr_ptr=0; m_rd_ptr=0; m_full=false; } 

bool get_from_stream(IsTy * is)
{
const IdxTy s=contig_write();
is->read(m_tgt+m_wr_ptr,s);
IdxTy n=is->gcount();
m_wr_ptr=(m_wr_ptr+n) % m_sz; 
if (n) if (m_wr_ptr==m_rd_ptr) m_full=true;
//MM_ERR(MMPR(m_full))
return is->eof();
} // get_from_stream;


IdxTy write(const Data * p, const IdxTy sz,const IdxTy flags )
{
// FIXME make these reentrant lol. 
const bool get_lock=!Bit(flags,0);
if (get_lock) EnterSerial(0);
IdxTy n=m_sz-Available();
if (n<sz) return 0; 
IdxTy top=m_sz-m_wr_ptr;
if (sz<n) n=sz;
if (top>=n) { memcpy( m_tgt+m_wr_ptr, p,n) ; m_wr_ptr=(m_wr_ptr+n) % m_sz; }
else
{
 memcpy( m_tgt+m_wr_ptr, p,top) ; 
 memcpy( m_tgt, p+top,n-top) ; 
m_wr_ptr=(m_wr_ptr+n) % m_sz; 

}
if (sz) m_full= (m_wr_ptr==m_rd_ptr); //  m_full=true;
const IdxTy nowav = Available(); 
if (nowav>m_max) m_max=nowav;
if (get_lock) ExitSerial(0);
return n;
} // write 
// no start char need to be able to toss first read lol. 
IdxTy write_line(const StrTy & s, const char ceox) 
{ return write_thing(s,'\r'); }
IdxTy write_blob(const StrTy & s, const char ceox) 
{ return write_thing(s,26); }
// FIXME need an better flow exception etc handler... 
template <class Ragged> IdxTy write_ragged(const Ragged &r, const IdxTy flags)
{
const bool serials=Bit(flags,0);
const bool block=Bit(flags,1);
Ss ss; ss<r.dump_ssv_unsafe(); // could include serial numbes but not worth it now... 
IdxTy len=ss.str().length();
IdxTy n=write_thing(ss.str(),26);
return n;
} // write_ragged
IdxTy write_thing(const StrTy & s, const char ceox)
{
IdxTy rc=0;
const IdxTy sz=s.length();
Myt & q=(*this); // m_que();
while (q.available()<(sz+1)) 
{
return 0;
} // while 
q.lock();
rc=q.write(s.c_str(),sz,1);
q.put(ceox); ++rc;
q.release();
return rc;
} // write_line
// keep overwriting old data useful to monitroing etc
// only useful for fixed length samples with buffer multiple of
// that size ... doh 
// TODO text this lol 
IdxTy write_string(const StrTy & s, const IdxTy flags=0)
{
const bool write_zed=!Bit(flags,0);
const IdxTy del=write_zed?1:0;
const IdxTy n=s.length()+del;
const IdxTy nsent=write_wrap(s.c_str(),n,0);
return n-nsent;
} // write_string

IdxTy write_wrap(const Data * p, const IdxTy sz,const IdxTy flags )
{
EnterSerial(0);
IdxTy n=(sz>m_sz)?m_sz:sz;
IdxTy space=Space();
IdxTy pzed=0;
// only write the last par of buffer if too big
if (n!=sz) pzed=sz-n;
//IdxTy n=m_sz-Available();
IdxTy top=m_sz-m_wr_ptr;
//if (sz<n) n=sz;
if (top>=n) { memcpy( m_tgt+m_wr_ptr, p+pzed,n) ; m_wr_ptr=(m_wr_ptr+n) % m_sz; }
else
{
 memcpy( m_tgt+m_wr_ptr, p+pzed,top) ; 
 memcpy( m_tgt, p+top+pzed,n-top) ; 
m_wr_ptr=(m_wr_ptr+n) % m_sz; 

}
if (n>space) m_rd_ptr=m_wr_ptr; 
m_full= (m_wr_ptr==m_rd_ptr); //  m_full=true;
const IdxTy nowav = Available(); 
ExitSerial(0);
if (nowav>m_max) m_max=nowav;
return n;
} // write_wrap

IdxTy read_to(const OsTy & os, const char ceox)
{
IdxTy rc=0;
if (empty()) return rc;  
lock();
IdxTy p=m_rd_ptr;
IdxTy ssz=0;
// full is ok to handle now... 
do
{
// do not include in the thing but do drop it... 
if (m_tgt[p]==ceox)
{
Data * d=0; IdxTy c1=0;
contig(d,c1);
if (c1>ssz) c1=ssz;
os.write(d,c1);
take(c1);
ssz-=c1;
if (ssz) { contig(d,c1);  if ( c1>ssz) c1=ssz; write(d,c1); take(c1); }
take(1); // get the eof char... 
release(); 
return rc;
}
++ssz;
inc(p,1);
} while ( p!=m_wr_ptr );

release();
return rc;
} // read_to
IdxTy contig_write()
{
IdxTy sz=m_sz-m_wr_ptr;
if (m_rd_ptr>m_wr_ptr) sz=m_rd_ptr-m_wr_ptr;
if (m_rd_ptr==m_wr_ptr) 
{ if (m_full) return 0; return m_sz;  }
return sz;
}
void contig(const Data*& p, IdxTy &sz)
{
p=m_tgt+m_rd_ptr;
if (m_wr_ptr==m_rd_ptr)
{
if (!m_full) sz=0;
else sz=m_sz-m_rd_ptr;
}
else if (m_wr_ptr<m_rd_ptr) sz=m_sz-m_rd_ptr;
else sz=m_wr_ptr-m_rd_ptr;

} // contig

void inc(volatile IdxTy & p,const IdxTy n ) const { p=(p+n)%m_sz; } 
void take( const IdxTy n) { inc(m_rd_ptr,n); //  m_rd_ptr=(m_rd_ptr+n) % m_sz;
//MM_ERR(MMPR4(m_rd_ptr,m_wr_ptr,n,m_full))
if (n) m_full=false;
 } // take
// could index eol during write? 
StrTy *  read_string( const IdxTy flags=0 )
{
//bool found=false;
//MM_ERR(" rd wtf "<<MMPR(Available())) 
EnterSerial(0);
IdxTy ptr=m_rd_ptr;
if ( ptr==m_wr_ptr) if (!m_full) { ExitSerial(0); return 0; }
IdxTy n=0;
while ((m_tgt[ptr]!=0)&&(m_tgt[ptr]!='\n')) 
{ ++n; 
if ( ptr==m_wr_ptr) if (m_full) { ExitSerial(0); return 0; }
inc(ptr,1); 
if ( ptr==m_wr_ptr)if(!m_full)   { ExitSerial(0); return 0; }
} 
ExitSerial(0);
Data * p=new char[n+1];
read(p,n+1,0);
//if (p[n-1]=='\r')
p[n]=0;
StrTy * s= new StrTy(p);
delete [] p;
return s;

} // read_string
IdxTy read( Data * p, const IdxTy sz,const IdxTy flags )
{
const bool take=!Bit(flags,0);
EnterSerial(0);
IdxTy n=Available();
if (n>sz) n=sz;
IdxTy rd2=m_rd_ptr+n;
IdxTy szr=(rd2<=m_sz)? n:(m_sz-m_rd_ptr);
memcpy(p,m_tgt+m_rd_ptr,szr);
if (szr<n) memcpy(p+szr,m_tgt,n-szr);
if (take) { m_rd_ptr=rd2 % m_sz; 
if (n) m_full=false; }
ExitSerial(0);
return n;
} // read
Myt & operator=(const Myt & that) 
{
m_mutex_vector= MutexVector(that.m_mutex_vector.size());
 m_rd_ptr=0;
m_wr_ptr=0;
m_full=false;
m_sz=that.m_sz;
m_dump_on_exit=that.m_dump_on_exit;
m_tgt=0;
if (m_sz) m_tgt=new char[m_sz];
return *this;
}

private:
//int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
//int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=~((1)<<b); }
StrTy Dump(const IdxTy flags=0) const  {Ss ss;  
ss<<MMPR4(m_sz,space(),available(),m_max);
return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
StrTy XXX_test(const StrTy & sin, const IdxTy flags) 
{
StrTy sout="";
MM_ERR(MMPR3(sin,flags,sout))
BaseParams kvp(sin);

return sout;
} // XXX_test

IdxTy Space() const { return m_sz-Available(); } 
IdxTy Available() const
{
if (m_full) return m_sz;
IdxTy d=0;
// save locks...
// this stupid thing needs to know that the index things
// are UNSIGNED and hopefully temps never less than zed??? 
if ( m_wr_ptr>=m_rd_ptr) d= m_wr_ptr-m_rd_ptr;
else d=m_sz+m_wr_ptr-m_rd_ptr;

return d;

}
template <class Ragged> 
void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{

m_mutex_vector=MutexVector(3);
m_tgt=0;
m_rd_ptr=0;
m_wr_ptr=0;
m_sz=0;
m_max=0;
m_full=false;
m_dump_on_exit=true;
} // Init



// MEMBERS
volatile IdxTy m_rd_ptr, m_wr_ptr, m_sz,m_max;
 Data * m_tgt;
volatile bool m_full;
bool m_dump_on_exit;



}; // mjm_ya_buffer

//////////////////////////////////////////////

template <class Tr>
class mjm_ya_buffer_map : public std::map<typename Tr::StrTy, mjm_ya_buffer< Tr > >  
{
 typedef mjm_ya_buffer_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ya_buffer< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_ya_buffer_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ya_buffer_map




////////////////////////////////////////////
#ifdef  TEST_MJM_YA_BUFFER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ya_buffer <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;

#define CI(n) atoi(cip.wif(n).c_str()) 

void about()
{
Ss ss;
ss<<" MJM_YA_BUFFER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
//typedef mjm_ragged_table Ragged;

#define CIP(n) atoi(cip.wif(n).c_str())
#define CFP(n) atof(cip.wif(n).c_str())

int main(int argc,char **args)
{
about();
typedef mjm_ya_buffer<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

//if (cmd=="loadragged") {
// 	const IdxTy start=atoi(cip.wif(2).c_str()); 
//	const IdxTy first=atoi(cip.wif(3).c_str()); 
//	const IdxTy flags=atoi(cip.wif(4).c_str()); 
//Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="test") {StrTy xxx=x.xxx_test(cip.p1,CIP(2)); MM_ERR(MMPR(xxx))  }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_YA_BUFFER_H__ 
