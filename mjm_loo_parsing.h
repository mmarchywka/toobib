#ifndef MJM_LOO_PARSING_H__
#define MJM_LOO_PARSING_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_unit_crap.h"
#include "mjm_collections.h"
#include "mjm_misc_parse.h"
// faster than calling date in bash doh 
#include "mjm_calendar.h"
//#include "mjm_diary_parse_error.h"

#include <map>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <cctype>


// Sun Oct 11 20:03:13 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_loo_parsing   
// g++  -Wall -std=gnu++11 -DTEST_MJM_LOO_PARSING -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_loo_parsing.h  -lpthread -lreadline
// loo : line oriented object parsing 
template <class Tr>
class mjm_loo_parsing 
{
 typedef mjm_loo_parsing Myt;
typedef Myt Loo;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::OsTy Os;
 typedef typename Tr::Ofs Ofs;

// this code is copied several times, put in include file 
typedef mjm_ragged_table Ragged;
typedef typename Ragged::Line Line;
typedef StrTy Word;
typedef std::vector<Word> Words;
typedef std::map<StrTy, IdxTy> DictTy;
typedef mjm_var_parse<Tr> CharClass;
typedef typename CharClass::read_buffer Rb;

typedef mjm_unit_crap<Tr> Units;
typedef typename Units::qty_dim Qdim;




//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_loo_parsing() {}
~mjm_loo_parsing() {}
// trim and clean up string 
enum { CANMASK=(1<<8)-1 };
static StrTy canonical(const StrTy & s, const IdxTy flags) 
{
const bool remove_lead=Bit(flags,0);
const bool remove_trail=Bit(flags,1);
const bool remove_spaces=Bit(flags,2);
const bool to_lc=Bit(flags,3);

const IdxTy sz=s.length();
const char * ssp=s.c_str();
char d[(1+sz)<<1];
memcpy(d,ssp,sz+1);
IdxTy sp=0, dp=0;
while (sp<sz)
{
char c=ssp[sp];
++sp;
if (to_lc) c=tolower(c);
//if (remove_lead) if (dp==0) if (c!=' ' ) 
if (c!=' ') {  d[dp]=c; ++dp; } 
else 
{
if (remove_spaces)  continue ;
if ( (dp!=0) ||(!remove_lead)) { d[dp]=c; ++dp; } 

} // c== ' ' 
} // while 
if (remove_trail) { while (d[dp]==' ') { if (!dp) break; else --dp; }  } 

d[dp]=0;
return StrTy(d);
}

template <class Tm>
static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,  std::map<StrTy, Tm > >  & x,  const IdxTy flags)
{
MM_LOOP(ii,x)
{ Dump(os,lbl+StrTy(" ")+(*ii).first,(*ii).second,flags); } /// ii 
} // Dump4 map 
template <class Tm>
static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,  std::vector< Tm > >  & x,  const IdxTy flags)
{
MM_LOOP(ii,x)
{
MM_LOOP(jj,(*ii).second){

os<<lbl<<" "<<StrTy((*ii).first)<<" "<<StrTy(*jj)<<CRLF;} // jj
 } /// ii 
} // Dump4 vector  
static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,  std::vector< Line > >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{
MM_LOOP(jj,(*ii).second){
if (pre) os<<CRLF;  
os<<lbl<<" "<<StrTy((*ii).first);
MM_LOOP(kk,(*jj))
{
os<<" "<<StrTy(*kk);} // kk 
if (post) os <<CRLF; 

} // jj


 } /// ii 
} // Dump4 vector  



template <class Tm>
static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,Tm >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{
if (pre) os<<CRLF;  
os<<lbl<<" "<<StrTy((*ii).first)<<" "<<StrTy((*ii).second);
if (post) os <<CRLF; 
} /// ii 
} // Dump4 vector  

static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,int >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{ if (pre) os<<CRLF; os<<lbl<<" "<<StrTy((*ii).first)<<" "<<((*ii).second);
if (post) os<<CRLF;  } /// ii 
} // Dump4 vector  

static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,IdxTy >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{if (pre) os<<CRLF;  os<<lbl<<" "<<StrTy((*ii).first)<<" "<<((*ii).second);
if (post ) os<<CRLF; } /// ii 
} // Dump4 vector  
static void Dump(Os & os, const StrTy & lbl, const std::map<StrTy,D >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{ if (pre) os<<CRLF;  os<<lbl<<" "<<StrTy((*ii).first)<<" "<<((*ii).second);
if (post) os<<CRLF;  } /// ii 
} // Dump4 vector  
// added 2022-07-16 FUDD 
template <class Tfudd > 
static void Dump(Os & os, const StrTy & lbl, const std::vector<Tfudd >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{ if (pre) os<<CRLF; 
os<<lbl<<" "<<(*ii); 
if (post) os<<CRLF;  } /// ii 
} // Dump4 vector  


static void Dump(Os & os, const StrTy & lbl, const std::vector<Line >  & x,  const IdxTy flags)
{
const bool pre=!Bit(flags,0);
const bool post=Bit(flags,1);
MM_LOOP(ii,x)
{ if (pre) os<<CRLF; 
os<<lbl; 
MM_LOOP(jj,(*ii)) { os<<" "<<(*jj); } ;
if (post) os<<CRLF;  } /// ii 
} // Dump4 vector  



template <class Tg> 
static StrTy  Dump(const Tg  & x)
{
Ss os;
//os<<lbl;
MM_LOOP(jj,x) { os<<" "<<(*jj).dump(); } ;
return os.str();
} // Dump4 vector  

static StrTy  Dump(const std::vector<double>  & x)
{
Ss os;
//os<<lbl;
MM_LOOP(jj,x) { os<<" "<<(*jj); } ;
return os.str();
} // Dump4 vector  


static StrTy  Dump(const Words  & x)
{
Ss os;
//os<<lbl;
MM_LOOP(jj,x) { os<<" "<<(*jj); } ;
return os.str();
} // Dump4 vector  





static void load(IsTy & is , Ragged & r,  const IdxTy flags)
{
const bool csv=Bit(flags,1);
CommandInterpretter li(&is);
li.set_split(6,csv?',':' ');
//m_form.load(li,0);
r.load(li,0);
}

static void NextFloat(D & d, IdxTy & i, const Line & l, const IdxTy sz)
{
++i;
if (i>=sz) return;
const Word & w=l[i];
d=atof(w.c_str());

} // NextFloat

template<class Tp,class Tt >
static void TakeProperties(Tp & d, IdxTy & i, const Line & l, const IdxTy sz, const Tt & dummy)
{
++i;
if (i>=sz) return;
const Word & w=l[i];
if (w=="\\") return;
Words w2;
Loo::parse_full(w2,w.c_str(),',',0);
const IdxTy wsz=w2.size();
for(IdxTy i=0; i<(wsz&~1); i+=2) d[w2[i]]=Tt(w2[i+1]);

} // TakeProperties

template<class Tp >
static void TakeCount(Tp & d, IdxTy & i, const Line & l, const IdxTy sz)
{
++i;
if (i>=sz) return;
const Word & w=l[i];
if (w=="\\") return;
Words w2;
Loo::parse_full(w2,w.c_str(),',',0);
const IdxTy wsz=w2.size();
for(IdxTy i=0; i<(wsz); ++i) ++d[w2[i]];

} // TakeCount

template<class Tp >
static void SetFlags (IdxTy & d, const Tp & m, IdxTy & i, const Line & l, const IdxTy sz)
{
++i;
if (i>=sz) return;
const Word & w=l[i];
if (w=="\\") return;
Words w2;
Loo::parse_full(w2,w.c_str(),',',0);
const IdxTy wsz=w2.size();
for(IdxTy i=0; i<(wsz); ++i)
{
const auto ii=m.find(w2[i]);
if (ii==m.end()) continue;
d|=(*ii).second;
} // i 

} // TakeCount



template<class Tp >
static void TakeString(Tp & d, IdxTy & i, const Line & l, const IdxTy sz)
{
const StrTy k=l[i];
++i;
if (i>=sz) return;
d[k]=l[i];
} // TakeString

template<class Tp> 
static void TakeCode(Tp & d, IdxTy & i, const Line & l, const IdxTy sz) 
{
Line l2;
while (true)
{
++i;
if (i>=sz) break; // return;
const Word & w=l[i];
if (w=="\\") { if (l2.size()) d.push_back(l2); l2.clear(); continue; }
if (l2.size()==0)
{
const IdxTy wl=w.length();
if (wl==0) continue;
if (w.c_str()[wl-1]!=':') //{  l2.push_back(w); }
 l2.push_back(StrTy(""));
 l2.push_back(w); 
}
else l2.push_back(w);
} // true 
if (l2.size()) d.push_back(l2);
} // TakeCode
static void TakeLine(Line & d, IdxTy & i, const Line & l, const IdxTy sz)
{
while (true)
{
++i;
if (i>=sz) return;
const Word & w=l[i];
if (w=="\\") return;
d.push_back(w);

} // true

} // TakeLine

// parse a string s using separator sep pushing each word onto words.
// this is extracted from mjm_instruments.h the line oriented thing.

template <class Tv>
static void parse_full(Tv & words, const char * s,const char sep, const IdxTy flags=0 )
{
const IdxTy sz=strlen(s);
bool preserve_quotes=Bit(flags,0);
const bool no_concat_seps=!Bit(flags,1);
bool deb=false;
//MM_ERR(MMPR3(sz,sep,s))
char c[2*sz+1];
IdxTy pc=0;
IdxTy dp=0;
// TODO need a state int not bools 
IdxTy  start=0;
bool esc=false;
bool quote=false;
// added this, note tested 2020-10-20
bool squote=false;
//MM_ERR(" parser "<<MMPR4(no_concat_seps,preserve_quotes,flags,sep))
while (s[pc] != 0 )
{
	const char & cpc=s[pc];
	// do not pass the quote to esc to dest 
	if (!esc) if (cpc=='\\')  { esc=true; ++pc; continue; }  // else esc=false;
	if (!esc) if (cpc=='\'')  { squote=!squote; ++pc; continue; }  // else esc=false;
	if (!esc&&!squote) if (cpc=='"') 
	{
		deb=!true; quote=!quote; ++pc ; 
		if (preserve_quotes){  c[dp]=cpc; ++dp;} 
		continue;  
	}
	const bool br=(cpc==sep)&&(!esc)&&(!quote)&&(!squote);
	if (br)
	{  
		c[dp]=0;
		if ((c[start]!=0)||no_concat_seps ) words.push_back(c+start);
		++dp; start=dp;    
	}
 	else { c[dp]=cpc; ++dp; }
	++pc;
	esc=false; 
}
if (deb) { MM_ERR(MMPR4(pc,dp,start,words.size())) }

if (start!=dp){ c[dp]=0;  words.push_back(c+start);  }
if (deb) { MM_ERR(MMPR4(pc,dp,start,words.size())) }

}//  parse_full








//static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
template <class Td, class Tm > static 
void SplitPartLine(Td & x, IdxTy & i, Tm & m, const Line  & l, const IdxTy szl)
//const
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const StrTy w=rb[0];
///const IdxTy n=rb.string_count();
//for(IdxTy j=0; j<n; j+=2) m[StrTy(rb[j])]=Qdim(j+1,"rank"); 
Ragged r;
Ss ss;
ss<<l[i].c_str()+w.length()+1;
MM_ERR(" should be a string not ptr lol "<<ss.str())
Load(ss,r,0);
//m_line_parts[w]=r.line(0);
x[w]=r.line(0);
} // SplitPartLine

template < class Td > static 
void SplitFullPartLine(Td & m, IdxTy & i,  const Line  & l, const IdxTy szl)
//const
{
 ++i; if (i>=szl) return;
Words w2;
Loo::parse_full(w2,l[i].c_str(),',',0);
const IdxTy n=w2.size();
if (n==0) return; 
const StrTy&  name=w2[0];
auto & d=m[name];
//Rb rb(l[i]);
//rb.split_and_mark(',');
//const StrTy w=rb[0];
///const IdxTy n=rb.string_count();
//for(IdxTy j=0; j<n; j+=2) m[StrTy(rb[j])]=Qdim(j+1,"rank"); 
for(IdxTy j=1; j<n; ++j)
{
Ragged r;
Ss ss;
ss<<w2[j];
//MM_ERR(" should be a string not ptr lol "<<ss.str())
Load(ss,r,0);
if (r.size()) d.push_back(r.line(0));
}
} // SplitFullPartLine




static void Load(IsTy & is , Ragged & r,  const IdxTy flags) // const
{
const bool csv=Bit(flags,1);
CommandInterpretter li(&is);
li.set_split(6,csv?',':' ');
//m_form.load(li,0);
r.load(li,0);

}





template <class Tm > 
static void Split(IdxTy & i, Tm & m, const Line  & l, const IdxTy szl)  
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const IdxTy n=rb.string_count();
for(IdxTy j=0; j<n; ++j) m[StrTy(rb[j])]+=1; 
} // Split


template <class Tm > 
static void SplitEnum(IdxTy & i, Tm & m, const Line  & l, const IdxTy szl)  
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const IdxTy n=rb.string_count();
for(IdxTy j=0; j<(n&(~1)); j+=1) m[StrTy(rb[j])]=StrTy(rb[j+1]); 
} // SplitEnum




template <class Tm, class Tn >
static void SplitPart(IdxTy& i, Tm& m, Tn &ma, const Line& l, const IdxTy szl) 
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const IdxTy n=rb.string_count();
const bool have_alt=(n&1);
const IdxTy j0=have_alt?1:0;
Tm & mr=have_alt?ma[StrTy(rb[0])]:m;
for(IdxTy j=j0; j<n; j+=2) mr[StrTy(rb[j])]=Qdim(rb[j+1]);
if ((have_alt)){
//Ss ss;
MM_ERR(" odd entries on component list treated as alt entry  "<<MMPR2(i,l[i]) )
}
} // SplitPart

template <class Tm >
static void SplitPart(IdxTy& i, Tm& m,  const Line& l, const IdxTy szl) 
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const IdxTy n=rb.string_count();
const bool have_alt=(n&1);
const IdxTy j0=have_alt?1:0;
auto  & mr=m[StrTy(have_alt?(rb[0]):"")];
for(IdxTy j=j0; j<n; j+=2) mr[StrTy(rb[j])]=Qdim(rb[j+1]);
if ((!have_alt)){
//Ss ss;
MM_ERR(" even entry count assuming null name default,   "<<MMPR2(i,l[i]) )
}
} // SplitPart


template <class Tm >
static void SplitPartFull(IdxTy& i, Tm& m,  const Line& l, const IdxTy szl,const IdxTy flags) 
{
 ++i; if (i>=szl) return;
Words w2;
Loo::parse_full(w2,l[i].c_str(),',',0);
const IdxTy n=w2.size();
if (n==0)
{
MM_ERR(" no strings here "<<MMPR2(n,l[i]))
 return; 
}
//Rb rb(l[i]);
//rb.split_and_mark(',');
//const IdxTy n=rb.string_count();
const IdxTy cf=flags&CANMASK;
const bool have_alt=(n&1);
const IdxTy j0=have_alt?1:0;
const StrTy nm=StrTy(have_alt?(w2[0]):StrTy());
if (n==1) { MM_ERR("warning only a name here nothing to add "<< MMPR4(n,j0,nm,w2[0])) } 
//auto  & mr=m[StrTy(have_alt?(w2[0]):StrTy())];
auto  & mr=m[nm];
for(IdxTy j=j0; j<n; j+=2) mr[canonical(StrTy(w2[j]),cf)]=Qdim(w2[j+1].c_str());
if ((!have_alt)){
//Ss ss;
MM_ERR(" even entry count assuming null name default,   "<<MMPR2(i,l[i]) )
}
} // SplitPartFull
////////////


// do a detailed parse with escape and quote facilities.
// missing amounts treated as ranks. 
// unites have "things" added for top and bottom
// to keep track of contents fractions. 
template <class Tm >
static void SplitPartFullLbl(IdxTy& i, Tm& m,  const Line& l, const IdxTy szl,const StrTy & bot,const IdxTy flags) 
{
 ++i; if (i>=szl) return;
Words w2;
Loo::parse_full(w2,l[i].c_str(),',',0);
const IdxTy n=w2.size();
if (n==0)
{
MM_ERR(" no strings here "<<MMPR2(n,l[i]))
 return; 
}
//Rb rb(l[i]);
//rb.split_and_mark(',');
//const IdxTy n=rb.string_count();
const IdxTy cf=flags&CANMASK;
const bool have_alt=(n&1);
const IdxTy j0=have_alt?1:0;
const StrTy nm=StrTy(have_alt?(w2[0]):StrTy());
if (n==1) { MM_ERR("warning only a name here nothing to add "<< MMPR4(n,j0,nm,w2[0])) } 
//auto  & mr=m[StrTy(have_alt?(w2[0]):StrTy())];
auto  & mr=m[nm];
for(IdxTy j=j0; j<n; j+=2)
{
 const StrTy top=canonical(StrTy(w2[j]),cf);
StrTy u=w2[j+1];
// if blanks, use rank 
if (u.length()==0)
{
Ss ss;
ss<<(1+(j>>1))<<"rank";
u=ss.str();
}
 //mr[canonical(StrTy(w2[j]),cf)]=Qdim(w2[j+1].c_str());
 mr[top]=Qdim(u,top,bot);

}
if ((!have_alt)){
//Ss ss;
MM_ERR(" even entry count assuming null name default,   "<<MMPR2(i,l[i]) )
}
} // SplitPartFull



/////////////



template <class Tm>
static void SplitUPC(IdxTy & i, Tm & m,  const Line  & l, const IdxTy szl) // const
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const IdxTy n=rb.string_count();
const bool have_alt=(n&1);
//const IdxTy j0=have_alt?1:0;
//Tm & mr=have_alt?ma[StrTy(rb[0])]:m;
if ((have_alt)){
//Ss ss;
MM_ERR(" odd entries on list treated spurious   "<<MMPR3(i,l[i-1],l[i]) )
}
//for(IdxTy j=0; j<(n&(~1)); j+=2) m[StrTy(rb[j])]=StrTy(rb[j+1]);
// note this could be BACKWARDS for a number lookup
// with applicable codes to resolve ambiguouity 
// suggest number,system to allow easy look up and unlikely
// need for duplicates anyway.. 
for(IdxTy j=0; j<(n&(~1)); j+=2) m[StrTy(rb[j])].push_back(StrTy(rb[j+1]));

} // SplitUPC

// every entry is in rank order 
// TODO this needs to accomodate less than and comments and even
// nexted things as is common in lists 
template <class Tm >
static void SplitPartRank(IdxTy & i, Tm & m, const Line  & l, const IdxTy szl, const IdxTy flags) /// const
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',');
const IdxTy cf=(flags&CANMASK);
const IdxTy n=rb.string_count();
for(IdxTy j=0; j<n; j+=2) m[canonical(StrTy(rb[j]),cf)]=Qdim(j+1,"rank");

} // SplitPartRank



// split naively by comma and if the CNAMASK bit is set make name conform
// to some conventions in "canonical" 
template <class Tm >
static void SplitPartRankName(IdxTy & i, Tm & m, const Line  & l, const IdxTy szl, const IdxTy flags) /// const
{
 ++i; if (i>=szl) return;
Rb rb(l[i]);
rb.split_and_mark(',',true);
const IdxTy n=rb.string_count();
if (n==0) return;
const IdxTy cf=(flags&CANMASK);
auto&  mx=m[rb[0]];
for(IdxTy j=1; j<n; j+=2) mx[canonical(StrTy(rb[j]),cf)]=Qdim(j+1,"rank");

} // SplitPartRankName















StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


}; // mjm_loo_parsing

//////////////////////////////////////////////

template <class Tr>
class mjm_loo_parsing_map : public std::map<typename Tr::StrTy, mjm_loo_parsing< Tr > >  
{
 typedef mjm_loo_parsing_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_loo_parsing< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_loo_parsing_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_loo_parsing_map




////////////////////////////////////////////
#ifdef  TEST_MJM_LOO_PARSING
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_loo_parsing <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_LOO_PARSING "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_loo_parsing<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_LOO_PARSING_H__ 
