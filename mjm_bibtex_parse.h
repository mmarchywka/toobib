#ifndef MJM_BIBTEX_PARSE_H__
#define MJM_BIBTEX_PARSE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_wovdb.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_misc_parse.h"
#include "mjm_read_buffer.h"
#include "mjm_blob.h"




// Mon Sep 16 20:34:28 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibtex_parse   
// g++ -std=gnu++11 -DTEST_MJM_BIBTEX_PARSE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibtex_parse.h  -lpthread -lreadline

template <class Tr>
class mjm_bibtex_parse 
{
 typedef mjm_bibtex_parse Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef mjm_misc_parse<Tr> ParseTableSuper;
typedef mjm_var_parse<Tr> ParseTable;
typedef mjm_read_buffer<Tr> RdBuf;
typedef mjm_blob<Tr>  Blob;
typedef typename ParseTable::Iv Iv;

typedef mjm_wovdb<Tr,StrTy> WovDB;
enum  {DCMAX=100};
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_parse(): m_rdb(10)  {Init(); }
~mjm_bibtex_parse() {}


template <class Tm> 
IdxTy parse(Tm & m, const char * p, const IdxTy len, const IdxTy flags)
{
return Parse(m,p,len,m_clut,flags);
}
void parse(OsTy & os, const StrTy nm)
{ Parse_db(os,nm); } 

template <class Tm> IdxTy get_last_keys(Tm & v) { return GetLastKeys(v); } 

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:


void Init() {m_key_mask=0;  m_val_mask=0; FixClut();  }


bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
bool Mask(const IdxTy f, const IdxTy b) const  { return  ((f)&b)!=0; }
// need to make vector valed 
class asgn {
typedef std::map<StrTy,StrTy> M;
public:
asgn(M & m) : m_map(m) {}
void kv(const StrTy & k, const StrTy & v,int stage) {m_map[k]=v; } 
M &  m_map;

}; // asgn

void Parse(OsTy & os, const StrTy nm)
{
typedef std::map<StrTy,StrTy> M;
Blob x;
x.load(nm);
IdxTy len=x.size();
IdxTy pos=0;
while (pos<len)
{
M m;
os<<CRLF;
IdxTy dx=parse(asgn(m),x.ptr()+pos,len-pos,0);
os<<MMPR3(pos,dx,len);
pos+=dx;
MM_LOOP(ii,m) { os<<MMPR2((*ii).first, (*ii).second)<<CRLF; }

}
} // Parse

class asgndb {
typedef WovDB Mdb;
public:
asgndb(Mdb & m) : m_map(m) {}
void kv(const StrTy & k, const StrTy & v, int stage) {
/*
grep m.kv mjm_bibtex_parse.h | sed -e 's/.*m\.kv/m.kv/'
m.kv(leading_name,rdb.string(),0); 
m.kv(type_name,rdb.string_sane(0),1);     return pc;  } 
m.kv(type_name,rdb.string_sane(0),2);     return pc;  } 
m.kv(type_name,rdb.string_sane(0),3); 
m.kv(type_name,rdb.string_sane(1),4); return pc; } 
m.kv(name_name,rdb.string_sane(1),5);
m.kv(rdb.string_sane(kvc-2),rdb.string_sane(kvc-1),6); 
*/
//m_map[k]=v; 
IdxTy loc=m_map.add(v);
if (stage==~0)  { m_map.index(loc,"error",k); return ; } 
if (stage==~1)  { m_map.index(loc,"observe",k); return ; } 
const StrTy idxname=(stage==6)?"":"special";
m_map.index(loc,idxname,k);

}
Mdb &  m_map;

}; // asgndb


void Parse_db(OsTy & os, const StrTy nm)
{
typedef WovDB Mdb;
Blob x;
x.load(nm);
IdxTy len=x.size();
IdxTy pos=0;
while (pos<len)
{
Mdb mdb;
os<<CRLF;
asgndb xx(mdb);
IdxTy dx=parse(xx,x.ptr()+pos,len-pos,0);
os<<MMPR3(pos,dx,len);
pos+=dx;
{auto ii=mdb.begin("special");
while (ii) { os<<MMPR2(ii.key(),(*ii))<<CRLF; ++ii; }
}
{auto ii=mdb.begin("");
while (ii) { os<<MMPR2(ii.key(),(*ii))<<CRLF; ++ii; }
}

//MM_LOOP(ii,m) { os<<MMPR2((*ii).first, (*ii).second)<<CRLF; }

}
} // Parse_db


class _ParseState
{

public:
_ParseState() { Init(); } 

_ParseState(const char * _p) { Init(); p=_p; } 

void Init() { 
p=0;
prd=0;
 pc=0;
 skipped=0;
 braces=0;
 ubraces=0;
 state=HUNT;
}
//ss<<msg<<" "<<MMPR2(pc,braces); ss<<std::hex<<MMPR(state);
StrTy dump() const
{
Ss ss;
ss<<MMPR4(pc,state,braces,ubraces);
ss<<MMPR(skipped); 
ss<<"0x0"<<std::hex<<MMPR(state); 
ss<<"0x0"<<std::hex<<MMPR(prd); 
return ss.str();
}

RdBuf * prd;
const char * p;
IdxTy pc;
IdxTy state;
int  braces;
int  ubraces;
IdxTy skipped;

}; // _ParseState
typedef _ParseState ParseState;


// this needs a routine to mince the word with the Parse thing, 
//enum { BAD=~0,BITS=8*sizeof(Ch), CARD=(1<<BITS),LC =(1<<0), DIGIT=(1<<1),
//WHITE=(1<<2), CTRL=(1<<3), UC=(1<<4), PUNC=(1<<5),EOL=(1<<6),START=(1<<7),
//STOP=(1<<8), OPER=(1<<9) } ; UNUSED ... 
// probably ESC is a macro hence BESC 
// !HUNT&!INBIB = parsing name 
enum { HUNT=(1<<0), INBIB=(1<<1), INTYPE=(1<<7), INNAME=(1<<2), INKEY=(1<<3)
, INVAL=(1<<4), BESC=(1<<5), QUOTE=(1<<6), BCOMMENT=(1<<8)  }; 
enum {BIBTYPES=ParseTable::LC|ParseTable::UC };
enum {BIBTYPE=ParseTable::LC|ParseTable::UC|ParseTable::DIGIT };
enum {BIBNAMES=ParseTable::LC|ParseTable::UC|ParseTable::DIGIT };
enum {BIBNAME=ParseTable::LC|ParseTable::UC|ParseTable::DIGIT };
enum {NONEXCEPTIONAL=ParseTable::ASCII };
enum {WSTOSKIP=ParseTable::WHITE|ParseTable::EOL };
enum {COMMENTMASK=~0 };
// 2021-07-15 scraped clinical trial keys start with crap 
//enum {BIBKEYS=ParseTable::LC|ParseTable::UC };
enum {BIBKEYS=ParseTable::LC|ParseTable::UC|ParseTable::DIGIT };
enum {BIBKEY=ParseTable::LC|ParseTable::UC|ParseTable::DIGIT };
enum {BIBVALS=ParseTable::LC|ParseTable::UC };
enum {BIBVAL=ParseTable::LC|ParseTable::UC|ParseTable::DIGIT };

StrTy PrintState(const IdxTy state)
{
//ss<<MMPR4(c,pc,len,braces)<<std::hex<<MMPR2(int(c),state);
Ss ss;
ss<<std::hex<<MMPR(state);
if ( state&HUNT) ss<<",HUNT";
if ( state&INBIB) ss<<",INBIB";
if ( state&INTYPE) ss<<",INTYPE";
if ( state&INNAME) ss<<",INNAME";
if ( state&INKEY) ss<<",INKEY";
if ( state&INVAL) ss<<",INVAL";
if ( state&BESC) ss<<",BESC";
if ( state&QUOTE) ss<<",QUOTE";
if ( state&BCOMMENT) ss<<",BCOMMENT";
if ( state>>8) ss<<",JUNK"<<(state>>8);
return ss.str();
} // PrintState

void FixClut()
{
// add mask bits 
//m_val_mask=m_clut.uset("{}\""); 
m_val_mask=m_clut.uset("{@}\"");  // 2021-09-30 dying on emails lol 
m_key_mask=m_clut.uset("_"); 
m_inter_kv=0; // m_clut.uset(",");
m_name_mask=  m_clut.uset("_-:/#.;");
} 
bool Inc(IdxTy & pc, const IdxTy & len)
{
++pc; return  (pc>=len) ; 
}
bool CharOk(const char c, const IdxTy mask, ParseTable & clut)
{
return (( clut.lut()[int(c)]&mask)!=0);  
}
StrTy  CharCoS( const StrTy & msg, const char c, const char * p, const IdxTy pc, const IdxTy len,const IdxTy state, const IdxTy braces )
{
Ss ss;
ss<<msg;
ss<<MMPR4(c,pc,len,braces)<<std::hex<<MMPR2(int(c),state);
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
return ss.str();

}
template <class Tm> 
StrTy  CharCoS( Tm & m, const StrTy & msg, const char c, const char * p, const IdxTy pc, const IdxTy len,const IdxTy state, const IdxTy braces )
{
Ss ss;
ss<<msg;
ss<<MMPR4(c,pc,len,braces)<<std::hex<<MMPR2(int(c),state);
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
ss<<MMPR(m_rdb.dump_char(DCMAX,3));
m.kv("charcos",ss.str(),~0);
return ss.str();

}



StrTy  EarlyEnd( Ss  & _ss,const char * p,  const ParseState & ps ) 
{
Ss ss;
//ss<<msg<<" "<<MMPR2(pc,braces); ss<<std::hex<<MMPR(state);

ss<<_ss.str()<<" "<<ps.dump();
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
return ss.str();
}



StrTy  EarlyEnd( const StrTy & msg,const char * p,  const IdxTy pc, const IdxTy state, const IdxTy braces)
{
Ss ss;
ss<<msg<<" "<<MMPR2(pc,braces);
//ss<<std::hex<<MMPR(state);
ss<<PrintState(state);
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
return ss.str();
}

template <class Tm > 
StrTy  EarlyEnd( Tm & m, const StrTy & msg,const char * p,  const IdxTy pc, const IdxTy state, const IdxTy braces)
{
Ss ss;
ss<<msg<<" "<<MMPR2(pc,braces);
//ss<<std::hex<<MMPR(state);
ss<<PrintState(state);
MM_ERR(ss.str())
MM_ERR(MMPR(m_rdb.summary(0)))
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
ss<<" buffer = "<<m_rdb.dump_char(DCMAX,3);
m.kv("earlyend",ss.str(),~0);
return ss.str();
}




template <class Tm > 
StrTy  EarlyEnd(Tm & m,  Ss  & _ss,const char * p,  const ParseState & ps ) 
{
Ss ss;
//ss<<msg<<" "<<MMPR2(pc,braces); ss<<std::hex<<MMPR(state);

ss<<_ss.str()<<" "<<ps.dump();
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
m.kv("earlyend",ss.str(),~0);
return ss.str();
}




template <class Tm > 
void Observe( Tm & m, const StrTy & msg,const ParseState & ps )
{
Ss ss;
ss<<msg<<" "<<MMPR(ps.dump());
//ss<<std::hex<<MMPR(state);
MM_ERR(ss.str())
//m_rdb.cap();
//MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
ss<<" buffer = "<<m_rdb.dump_char(DCMAX,3);
MM_ERR(" Ovserve "<<ss.str())
m.kv("observation",ss.str(),(~1));
//return ss.str();
} // Observe




StrTy  CharCoS( const StrTy & msg, const char c, const IdxTy mask, ParseTable & clut)
{
Ss ss;
ss<<msg;
IdxTy v=  clut.lut()[int(c)];  
ss<<std::hex<<MMPR4(v,mask,int(c),c);
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
return ss.str();
}
template <class Tm>
StrTy  CharCoS( Tm & m,  const StrTy & msg, const char c, const IdxTy mask, ParseTable & clut)
{
Ss ss;
ss<<msg;
IdxTy v=  clut.lut()[int(c)];  
ss<<std::hex<<MMPR4(v,mask,int(c),c);
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
ss<<" buffer = "<<m_rdb.dump_char(DCMAX,3);
m.kv("charcos",ss.str(),~0);
return ss.str();
}

/*
template <class Tm> 
StrTy  CharCoS( Tm & m, const StrTy & msg, const char c, const IdxTy mask, ParseTable & clut)
{
Ss ss;
ss<<msg;
IdxTy v=  clut.lut()[int(c)];  
ss<<std::hex<<MMPR4(v,mask,int(c),c);
MM_ERR(ss.str())
//m_rdb.cap();
MM_ERR(MMPR(m_rdb.dump_char(DCMAX)))
return ss.str();
}
*/

void Trans(IdxTy & s, const IdxTy from, const IdxTy to) { s&=~from; s|=to; }
void TransIf(IdxTy & s, const IdxTy m, const bool x) {if (!x)  s&=~m; else  s|=m; }
void Flip(IdxTy & s, const IdxTy m) { s^=m; }
// this should only be called from non-quoited point and
// then also skip from comment to eol 
//void SkipWS(p,pc,len,clut)
bool SkipWS ( const char * p,  IdxTy&  pc, const IdxTy len,  ParseTable & clut,
const Iv pmask=WSTOSKIP)
{
std::vector<char> cv;
IdxTy mask = pmask; /// WSTOSKIP;
if (p[pc]=='%') mask=COMMENTMASK;
while ( CharOk(p[pc],mask,clut)) 
{
if (Inc(pc,len)){ 
if (cv.size()!=0)
{ cv.push_back(0);  MM_ERR(" comment found in bad place "<<MMPR((&cv[0]))); }
return true ;  } 
if (p[pc]=='%') mask=COMMENTMASK;
else if ( CharOk(p[pc],ParseTable::EOL,clut)) mask=pmask; // WSTOSKIP;
if (int(mask)==COMMENTMASK) cv.push_back(p[pc]);
} // while
if (cv.size()!=0)
{ cv.push_back(0);  MM_ERR(" comment found in bad place "<<MMPR((&cv[0]))); }

return false; 
} // SkipWS;


template <class Tm> IdxTy GetLastKeys(Tm & v) 
{  // kvc
// this is the size ofthe mark vector
const IdxTy szl=m_rdb.strings()-1;
if (szl==~0U) return 0;
// string sane is an index into the mark buffer so the limit shoud be ok 
for(IdxTy i=2; i<szl; i+=2) v.push_back((m_rdb.string_sane(i)));

return v.size(); } 


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

template <class Tm> 
IdxTy ParseHunt(Tm & m, ParseState & ps,const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{

const StrTy leading_name="junk_name";
IdxTy &  pc=ps.pc;
IdxTy &  skipped=ps.skipped;
// 2023-01-12 unused remove dummy thing for now 
//int&  braces=ps.braces;
IdxTy &  state=ps.state;
RdBuf& rdb= * ps.prd;
// 2022-07-24 compiler complais unused... 
// 2023-01-12 unused remove dummy thing for now 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))


//bool in_esc=false;
//bool in_comment=false;
char c=p[pc]; 

bool hunting_comment=false;
while (true) // while (Mask(state,HUNT)) 
{
// when the prior one is junk it gets tacked on here ... doh 
// 2021-07-15 clinical trial contact info in the value field unquotes
// ampersand in a value field is ok without esc yet makes a bif fck here
//const bool ignore =Mask(state,BESC|BCOMMENT|QUOTE);
if (c=='%') hunting_comment=true;
const bool ignore =hunting_comment||Mask(state,INVAL|BESC|BCOMMENT|QUOTE);
if ((!ignore)&&( c=='@'))
//{ rdb.cap(); m[leading_name]=rdb.string(); 
{ rdb.cap(); m.kv(leading_name,rdb.string(),0); 
  Trans(state,HUNT, INBIB|INTYPE );
break; // this avoids meaningless append but also inc lol 
 }  // state&=~HUNT; 
else ++skipped;
TransIf(state,BESC,(c=='\\')) ;

Iv v=m_clut.lut(c);
if(Mask(v,ParseTable::EOL)) 
{
hunting_comment=false;
Trans(state,BESC|QUOTE|BCOMMENT,0) ;
}
rdb.append(c);
if (Inc(pc,len))
{
// TODO not really an error will be apaprent on examination 
// m.kv("earlyend","end found before start",~0); 
 return pc; 
}

c=p[pc]; 
} // while true HUNT 



return 0;
} // ParseHunt


template <class Tm> 
IdxTy ParseType(Tm & m, ParseState & ps,const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{

const StrTy type_name="type_name";
IdxTy &  pc=ps.pc;
// 2023-01-12 unused remove dummy thing for now 
//IdxTy &  skipped=ps.skipped;
int&  braces=ps.braces;
IdxTy &  state=ps.state;
RdBuf& rdb= * ps.prd;

// 2022-07-24 compiler complais unused... 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))


// now skipping inc after ampersand
if (Inc(pc,len)) 
{
 m.kv("earlyend","end found endtry ends ",~0); 
return pc; 
}

char c=p[pc]; 
if (! CharOk(c,BIBTYPES,clut)) 
{ 
CharCoS(m,"bad type",c,BIBTYPES,clut) ;return pc; } 
// string zero is the name
rdb.append(c);
// could return a blank name; 
// could use goto using reverse assign order  at exit lol 
// the state never changes now 
while (true) // while (Mask(state,INTYPE)) 
{
// oh this worked when the first string wsa there doh. 
if (Inc(pc,len)){ 
rdb.cap(); m.kv(type_name,rdb.string_sane(0),1);     
return pc;  } 
c=p[pc]; 
//std::cerr<<c; 
// 2022-02-06 
const bool name_kluge1= (c!='-')&&(c!='_');
if (name_kluge1&&! CharOk(c,BIBTYPE,clut)) 
{
// white space or '{' 
if (SkipWS(p,pc,len,clut)){ rdb.cap(); m.kv(type_name,rdb.string_sane(0),2);     return pc;  } 
c=p[pc]; 
break;
} // CharOK
rdb.append(c);
} // INNAME


if (c=='{')
{
++braces;
// for now leave the entry in the read buffer for later analysis
// although popping the last complete one works too. 
rdb.start_new(); m.kv(type_name,rdb.string_sane(0),3); 
Trans(state,INTYPE,INNAME);
} // == }
else { 
char fck[pc+2];
memcpy(fck,p,pc);
fck[pc]=0;
MM_ERR(MMPR(fck))
CharCoS(m," m1 need left brace to start name ",c,p,pc,len,state,braces) ;return pc; } 

// if there is nothing else, the name is null but braces unbalanced
if (Inc(pc,len))
{ 
CharCoS(m,"need right brace(s) to end entry  ",c,p,pc,len,state,braces) ; return pc;  } 

if (SkipWS(p,pc,len,clut)){ rdb.cap(); m.kv(type_name,rdb.string_sane(1),4); return pc; } 


return 0;
} // ParseType



template <class Tm> 
IdxTy ParseName(Tm & m, ParseState & ps,const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{
const StrTy name_name="name_name";
IdxTy &  pc=ps.pc;
// 2023-01-12 unused remove dummy thing for now 
//IdxTy &  skipped=ps.skipped;
int&  braces=ps.braces;
IdxTy &  state=ps.state;
RdBuf& rdb= * ps.prd;

// 2022-07-24 compiler complais unused... 
// 2023-01-12 unused remove dummy thing for now 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))


char c=p[pc];
if (! CharOk(c,BIBNAMES,clut)) 
{ 
CharCoS(m,"need name start char here ",c,BIBNAMES|m_name_mask,clut) ;return pc; } 
rdb.append(c);
while (Mask(state,INNAME))
{
if (Inc(pc,len))
{ 
CharCoS(m,"need right brace(s) to end entry  ",c,p,pc,len,state,braces) ; return pc;  } 
c=p[pc]; 
if ((! CharOk(c,BIBNAME|m_name_mask,clut)) 
// latex seems ok with non-ascii citations names 
 && (CharOk(c,NONEXCEPTIONAL,clut)) )
{
rdb.start_new();
// the fist string is not marked, this is the first marked one. 
m.kv(name_name,rdb.string_sane(1),5);
break;
}
// keep non-ascii for now 
rdb.append(c);
} // INNAME;

if (SkipWS(p,pc,len,clut)) 
{ 
CharCoS(m,"need right brace(s) to end entry ",c,p,pc,len,state,braces) ; 
return pc;  } 
c=p[pc]; 
// this should be a comma
if (c!=','){ 
 CharCoS(m,"need comma after value  ",c,p,pc,len,state,braces) ; 
return pc;  } 
Trans(state,INNAME,0);


return 0;
} // ParseName



template <class Tm> 
IdxTy ParseKey(Tm & m, ParseState & ps,const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{
IdxTy &  pc=ps.pc;
// 2023-01-12 unused remove dummy thing for now 
//IdxTy &  skipped=ps.skipped;
int&  braces=ps.braces;
IdxTy &  state=ps.state;
RdBuf& rdb= * ps.prd;
// 2022-07-24 compiler complais unused... 
// 2023-01-12 unused remove dummy thing for now 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))


char c=p[pc];

if (SkipWS(p,pc,len,clut)) 
{ 
CharCoS(m,"key or right brace ",c,p,pc,len,state,braces) ; 
return pc;  } 
c=p[pc]; 
//////////////////////
// apaprently a right brace even after a comma is ok 
if (c=='}') { ++pc; return pc; } 
if (! CharOk(c,BIBKEYS|m_name_mask,clut)) 
{ 
//MM_MSG(" what the fck "<<MMPR(c))
char fck[pc+2];
memcpy(fck,p,pc);
fck[pc]=0;
MM_ERR(MMPR(fck))
CharCoS(m,"m1 need key start ",c,BIBKEYS|m_name_mask,clut) ;
return pc; } 
Trans(state,0,INKEY);
//rdb.start_new();
rdb.append(c);
// the state never changes here... 
while (true) // while (Mask(state,INKEY)) 
{
if (Inc(pc,len)){ EarlyEnd(m," eof ",p,pc,state,braces);   
// m.kv("earlyend","eof too early  ",~0); 
  return pc;  } 
c=p[pc]; 
//MM_ERR(MMPR4(c,int(c),state,INKEY))
if (! CharOk(c,BIBKEY|m_name_mask,clut)) 
{
// white space or '{' 
rdb.start_new();
c=p[pc]; 
break;
} // CharOK
rdb.append(c);
} //BIBKEY 

return 0;
} // ParseKey

template <class Tm> 
IdxTy ParseValue(Tm & m, ParseState & ps,const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{

//const StrTy name_name="name_name";
IdxTy &  pc=ps.pc;
// 2023-01-12 unused remove dummy thing for now 
//IdxTy &  skipped=ps.skipped;
int&  braces=ps.braces;
IdxTy &  state=ps.state;
RdBuf& rdb= * ps.prd;
//2023-01-12 undo  2022-07-24 compiler complais unused... 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))


char c=p[pc];


// SkipWS already throws out trailing comments although not a good idea I guess 
if (SkipWS(p,pc,len,clut)){  EarlyEnd(m," eof ",p,pc,state,braces);    
// m.kv("earlyend","eof too early  ",~0); 
return pc;  } 
c=p[pc]; 
if (c!='=') { 
IdxTy pcx=(pc>80)?(pc-80):0;
MM_ERR(" need equal "<<MMPR2(pc,c))
std::stringstream ss;
while (pcx<pc) { ss<<p[pcx]; ++pcx; } 
StrTy sd=ss.str(); // StrTy(p+pcx,pc-pcx);
MM_ERR(MMPR3(__FUNCTION__,pc,sd))
CharCoS(m,"need equals 2 ",c,0,clut) ;
// m.kv("syntax","need equals  ",~0); 
return pc; } 
if (Inc(pc,len)){ EarlyEnd(m," eof ",p,pc,state,braces);     
// m.kv("earlyend","eof too early  ",~0); 
return pc;  } 
if (SkipWS(p,pc,len,clut)){  EarlyEnd(m," eof ",p,pc,state,braces);    
// m.kv("earlyend","eof too early  ",~0); 
return pc;  } 
c=p[pc]; 
// this makes no sense here. 
//if (! CharOk(c,bvsmask,clut)) 
//{ CharCoS("need val start ",c,bvsmask,clut) ;return pc; } 

// the value continues up to a equals out of quote at braces==1
Trans(state,INKEY,INVAL);
//rdb.start_new();
// get rid of white space until quote or brace 
// this ws just done above 
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
//c=p[pc]; 

if ( c=='{' ) { ++braces; }
else if ( c=='\"' ) { Flip(state,QUOTE); }
else rdb.append(c);
while (true)  // bib value 
{
if (Inc(pc,len)){ EarlyEnd(m," eof ",p,pc,state,braces); 
// m.kv("earlyend","eof too early  ",~0); 
    return pc;  } 
c=p[pc]; 
//if (! CharOk(c,bvmask,clut)) { }
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
//c=p[pc]; 
if (!Mask(state,BESC)) { 
// this does not need to be quoted, must end with brace or quote doh 
if (c==',') { if (braces==1)  if (!Mask(state,QUOTE)) break; } else 
if (( c=='{' )&&(!Mask(state,QUOTE))) 
{ ++braces; 
//continue; 
}
else if (( c=='}' )&&(!Mask(state,QUOTE))) { --braces;
// 
//if (braces<1) { EarlyEnd(" braces ",p,pc,state,braces);     return pc;  } 
if (braces<=1) break;
//continue; 
 }
else if (( c=='\"' )&&(!Mask(state,BESC))) { Flip(state,QUOTE); 
if (!Mask(state,QUOTE)&&(braces==1)) break; 
continue; }
else if (c=='\\') Trans(state,0,BESC);
} else { /// "escaiped" probably mostly laex commands doh 
// 2020-01-12 track the escaped crap for typos- see texhax list
if (( c=='}' )&&(!Mask(state,QUOTE))) { --ps.ubraces;
if (ps.ubraces<0) Observe(m, " user braces underflow ",ps);
} // right brace
else if (( c=='{' )&&(!Mask(state,QUOTE))) { ++ps.ubraces; } 
// end escaped tracking 
Trans(state,BESC,0); } 
rdb.append(c);

} // BIBVAL



return 0;
} // ParseValue


template <class Tm> 
IdxTy ParseTrail(Tm & m, ParseState & ps,const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{

//const StrTy name_name="name_name";
IdxTy &  pc=ps.pc;
// 2023-01-12 unused remove dummy thing for now 
// IdxTy &  skipped=ps.skipped;

int&  braces=ps.braces;
IdxTy &  state=ps.state;
// 2023-01-12 unused remove dummy thing for now 
//RdBuf& rdb= * ps.prd;

//undo 2023-01-12  2022-07-24 compiler complais unused... 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))

char c=p[pc];
// just find the one needed comma or right brace
while ((c!=','))
{
// the last 
if (Inc(pc,len)){ EarlyEnd(m," now comma or brace  ",p,pc,state,braces);  
// m.kv("earlyend","eof too early  ",~0); 
   return pc;  } 
// I think there has to be one comma so this will ignore that
// with zero or more. 
//if (SkipWS(p,pc,len,clut,WSTOSKIP|m_inter_kv))
if (SkipWS(p,pc,len,clut,WSTOSKIP))
//enum {WSTOSKIP=ParseTable::WHITE|ParseTable::EOL };
{EarlyEnd(m," looking for comma or brace   ",p,pc,state,braces);    
// m.kv("earlyend","looking for comma or brace  ",~0); 
  return pc;  } 
c=p[pc];
// the brace needs to be consumed 
if (c=='}') {  --braces; if (braces==0) { ++pc;  return pc; }  }
} // find comma
// then discard it 
if (Inc(pc,len)){ EarlyEnd(m," after comma   ",p,pc,state,braces);    
// m.kv("earlyend","after comma  ",~0); 
 return pc;  }



return 0;
} // ParseTrail

template <class Tm> 
IdxTy ParseClean(Tm & m, const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{
//MM_ERR(" new clean  parse ")
if (len==0 ) return 0; 
const Iv bvsmask=BIBVALS| m_val_mask;
const Iv bvmask=BIBVAL| m_val_mask;
const Iv keymask=BIBKEY|m_key_mask; // 2021

// a reusable assembly area hopefully 1k is normally enough...
RdBuf& rdb=m_rdb; //  rdb(10);
rdb.clear();
ParseState ps(p);

IdxTy &  pc=ps.pc;
// 2023-01-12 unused remove dummy thing for now 
//IdxTy &  skipped=ps.skipped;
int&  braces=ps.braces;
IdxTy &  state=ps.state;
ps.prd=&rdb;

// 2022-07-24 compiler complais unused... 
//MM_ERR(MMPR3(skipped,braces,(long int)(&rdb)))





IdxTy phrc= ParseHunt( m,  ps, p, len,  clut,  flags);
// need to make sure it found the start though...
if (Mask(state,HUNT)) return pc;
rdb.start_new();
IdxTy phtype= ParseType( m,  ps, p, len,  clut,  flags);
if (!Mask(state,INNAME)) return pc;

IdxTy phname= ParseName( m,  ps, p, len,  clut,  flags);
if (Mask(state,INNAME)) return pc;
// 2022-07-24 compile complains unused
//char c=p[pc]; 
IdxTy kvc=2; // added back in the comments in fromt 
if (Inc(pc,len)){ 
Ss ss; ss<<MM_MARK<<" need kv pair   "; EarlyEnd(m,ss,p,ps);   return pc;  } 
// done later  c=p[pc]; 
// kv pair loop 
while (true)
{
IdxTy phkey= ParseKey( m,  ps, p, len,  clut,  flags);
if (phkey) return pc;

IdxTy phvalue= ParseValue( m,  ps, p, len,  clut,  flags);
if (phvalue) return pc;

rdb.start_new();
kvc+=2;
//m[rdb.string_sane(kvc-2)]=rdb.string_sane(kvc-1); 
//MM_ERR(MMPR3(kvc,rdb.string_sane(kvc-2),rdb.string_sane(kvc-1)))

m.kv(rdb.string_sane(kvc-2),rdb.string_sane(kvc-1),6); 
Trans(state,INVAL,0);
// the last brace needs to be consumed 
if (braces==0){ ++pc;    break; } 
IdxTy phtrail= ParseTrail( m,  ps, p, len,  clut,  flags);
if (phtrail) return pc;
 
// apparently a right brace is still valid here, 
} // while 


return pc; 
} // ParseClean



////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
template <class Tm> 
IdxTy Parse(Tm & m, const char * p, const IdxTy len, ParseTable & clut, const IdxTy flags)
{
//MM_ERR(" new parse ")
if (len==0 ) return 0; 
if (true) return ParseClean(m,p,len,clut,flags); 
#if 0 

const StrTy type_name="type_name";
const StrTy name_name="name_name";
const StrTy leading_name="junk_name";
const Iv bvsmask=BIBVALS| m_val_mask;
const Iv bvmask=BIBVAL| m_val_mask;
const Iv keymask=BIBKEY|m_key_mask; // 2021

// a reusable assembly area hopefully 1k is normally enough...
RdBuf& rdb=m_rdb; //  rdb(10);
rdb.clear();
ParseState ps(p);

//IdxTy pc=0;
//IdxTy skipped=0;
//IdxTy braces=0;
//IdxTy state=HUNT;


IdxTy &  pc=ps.pc;
IdxTy &  skipped=ps.skipped;
int&  braces=ps.braces;
IdxTy &  state=ps.state;
ps.prd=&rdb;

//bool in_esc=false;
//bool in_comment=false;
char c=p[pc]; 
bool hunting_comment=false;
while (true) // while (Mask(state,HUNT)) 
{
// when the prior one is junk it gets tacked on here ... doh 
// 2021-07-15 clinical trial contact info in the value field unquotes
// ampersand in a value field is ok without esc yet makes a bif fck here
//const bool ignore =Mask(state,BESC|BCOMMENT|QUOTE);
if (c=='%') hunting_comment=true;
const bool ignore =hunting_comment||Mask(state,INVAL|BESC|BCOMMENT|QUOTE);
if ((!ignore)&&( c=='@'))
//{ rdb.cap(); m[leading_name]=rdb.string(); 
{ rdb.cap(); m.kv(leading_name,rdb.string(),0); 
  Trans(state,HUNT, INBIB|INTYPE );
break; // this avoids meaningless append but also inc lol 
 }  // state&=~HUNT; 
else ++skipped;
TransIf(state,BESC,(c=='\\')) ;

Iv v=m_clut.lut(c);
if(Mask(v,ParseTable::EOL)) 
{
hunting_comment=false;
Trans(state,BESC|QUOTE|BCOMMENT,0) ;
}
rdb.append(c);
if (Inc(pc,len))
{
// TODO not really an error will be apaprent on examination 
// m.kv("earlyend","end found before start",~0); 
 return pc; 
}

c=p[pc]; 
} // while true HUNT 

// the comments get eliminated although you have to wonder if that is
// a good idea. 
//rdb.clear();
rdb.start_new();
// now skipping inc after ampersand
if (Inc(pc,len)) 
{
 m.kv("earlyend","end found endtry ends ",~0); 
return pc; 
}
c=p[pc]; 

if (! CharOk(c,BIBTYPES,clut)) 
{ 
// m.kv("badtype","no good type found for the entry ",~0); 
CharCoS(m,"bad type",c,BIBTYPES,clut) ;return pc; } 
// string zero is the name
rdb.append(c);
// could return a blank name; 
// could use goto using reverse assign order  at exit lol 
// the state never changes now 
while (true) // while (Mask(state,INTYPE)) 
{
// oh this worked when the first string wsa there doh. 
//if (Inc(pc,len)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
//if (Inc(pc,len)){ rdb.cap(); m[type_name]=rdb.string_sane(0);     return pc;  } 
if (Inc(pc,len)){ 
rdb.cap(); m.kv(type_name,rdb.string_sane(0),1);     
return pc;  } 
c=p[pc]; 
//std::cerr<<c; 
if (! CharOk(c,BIBTYPE,clut)) 
{
// white space or '{' 
//SkipWS(p,pc,len,clut);
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string_sane(0);     return pc;  } 
if (SkipWS(p,pc,len,clut)){ rdb.cap(); m.kv(type_name,rdb.string_sane(0),2);     return pc;  } 
c=p[pc]; 
break;
} // CharOK
rdb.append(c);
} // INNAME
if (c=='{')
{
++braces;
// for now leave the entry in the read buffer for later analysis
// although popping the last complete one works too. 
//rdb.start_new(); m[type_name]=rdb.string(); 
//rdb.start_new(); m[type_name]=rdb.string_sane(0); 
rdb.start_new(); m.kv(type_name,rdb.string_sane(0),3); 
Trans(state,INTYPE,INNAME);
} // == }
else { 
// m.kv("badtype","need left brace to start name  ",~0); 
char fck[pc+2];
memcpy(fck,p,pc);
fck[pc]=0;
MM_ERR(MMPR(fck))
CharCoS(m," m1 need left brace to start name ",c,p,pc,len,state,braces) ;return pc; } 
// if there is nothing else, the name is null but braces unbalanced
if (Inc(pc,len))
{ 
// m.kv("earlyend","need right brace(s) to end entry  ",~0); 
CharCoS(m,"need right brace(s) to end entry  ",c,p,pc,len,state,braces) ; return pc;  } 

//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string(); return pc; } 
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string_sane(1); return pc; } 
if (SkipWS(p,pc,len,clut)){ rdb.cap(); m.kv(type_name,rdb.string_sane(1),4); return pc; } 
c=p[pc]; 
if (! CharOk(c,BIBNAMES,clut)) 
{ 
// m.kv("badchar","need name start char   ",~0); 
CharCoS(m,"need name start char here ",c,BIBNAMES|m_name_mask,clut) ;return pc; } 
rdb.append(c);
while (Mask(state,INNAME))
{
if (Inc(pc,len))
{ 
// m.kv("earlyend","need right brace(s) to end entry    ",~0); 
CharCoS(m,"need right brace(s) to end entry  ",c,p,pc,len,state,braces) ; return pc;  } 
c=p[pc]; 
if ((! CharOk(c,BIBNAME|m_name_mask,clut)) 
// latex seems ok with non-ascii citations names 
 && (CharOk(c,NONEXCEPTIONAL,clut)) )
{
rdb.start_new();
// the fist string is not marked, this is the first marked one. 
//m[name_name]=rdb.string_sane(0);
//m[name_name]=rdb.string_sane(1);
m.kv(name_name,rdb.string_sane(1),5);
break;
}
// keep non-ascii for now 
rdb.append(c);
} // INNAME;
if (SkipWS(p,pc,len,clut)) 
{ 
// m.kv("earlyend","need right brace(s) to end entry    ",~0); 
CharCoS(m,"need right brace(s) to end entry ",c,p,pc,len,state,braces) ; 
return pc;  } 
c=p[pc]; 
// this should be a comma
if (c!=','){ 
// m.kv("syntax","need comma after value  ",~0); 
 CharCoS(m,"need comma after value  ",c,p,pc,len,state,braces) ; 
return pc;  } 
Trans(state,INNAME,0);
IdxTy kvc=2; // added back in the comments in fromt 
if (Inc(pc,len)){ 
// m.kv("earlyend","need kv pair   ",~0); 
EarlyEnd(m," need kv pair   ",p,pc,state,braces);     return pc;  } 
// done later  c=p[pc]; 
// kv pair loop 
while (true)
{
if (SkipWS(p,pc,len,clut)) 
{ 
// m.kv("earlyend","need key or right brace(s) to end entry    ",~0); 
CharCoS(m,"key or right brace ",c,p,pc,len,state,braces) ; 
return pc;  } 
c=p[pc]; 
//////////////////////
// apaprently a right brace even after a comma is ok 
if (c=='}') { ++pc; return pc; } 
if (! CharOk(c,BIBKEYS|m_name_mask,clut)) 
{ 
//MM_MSG(" what the fck "<<MMPR(c))
char fck[pc+2];
memcpy(fck,p,pc);
fck[pc]=0;
MM_ERR(MMPR(fck))
CharCoS(m,"m1 need key start ",c,BIBKEYS|m_name_mask,clut) ;
// m.kv("needkey","need key start ",~0); 
return pc; } 
Trans(state,0,INKEY);
//rdb.start_new();
rdb.append(c);
// the state never changes here... 
while (true) // while (Mask(state,INKEY)) 
{
if (Inc(pc,len)){ EarlyEnd(m," eof ",p,pc,state,braces);   
// m.kv("earlyend","eof too early  ",~0); 
  return pc;  } 
c=p[pc]; 
//MM_ERR(MMPR4(c,int(c),state,INKEY))
if (! CharOk(c,BIBKEY|m_name_mask,clut)) 
{
// white space or '{' 
//SkipWS(p,pc,len,clut);
// not needed here 
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
rdb.start_new();
c=p[pc]; 
break;
} // CharOK
rdb.append(c);
} //BIBKEY 
// SkipWS already throws out trailing comments although not a good idea I guess 
if (SkipWS(p,pc,len,clut)){  EarlyEnd(m," eof ",p,pc,state,braces);    
// m.kv("earlyend","eof too early  ",~0); 
return pc;  } 
c=p[pc]; 
if (c!='=') { 
IdxTy pcx=(pc>20)?(pc-20):0;
//StrTy sd=StrTy(p+pcx,pc-pcx);
std::stringstream ss;
while (pcx<pc) { ss<<p[pcx]; ++pcx; } 
StrTy sd=ss.str(); // StrTy(p+pcx,pc-pcx);
MM_ERR(MMPR3(__FUNCTION__,pc,sd))
CharCoS(m,"need equals 1  ",c,0,clut) ;
// m.kv("syntax","need equals  ",~0); 
return pc; } 
if (Inc(pc,len)){ EarlyEnd(m," eof ",p,pc,state,braces);     
// m.kv("earlyend","eof too early  ",~0); 
return pc;  } 
if (SkipWS(p,pc,len,clut)){  EarlyEnd(m," eof ",p,pc,state,braces);    
// m.kv("earlyend","eof too early  ",~0); 
return pc;  } 
c=p[pc]; 
// this makes no sense here. 
//if (! CharOk(c,bvsmask,clut)) 
//{ CharCoS("need val start ",c,bvsmask,clut) ;return pc; } 

// the value continues up to a equals out of quote at braces==1
Trans(state,INKEY,INVAL);
//rdb.start_new();
// get rid of white space until quote or brace 
// this ws just done above 
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
//c=p[pc]; 

if ( c=='{' ) { ++braces; }
else if ( c=='\"' ) { Flip(state,QUOTE); }
else rdb.append(c);
while (true)  // bib value 
{
if (Inc(pc,len)){ EarlyEnd(m," eof ",p,pc,state,braces); 
// m.kv("earlyend","eof too early  ",~0); 
    return pc;  } 
c=p[pc]; 
//if (! CharOk(c,bvmask,clut)) { }
//if (SkipWS(p,pc,len,clut)){ rdb.cap(); m[type_name]=rdb.string();     return pc;  } 
//c=p[pc]; 
if (!Mask(state,BESC)) { 
// this does not need to be quoted, must end with brace or quote doh 
if (c==',') { if (braces==1)  if (!Mask(state,QUOTE)) break; } else 
if (( c=='{' )&&(!Mask(state,QUOTE))) 
{ ++braces; 
//continue; 
}
else if (( c=='}' )&&(!Mask(state,QUOTE))) { --braces;
// 
//if (braces<1) { EarlyEnd(" braces ",p,pc,state,braces);     return pc;  } 
if (braces<=1) break;
//continue; 
 }
else if (( c=='\"' )&&(!Mask(state,BESC))) { Flip(state,QUOTE); 
if (!Mask(state,QUOTE)&&(braces==1)) break; 
continue; }
else if (c=='\\') Trans(state,0,BESC);
} else {
// 2020-01-12 track the escaped crap for typos- see texhax list
if (( c=='}' )&&(!Mask(state,QUOTE))) { --ps.ubraces;
if (ps.ubraces<0) Observe(m, " user braces underflow ",ps);
} // right brace
else if (( c=='{' )&&(!Mask(state,QUOTE))) { ++ps.ubraces; } 
// end escaped tracking 
Trans(state,BESC,0); } 
rdb.append(c);

} // BIBVAL
rdb.start_new();
kvc+=2;
//m[rdb.string_sane(kvc-2)]=rdb.string_sane(kvc-1); 
//MM_ERR(MMPR3(kvc,rdb.string_sane(kvc-2),rdb.string_sane(kvc-1)))

m.kv(rdb.string_sane(kvc-2),rdb.string_sane(kvc-1),6); 
Trans(state,INVAL,0);
// the last brace needs to be consumed 
if (braces==0){ ++pc;    break; } 
// just find the one needed comma or right brace
while ((c!=','))
{
// the last 
if (Inc(pc,len)){ EarlyEnd(m," now comma or brace  ",p,pc,state,braces);  
// m.kv("earlyend","eof too early  ",~0); 
   return pc;  } 
// I think there has to be one comma so this will ignore that
// with zero or more. 
//if (SkipWS(p,pc,len,clut,WSTOSKIP|m_inter_kv))
if (SkipWS(p,pc,len,clut,WSTOSKIP))
//enum {WSTOSKIP=ParseTable::WHITE|ParseTable::EOL };
{EarlyEnd(m," looking for comma or brace   ",p,pc,state,braces);    
// m.kv("earlyend","looking for comma or brace  ",~0); 
  return pc;  } 
c=p[pc];
// the brace needs to be consumed 
if (c=='}') {  --braces; if (braces==0) { ++pc;  return pc; }  }
} // find comma
// then discard it 
if (Inc(pc,len)){ EarlyEnd(m," after comma   ",p,pc,state,braces);    
// m.kv("earlyend","after comma  ",~0); 
 return pc;  } 
// apparently a right brace is still valid here, 
} // while 

return pc; 
#else
return ~0;

#endif

} // Parse


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }

RdBuf m_rdb; //  rdb(10);
ParseTable m_clut;
Iv m_val_mask,m_inter_kv,m_name_mask;
Iv m_key_mask; // 2021-09-28

}; // mjm_bibtex_parse

//////////////////////////////////////////////

template <class Tr>
class mjm_bibtex_parse_map : public std::map<typename Tr::StrTy, mjm_bibtex_parse< Tr > >  
{
 typedef mjm_bibtex_parse_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bibtex_parse< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_parse_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{ 
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}


private:

}; // mjm_bibtex_parse_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIBTEX_PARSE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIBTEX_PARSE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bibtex_parse<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="parse") { x.parse(std::cout,cip.p1) ;}
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIBTEX_PARSE_H__ 
