#ifndef MJM_UNICODE_LATEX_H__
#define MJM_UNICODE_LATEX_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_collections.h"
#include "mjm_misc_parse.h"
#include "mjm_strings.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat Apr  9 09:41:23 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_unicode_latex   
// g++  -Wall -std=gnu++11 -DTEST_MJM_UNICODE_LATEX -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_unicode_latex.h  -o mjm_unicode_latex.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_unicode_latex("mjm_unicode_latex"
, " https://github.com/goerz/Refcards/blob/master/asciitable/ascii.tex  ");

template <class Tr>
class mjm_unicode_latex 
{
 typedef mjm_unicode_latex Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_ragged_table Ragged;

typedef mjm_var_parse<Tr> ParseTable;
enum {UC=ParseTable::UC, LC=ParseTable::LC, DIGIT=ParseTable::DIGIT };





public:
mjm_unicode_latex() {Init(); }
~mjm_unicode_latex() {}
StrTy latex(const int c) const { return Latex(c); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }

static int myatoi(const StrTy & s ) { return myatoi(s.c_str()); }
static int myatoi(const char * c) { return ::strtol(c,0,0); }



// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// https://github.com/goerz/Refcards/blob/master/asciitable/ascii.tex
typedef std::map<IdxTy, StrTy> DecMap;
typedef std::map<StrTy, StrTy> HexMap;

StrTy Latex(const int c) const { 
Ss ss;
ss<<LoadMaps(c);

return ss.str(); 

} // Latex

class _char_latex_desc
{
typedef std::vector<StrTy> Desc;
//IdxTy LoadXlate(const StrTy & fn, const IdxTy flags)
public:
_char_latex_desc(): m_u(~0) {}
_char_latex_desc(const IdxTy u, const StrTy & ltx, const StrTy & misc)
: m_u(u),m_latex(ltx),m_misc(misc) {}
_char_latex_desc(const IdxTy u, const StrTy & ltx, const StrTy& altcx,const StrTy & misc)
: m_u(u),m_latex(ltx),m_altcx(altcx),m_misc(misc) {}


_char_latex_desc(const IdxTy u, const StrTy & ltx, const Desc & d)
: m_u(u),m_latex(ltx),m_desc(d) {}
_char_latex_desc(const IdxTy u, const StrTy & ltx, const StrTy & x,const Desc & d)
: m_u(u),m_latex(ltx),m_altcx(x),m_desc(d) {}



const StrTy & latex() const { return m_latex;}
const StrTy & altcx() const { return m_altcx;}
const StrTy & something() const { return m_latex.length()?m_latex:m_altcx;}
StrTy dump() const
{
Ss ss;
ss<<MMPR(m_u)<< std::hex<<" hex " << MMPR4(m_u,m_latex,m_altcx,m_misc);
return ss.str();
} // dump

IdxTy m_u;
StrTy m_latex, m_altcx,m_misc;
Desc m_desc;
}; // _char_latex_desc
typedef _char_latex_desc char_latex_desc;

typedef std::map<IdxTy, char_latex_desc> ConvMap;





// 2440  more asciitable.tex  | grep "\\\\" | grep textit| sed -e 's/\\\\/ /g' | sed -e 's/.textit/ /g' |sed -e 's/\\/\\\\/g' | sed -e 's/"/\\"/g' | awk '{print "mdec["int($1)"]=\""$7"\"; mhex[\""$4"\"]=\""$7"\";"}' | myclip -paste
// 2441  vi mjm_unicode_latex.h 

StrTy LoadMaps(const int v) const
{
static DecMap mdec;
static HexMap mhex;
if (mdec.size()==0)
{

mdec[0]="\\NUL"; mhex["00"]="\\NUL";
mdec[1]="\\SOH"; mhex["01"]="\\SOH";
mdec[2]="\\STX"; mhex["02"]="\\STX";
mdec[3]="\\ETX"; mhex["03"]="\\ETX";
mdec[4]="\\EOT"; mhex["04"]="\\EOT";
mdec[5]="\\ENQ"; mhex["05"]="\\ENQ";
mdec[6]="\\ACK"; mhex["06"]="\\ACK";
mdec[7]="\\BEL"; mhex["07"]="\\BEL";
mdec[8]="\\BS"; mhex["08"]="\\BS";
mdec[9]="~"; mhex["09"]="~";
mdec[10]="\\LF"; mhex["0A"]="\\LF";
mdec[11]="\\VT"; mhex["0B"]="\\VT";
mdec[12]="~"; mhex["0C"]="~";
mdec[13]="\\CR"; mhex["0D"]="\\CR";
mdec[14]="\\SO"; mhex["0E"]="\\SO";
mdec[15]="\\SI"; mhex["0F"]="\\SI";
mdec[16]="\\DLE"; mhex["10"]="\\DLE";
mdec[17]="\\DCa"; mhex["11"]="\\DCa";
mdec[18]="\\DCb"; mhex["12"]="\\DCb";
mdec[19]="\\DCc"; mhex["13"]="\\DCc";
mdec[20]="\\DCd"; mhex["14"]="\\DCd";
mdec[21]="\\NAK"; mhex["15"]="\\NAK";
mdec[22]="\\SYN"; mhex["16"]="\\SYN";
mdec[23]="\\ETB"; mhex["17"]="\\ETB";
mdec[24]="\\CAN"; mhex["18"]="\\CAN";
mdec[25]="\\EM"; mhex["19"]="\\EM";
mdec[26]="~"; mhex["1A"]="~";
mdec[27]="\\ESC"; mhex["1B"]="\\ESC";
mdec[28]="\\FS"; mhex["1C"]="\\FS";
mdec[29]="\\GS"; mhex["1D"]="\\GS";
mdec[30]="\\RS"; mhex["1E"]="\\RS";
mdec[31]="\\US"; mhex["1F"]="\\US";
mdec[32]="\\textvisiblespace"; mhex["20"]="\\textvisiblespace";
mdec[33]="!"; mhex["21"]="!";
mdec[34]="\""; mhex["22"]="\"";
mdec[35]="\\#"; mhex["23"]="\\#";
mdec[36]="\\$"; mhex["24"]="\\$";
mdec[37]="\\%"; mhex["25"]="\\%";
mdec[38]="\\&"; mhex["26"]="\\&";
mdec[39]="\\textquotesingle"; mhex["27"]="\\textquotesingle";
mdec[40]="("; mhex["28"]="(";
mdec[41]=")"; mhex["29"]=")";
mdec[42]="*"; mhex["2A"]="*";
mdec[43]="+"; mhex["2B"]="+";
mdec[44]="\\textquoteright"; mhex["2C"]="\\textquoteright";
mdec[45]="-"; mhex["2D"]="-";
mdec[46]="."; mhex["2E"]=".";
mdec[47]="/"; mhex["2F"]="/";
mdec[48]="0"; mhex["30"]="0";
mdec[49]="1"; mhex["31"]="1";
mdec[50]="2"; mhex["32"]="2";
mdec[51]="3"; mhex["33"]="3";
mdec[52]="4"; mhex["34"]="4";
mdec[53]="5"; mhex["35"]="5";
mdec[54]="6"; mhex["36"]="6";
mdec[55]="7"; mhex["37"]="7";
mdec[56]="8"; mhex["38"]="8";
mdec[57]="9"; mhex["39"]="9";
mdec[58]=":"; mhex["3A"]=":";
mdec[59]=";"; mhex["3B"]=";";
mdec[60]="<"; mhex["3C"]="<";
mdec[61]="="; mhex["3D"]="=";
mdec[62]=">"; mhex["3E"]=">";
mdec[63]="?"; mhex["3F"]="?";
mdec[64]="@"; mhex["40"]="@";
mdec[65]="A"; mhex["41"]="A";
mdec[66]="B"; mhex["42"]="B";
mdec[67]="C"; mhex["43"]="C";
mdec[68]="D"; mhex["44"]="D";
mdec[69]="E"; mhex["45"]="E";
mdec[70]="F"; mhex["46"]="F";
mdec[71]="G"; mhex["47"]="G";
mdec[72]="H"; mhex["48"]="H";
mdec[73]="I"; mhex["49"]="I";
mdec[74]="J"; mhex["4A"]="J";
mdec[75]="K"; mhex["4B"]="K";
mdec[76]="L"; mhex["4C"]="L";
mdec[77]="M"; mhex["4D"]="M";
mdec[78]="N"; mhex["4E"]="N";
mdec[79]="O"; mhex["4F"]="O";
mdec[80]="P"; mhex["50"]="P";
mdec[81]="Q"; mhex["51"]="Q";
mdec[82]="R"; mhex["52"]="R";
mdec[83]="S"; mhex["53"]="S";
mdec[84]="T"; mhex["54"]="T";
mdec[85]="U"; mhex["55"]="U";
mdec[86]="V"; mhex["56"]="V";
mdec[87]="W"; mhex["57"]="W";
mdec[88]="X"; mhex["58"]="X";
mdec[89]="Y"; mhex["59"]="Y";
mdec[90]="Z"; mhex["5A"]="Z";
mdec[91]="["; mhex["5B"]="[";
mdec[92]="\\char`"; mhex["5C"]="\\char`";
mdec[93]="]"; mhex["5D"]="]";
mdec[94]="\\^{}"; mhex["5E"]="\\^{}";
mdec[95]="\\char`\\_"; mhex["5F"]="\\char`\\_";
mdec[96]="\\textquoteleft"; mhex["60"]="\\textquoteleft";
mdec[97]="a"; mhex["61"]="a";
mdec[98]="b"; mhex["62"]="b";
mdec[99]="c"; mhex["63"]="c";
mdec[100]="d"; mhex["64"]="d";
mdec[101]="e"; mhex["65"]="e";
mdec[102]="f"; mhex["66"]="f";
mdec[103]="g"; mhex["67"]="g";
mdec[104]="h"; mhex["68"]="h";
mdec[105]="i"; mhex["69"]="i";
mdec[106]="j"; mhex["6A"]="j";
mdec[107]="k"; mhex["6B"]="k";
mdec[108]="l"; mhex["6C"]="l";
mdec[109]="m"; mhex["6D"]="m";
mdec[110]="n"; mhex["6E"]="n";
mdec[111]="o"; mhex["6F"]="o";
mdec[112]="p"; mhex["70"]="p";
mdec[113]="q"; mhex["71"]="q";
mdec[114]="r"; mhex["72"]="r";
mdec[115]="s"; mhex["73"]="s";
mdec[116]="t"; mhex["74"]="t";
mdec[117]="u"; mhex["75"]="u";
mdec[118]="v"; mhex["76"]="v";
mdec[119]="w"; mhex["77"]="w";
mdec[120]="x"; mhex["78"]="x";
mdec[121]="y"; mhex["79"]="y";
mdec[122]="z"; mhex["7A"]="z";
mdec[123]="\\char`\\{"; mhex["7B"]="\\char`\\{";
mdec[124]="|"; mhex["7C"]="|";
mdec[125]="\\char`\\}"; mhex["7D"]="\\char`\\}";
mdec[126]="\\~{}"; mhex["7E"]="\\~{}";
mdec[127]="\\DEL"; mhex["7F"]="\\DEL";
mdec[128]="~"; mhex["80"]="~";
mdec[129]="~"; mhex["81"]="~";
mdec[130]="~"; mhex["82"]="~";
mdec[131]="~"; mhex["83"]="~";
mdec[132]="~"; mhex["84"]="~";
mdec[133]="~"; mhex["85"]="~";
mdec[134]="~"; mhex["86"]="~";
mdec[135]="~"; mhex["87"]="~";
mdec[136]="~"; mhex["88"]="~";
mdec[137]="~"; mhex["89"]="~";
mdec[138]="~"; mhex["8A"]="~";
mdec[139]="~"; mhex["8B"]="~";
mdec[140]="~"; mhex["8C"]="~";
mdec[141]="~"; mhex["8D"]="~";
mdec[142]="~"; mhex["8E"]="~";
mdec[143]="~"; mhex["8F"]="~";
mdec[144]="~"; mhex["90"]="~";
mdec[145]="~"; mhex["91"]="~";
mdec[146]="~"; mhex["92"]="~";
mdec[147]="~"; mhex["93"]="~";
mdec[148]="~"; mhex["94"]="~";
mdec[149]="~"; mhex["95"]="~";
mdec[150]="~"; mhex["96"]="~";
mdec[151]="~"; mhex["97"]="~";
mdec[152]="~"; mhex["98"]="~";
mdec[153]="~"; mhex["99"]="~";
mdec[154]="~"; mhex["9A"]="~";
mdec[155]="~"; mhex["9B"]="~";
mdec[156]="~"; mhex["9C"]="~";
mdec[157]="~"; mhex["9D"]="~";
mdec[158]="~"; mhex["9E"]="~";
mdec[159]="~"; mhex["9F"]="~";
mdec[160]="\\NBSP"; mhex["A0"]="\\NBSP";
mdec[161]="!`"; mhex["A1"]="!`";
mdec[162]="\\textcent"; mhex["A2"]="\\textcent";
mdec[163]="\\pounds"; mhex["A3"]="\\pounds";
mdec[164]="\\textcurrency"; mhex["A4"]="\\textcurrency";
mdec[165]="\\textyen"; mhex["A5"]="\\textyen";
mdec[166]="\\textbrokenbar"; mhex["A6"]="\\textbrokenbar";
mdec[167]="\\S"; mhex["A7"]="\\S";
mdec[168]="\\textasciidieresis"; mhex["A8"]="\\textasciidieresis";
mdec[169]="\\textrm{\\small\\textcopyright}"; mhex["A9"]="\\textrm{\\small\\textcopyright}";
mdec[170]="\\textordfeminine"; mhex["AA"]="\\textordfeminine";
mdec[171]="\\guillemotleft"; mhex["AB"]="\\guillemotleft";
mdec[172]="\\textlnot"; mhex["AC"]="\\textlnot";
mdec[173]="\\-"; mhex["AD"]="\\-";
mdec[174]="\\textrm{\\small\\textregistered}"; mhex["AE"]="\\textrm{\\small\\textregistered}";
mdec[175]="\\textasciimacron"; mhex["AF"]="\\textasciimacron";
mdec[176]="\\textdegree"; mhex["B0"]="\\textdegree";
mdec[177]="\\textpm"; mhex["B1"]="\\textpm";
//mdec[178]="\\texttwosuperior"; mhex["B2"]="\\texttwosuperior";
mdec[178]="$^{2+}$"; mhex["B2"]="$^{2+}$";
mdec[179]="\\textthreesuperior"; mhex["B3"]="\\textthreesuperior";
mdec[180]="\\textasciiacute"; mhex["B4"]="\\textasciiacute";
mdec[181]="\\textmu"; mhex["B5"]="\\textmu";
mdec[182]="\\P"; mhex["B6"]="\\P";
mdec[183]="\\textperiodcentered"; mhex["B7"]="\\textperiodcentered";
mdec[184]="\\c{}"; mhex["B8"]="\\c{}";
mdec[185]="\\textonesuperior"; mhex["B9"]="\\textonesuperior";
mdec[186]="\\textordmasculine"; mhex["BA"]="\\textordmasculine";
mdec[187]="\\guillemotright"; mhex["BB"]="\\guillemotright";
mdec[188]="\\textonequarter"; mhex["BC"]="\\textonequarter";
mdec[189]="\\textonehalf"; mhex["BD"]="\\textonehalf";
mdec[190]="\\textthreequarters"; mhex["BE"]="\\textthreequarters";
mdec[191]="?`"; mhex["BF"]="?`";
mdec[192]="\\`{A}"; mhex["C0"]="\\`{A}";
mdec[193]="\\'{A}"; mhex["C1"]="\\'{A}";
mdec[194]="\\^{A}"; mhex["C2"]="\\^{A}";
mdec[195]="\\~{A}"; mhex["C3"]="\\~{A}";
mdec[196]="\\\"{A}"; mhex["C4"]="\\\"{A}";
mdec[197]="\\AA"; mhex["C5"]="\\AA";
mdec[198]="\\AE"; mhex["C6"]="\\AE";
mdec[199]="\\c{C}"; mhex["C7"]="\\c{C}";
mdec[200]="\\`{E}"; mhex["C8"]="\\`{E}";
mdec[201]="\\'{E}"; mhex["C9"]="\\'{E}";
mdec[202]="\\^{E}"; mhex["CA"]="\\^{E}";
mdec[203]="\\\"{E}"; mhex["CB"]="\\\"{E}";
mdec[204]="\\`{I}"; mhex["CC"]="\\`{I}";
mdec[205]="\\'{I}"; mhex["CD"]="\\'{I}";
mdec[206]="\\^{I}"; mhex["CE"]="\\^{I}";
mdec[207]="\\\"{I}"; mhex["CF"]="\\\"{I}";
mdec[208]="\\DH"; mhex["D0"]="\\DH";
mdec[209]="\\~{N}"; mhex["D1"]="\\~{N}";
mdec[210]="\\`{O}"; mhex["D2"]="\\`{O}";
mdec[211]="\\'{O}"; mhex["D3"]="\\'{O}";
mdec[212]="\\^{O}"; mhex["D4"]="\\^{O}";
mdec[213]="\\~{O}"; mhex["D5"]="\\~{O}";
mdec[214]="\\\"{O}"; mhex["D6"]="\\\"{O}";
mdec[215]="\\texttimes"; mhex["D7"]="\\texttimes";
mdec[216]="\\O"; mhex["D8"]="\\O";
mdec[217]="\\`{U}"; mhex["D9"]="\\`{U}";
mdec[218]="\\'{U}"; mhex["DA"]="\\'{U}";
mdec[219]="\\^{U}"; mhex["DB"]="\\^{U}";
mdec[220]="\\\"{U}"; mhex["DC"]="\\\"{U}";
mdec[221]="\\'{Y}"; mhex["DD"]="\\'{Y}";
mdec[222]="\\TH"; mhex["DE"]="\\TH";
mdec[223]="\\ss"; mhex["DF"]="\\ss";
mdec[224]="\\`{a}"; mhex["E0"]="\\`{a}";
mdec[225]="\\'{a}"; mhex["E1"]="\\'{a}";
mdec[226]="\\^{a}"; mhex["E2"]="\\^{a}";
mdec[227]="\\~{a}"; mhex["E3"]="\\~{a}";
mdec[228]="\\\"{a}"; mhex["E4"]="\\\"{a}";
mdec[229]="\\aa"; mhex["E5"]="\\aa";
mdec[230]="\\ae"; mhex["E6"]="\\ae";
mdec[231]="\\c{c}"; mhex["E7"]="\\c{c}";
mdec[232]="\\`{e}"; mhex["E8"]="\\`{e}";
mdec[233]="\\'{e}"; mhex["E9"]="\\'{e}";
mdec[234]="\\^{e}"; mhex["EA"]="\\^{e}";
mdec[235]="\\\"{e}"; mhex["EB"]="\\\"{e}";
mdec[236]="\\`{i}"; mhex["EC"]="\\`{i}";
mdec[237]="\\'{i}"; mhex["ED"]="\\'{i}";
mdec[238]="\\^{i}"; mhex["EE"]="\\^{i}";
mdec[239]="\\\"{i}"; mhex["EF"]="\\\"{i}";
mdec[240]="\\dh"; mhex["F0"]="\\dh";
mdec[241]="\\~{n}"; mhex["F1"]="\\~{n}";
mdec[242]="\\`{o}"; mhex["F2"]="\\`{o}";
mdec[243]="\\'{o}"; mhex["F3"]="\\'{o}";
mdec[244]="\\^{o}"; mhex["F4"]="\\^{o}";
mdec[245]="\\~{o}"; mhex["F5"]="\\~{o}";
mdec[246]="\\\"{o}"; mhex["F6"]="\\\"{o}";
mdec[247]="\\textdiv"; mhex["F7"]="\\textdiv";
mdec[248]="\\o"; mhex["F8"]="\\o";
mdec[249]="\\`{u}"; mhex["F9"]="\\`{u}";
mdec[250]="\\'{u}"; mhex["FA"]="\\'{u}";
mdec[251]="\\^{u}"; mhex["FB"]="\\^{u}";
mdec[252]="\\\"{u}"; mhex["FC"]="\\\"{u}";
mdec[253]="\\'{y}"; mhex["FD"]="\\'{y}";
mdec[254]="\\th"; mhex["FE"]="\\th";
mdec[255]="\\\"{y}"; mhex["FF"]="\\\"{y}";

// https://www.codetable.net/decimal/8216
// close enoughs 
// https://www.fileformat.info/info/unicode/char/2074/index.htm
//Encodings
//HTML Entity (decimal)	&#8308;
//HTML Entity (hex)	&#x2074;

mdec[8211]="-"; mhex["2013"]="-";

mdec[8216]="\'"; mhex["2018"]="\'";
mdec[8217]="\'"; mhex["2019"]="\'";
mdec[8239]=""; mhex["202F"]=""; // nbsp 
mdec[8308]="$^{4+}$"; mhex["2074"]="$^{4+}$";
} // size ==0 
auto ii=mdec.find(v);
if (ii!=mdec.end())
{
MM_ERR(MMPR(v)<<std::hex<<MMPR2(v,(*ii).second))
 return (*ii).second;
}

//if (ii==mdec.end()) return StrTy();
auto jj=m_conv->find(v);
// { ++n;  ss<<"Ux"<< std::setfill('0') << std::setw(4)<< std::hex<<(*ii); }

//if (jj!=m_conv->end())  return (*jj).second.latex();
if (jj!=m_conv->end())
{
MM_ERR(MMPR((*jj).second.dump()))
// "something" can be utf 8 
  //return (*jj).second.something();
  return (*jj).second.latex();
}
 Ss ss;
  ss<<"Ux"<< std::setfill('0') << std::setw(4)<< std::hex<<(v); 
return ss.str(); //  (*jj).second.latex();
} // LoadMaps


// this is great but not complete. .. 
IdxTy LoadXlate(const StrTy & fn, const IdxTy flags)
{
ConvMap & conv=*m_conv;
// http://milde.users.sourceforge.net/LUCR/Math/data/unimathsymbols.txt
Ragged r;
r.load_params(1,0,"^");
r.load(fn,0);
MM_ERR(r.dump())
for(IdxTy i=0; i<r.size(); ++i)
{
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
if (len<3) continue;
if (l[0].c_str()[0]=='#') continue;
if (l[0].length()!=5) continue;
const IdxTy u=myatoi(StrTy("0x"+l[0]));
const StrTy & latex=l[3];
const StrTy & altcx=l[1];
//StrTy desc="";
//for(IdxTy j=3; j<len; ++j) desc+=l[j]+" ";
//char_latex_desc cld(u,latex,l);
char_latex_desc cld(u,latex,altcx,l);
conv[u]=cld;
MM_ERR(MMPR2(i,cld.dump()))
} // i 

return 0;
}

void Init()
{
m_conv=&Conv();
const StrTy fn="/home/documents/cpp/proj/toobib/unimathsymbols.txt";
if (m_conv->size()==0) LoadXlate(fn,0);

} // Init 

ConvMap & Conv()
{
static ConvMap m;
return m;
}


// MEMBERS
 ConvMap* m_conv;


}; // mjm_unicode_latex

//////////////////////////////////////////////

template <class Tr>
class mjm_unicode_latex_map : public std::map<typename Tr::StrTy, mjm_unicode_latex< Tr > >  
{
 typedef mjm_unicode_latex_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_unicode_latex< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_unicode_latex_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }

// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_unicode_latex_map




////////////////////////////////////////////
#ifdef  TEST_MJM_UNICODE_LATEX
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_unicode_latex <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_UNICODE_LATEX "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_unicode_latex<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_UNICODE_LATEX_H__ 
