#ifndef MJM_BIBTEX_FIND_H__
#define MJM_BIBTEX_FIND_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

// order is temporary get required includes in righ file 
#include "mjm_bibtex_motif.h"
#include "mjm_temp_progress.h"
#include "mjm_partial_cache.h"
#include "mjm_bibtex_features.h"
#include "mjm_blob.h"
#include "mjm_read_buffer.h"
#include "mjm_misc_parse.h"
#include "mjm_bibtex_entry.h"
#include "mjm_bibtex_parse.h"
// instead of pawnoff
#include "mjm_ext_things.h"
#include "mjm_collections.h"
#include "mjm_generic_iterators.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


#include "mjm_read_buffer.h"

// Tue Nov 19 06:57:30 EST 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibtex_find   
// g++ -std=gnu++11 -DTEST_MJM_BIBTEX_FIND -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibtex_find.h  -lpthread -lreadline

template <class Tr>
class mjm_bibtex_find 
{
 typedef mjm_bibtex_find Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef char Ch; 
typedef std::vector<StrTy> Vec;

typedef mjm_read_buffer<Tr> RdBuf;
typedef mjm_ext_things<Tr> ExtThings;
typedef mjm_bibtex_features<Tr> Features;
typedef std::map<StrTy, StrTy> Pmap;
typedef std::map<StrTy, IdxTy> Imap;
typedef mjm_partial_cache<Tr> ProgCache;
typedef mjm_ragged_table Ragged;
typedef mjm_blob<Tr> Blob;
typedef std::map<StrTy, Blob> BlobMap;

//template <class Key, class Value,int Zero=0>
//class mjm_vector_map_iter
#if 0 
#endif

//typedef temp_progress TempProg;
typedef mjm_temp_progress<Tr> TempProg;
typedef typename  TempProg::bib_map BibMap;
typedef typename  TempProg::bib_vector BibVector;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;
typedef mjm_bibtex_motif<Tr> Motif;
public:
mjm_bibtex_find() {}
~mjm_bibtex_find() {}

StrTy find(const StrTy & url,const IdxTy flags) { return Find(url,flags); }
IdxTy save(const StrTy & fn, const IdxTy flags){return Save(fn, flags);} 
IdxTy output( OsTy & os, const IdxTy flags){return Output(os, flags);} 
StrTy get_doi(const StrTy &doi) { return GetDoi(doi); } 


StrTy dump(const IdxTy flags=0) { return Dump(flags); }


private:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

template<class M > 
void CountUniq(M& m, const Vec & v) { MM_LOOP(ii,v) { ++m[(*ii)];}}

bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }

template <class M >
IdxTy SetColon(M & m , const StrTy &  k, const Ragged::Line & l, const IdxTy len)
{
m[k]="";
IdxTy i=0;
for(; i<len; ++i) { if (l[i]==":") break; } 
++i;
while(i<len) {if (l[i].length()!=0)  { m[k]+=l[i]; break; } ++i; }
++i;
for(; i<len; ++i) { if (l[i].length()!=0) m[k]+=StrTy(" ")+l[i]; }
return 0;
}

template <class M >
IdxTy Exif(M & m , Blob & ex, const Blob & s )
{
m_ext.exif_info(ex,s,StrTy(""));
//MM_ERR(MMPR(ex.dump()))
Ragged r;
Ss ss;
ss.write(ex.ptr(),ex.size());
// load_lines allows the reader to be configured
//r.sep(":");
//r.splitter(0);
// this loads as a single fcking line shut fck 
//r.load_lines(ss,true);
r.load(ss,!true);
//MM_ERR(r.dump(0))
const IdxTy sz=r.size();
// the exif format will not easily convert to a map, just kluge here 
for(IdxTy i=0; i<sz; ++i)
{
const Ragged::Line & l=r.line(i);
const IdxTy len=l.size();
//MM_ERR(MMPR3(i,len,l[0]))
if (len<3) continue;
if (l[0]=="File") if (l[1]=="Type")if (l[2]=="") { SetColon(m,StrTy("type"),l,len); continue; } 
if (l[0]=="Author") if (l[1]=="") { SetColon(m,StrTy("author"),l,len); continue; } 
if (strncmp(l[0].c_str(),"x-bibtex",8)==0) if (l[1]=="") { SetColon(m,StrTy(l[0].c_str()+8),l,len); continue; } 


}
//MM_LOOP(ii,m) { MM_ERR(MMPR2((*ii).first,(*ii).second)) } 
return 0;
}

// thing is either a doi or url, url used to be uin in the med2bib script  
// the flags could indicate doi, dos2unix, htmldecode, etc 
// flags : 0 - is_url_not_doi , 1 - skip analyze test results
void GetAndTest(BibMap & bm, const StrTy & handler, const StrTy & url, const StrTy & thing, const IdxTy flags)
{
const bool do_grep=!Bit(flags,1);
const bool debug=Bit(flags,0);
bm["srcurl"]=url;
bm["handler"]=handler;
//StrTy bib= GetDoi(bm,thing);
StrTy bib= GetABib(bm,thing,flags);
//MM_ERR(MMPR(bib))
const StrTy result=TestBib(bib);
bm[" test_result"]=result;
if (debug)
{
MM_ERR(MMPR(bib))
MM_ERR(MMPR(result))

}
//m_prog.bibs("pdfpagedoi").push_back(bm);
m_prog.bibs(handler).push_back(bm);
if (do_grep) GrepTestResults(bm,result,flags);
} // GetAndTest

IdxTy GrepTestResults(BibMap & bm, const StrTy & result, const IdxTy flags)
{
Blob bg;
m_ext.grep(bg,Blob(result), " -A 20 References | grep \"[a-zA-Z]\"");
if (bg.size()==0) 
{
m_ext.grep(bg,Blob(result), " -i  -B 2 -A 2 \"error\\|warning\"  ");
MM_ERR(StrTy(bg))
} else MM_ERR(StrTy(bg))

return 0;
} //  GrepTestResults

void FindInPDF(const StrTy & url,const IdxTy flags)
{

const bool debug_flag=Bit(flags,0);
Blob & p2t=m_prog.page("pdftotext");
//MM_ERR(" have blob "<<MMPR(p2t.size()))
m_ext.pdftotext(p2t,m_prog.page(),"");
//MM_ERR(" have made  blob "<<MMPR(p2t.size()))
GetDoiBibs(p2t,"pdf",flags);
/*
CheckForDoi(m_prog, p2t,"pdf");
if ( debug_flag ) { MM_ERR(" now dumping ")
m_prog.dump_dois("pdf"); }

Imap m;
CountUniq(m,m_prog.dois("pdf"));
BibMap bm;
if (m.size()!=0)
{
auto ii=m_prog.dois("pdf").begin();
// do grep if bit 1 is zero 
GetAndTest(bm, "pdfpagedoi", url, (*ii), flags);
}
*/

//BibEntryMap bem;
//ParseBib(bem,bm);
}



void FindInPDFOld(const StrTy & url,const IdxTy flags)
{

Blob & p2t=m_prog.page("pdftotext");
//MM_ERR(" have blob "<<MMPR(p2t.size()))
m_ext.pdftotext(p2t,m_prog.page(),"");
//MM_ERR(" have made  blob "<<MMPR(p2t.size()))
CheckForDoi(m_prog, p2t,"pdf");
//MM_ERR(" now dumping ")
//m_prog.dump_dois("pdf");
Imap m;
CountUniq(m,m_prog.dois("pdf"));
//if (m.size()==1)
BibMap bm;
if (m.size()!=0)
{
auto ii=m_prog.dois("pdf").begin();
// do grep if bit 1 is zero 
GetAndTest(bm, "pdfpagedoi", url, (*ii), flags);
}
//void GetAndTest(BibMap & bm, const StrTy & handler, const StrTy & url, const StrTy & thing, const IdxTy flags)
//IdxTy GrepTestResults(BibMap & bm, const StrTy & result, const IdxTy flags)

/*
if (m.size()!=0)
{
auto ii=//m.begin();
 	m_prog.dois("pdf").begin();
BibMap bm;
bm["srcurl"]=url;
bm["handler"]="pdfpagedoi";
//StrTy bib= GetDoi(bm,(*ii).first);
StrTy bib= GetDoi(bm,(*ii));
//MM_ERR(bib);
// note this could include multiple bibs. 
const StrTy result=TestBib(bib);
// " " means do not include
bm[" test_result"]=result;
m_prog.bibs("pdfpagedoi").push_back(bm);
Blob bg;
m_ext.grep(bg,Blob(result), " -A 20 References");
if (bg.size()==0) 
{
m_ext.grep(bg,Blob(result), " -i  -B 2 -A 2 \"error\\|warning\"  ");
MM_ERR(StrTy(bg))
} else MM_ERR(StrTy(bg))

BibEntryMap bem;
ParseBib(bem,bm);

}

*/

}



void FindInHTML(const StrTy & url,const IdxTy flags)
{
const bool debug_flag=Bit(flags,0);
const StrTy page=m_prog.page();

//const StrTy page=m_ext.get_url(url,1);


GetDoiBibs(page,"page",flags);
/*

const IdxTy ndoi_page=CheckForDoi( m_prog,page,"page");
if (debug_flag) { MM_ERR(" page dois "<<MMPR2(ndoi_page,page.size())) 
m_prog.dump_dois("page"); }
Imap m;
CountUniq(m,m_prog.dois("page"));

BibMap bm;
if (m.size()!=0)
{
auto ii=m_prog.dois("page").begin();
// do grep if bit 1 is zero 
GetAndTest(bm, "htmlpagedoi", url, (*ii), flags);
}

*/


//BibEntryMap bem;
//ParseBib(bem,bm);

//const auto & v = m_prog.dois("page");
//MM_LOOP(ii,v) { MM_ERR("page doi "<<MMPR((*ii))) } 
// wonderful this does not work for binary data doh
const StrTy plinks=m_ext.html_info(page,url);
//MM_ERR(MMPR(plinks));
Vec links;
// this contains all text lines right now, need to assemble
// the things like meta tags etc. 
IsolateLinks(links,plinks);
if ( debug_flag) { MM_ERR(MMPR2(links.size(),plinks.size())) } 

//MM_LOOP(ii,links) { MM_ERR(" link "<<MMPR(*ii)) } 

}
IdxTy Save(const StrTy & fn, const IdxTy flags)
{

return 0; 
}
IdxTy Output(OsTy & os, const IdxTy flags)
{
bool to_clip=Bit(flags,0);
bool to_cout=Bit(flags,1);
bool debug=Bit(flags,2);
if (debug) { MM_ERR(" Output "<<MMPR(m_prog.bibs().size())) } 
//BibVector & bv = m_prog.bibs("pdfpagedoi");
//const IdxTy szpdf=bv.size();
BibEntryMap bem;
typedef typename TempProg::bibs_iter bibs_iter;
// & begin() { return m_bibs.begin(); } 
bibs_iter ii=m_prog.begin();
//bibs_iter ee=m_prog.end();

while (ii) {
//const StrTy & vnm =(*ii).first; //  m_prog.bibs("pdfpagedoi");
//BibVector & bv =(*ii).second; //  m_prog.bibs("pdfpagedoi");
//MM_LOOP(jj,bv)
//{
//BibMap & bm=(*jj);
ParseBib(bem,(*ii));
//}
++ii; }
os<<bem.dump(0);
/*
if (false) // if (szpdf!=0) 
{
BibMap & bm=bv[0];
ParseBib(bem,bm);
os<<bem.dump(0);
}
//else MM_ERR(" nothing to output ")
*/

//if (to_clip) 
{
StrTy cites="";
auto ii=bem.begin();
//auto ee=bem.end();
//while ( ii!=ee ) { 
while ( ii ) { 
// these should all have the same name but if not bomb... 
//const StrTy nm=(*ii).second[0].name();  
const StrTy nm=(*ii).name();  
//const StrTy nmf=(*ii).first;  
const StrTy nmf=ii.key();  
//MM_ERR(MMPR(nmf))
cites=cites+StrTy("\\cite{") + nm+"}";
++ii;  }
if (to_cout) { MM_MSG(cites); } 
//if (to_cout) { std::cout<<cites; } 
if (to_clip){
 m_ext.put_clipboard(cites);
MM_ERR(" clipboard is now  "<<cites)
}}
return 0; 
}

IdxTy GetDoiBibs(const StrTy & src, const StrTy & lbl, const IdxTy flags)
{
const bool debug_flag=Bit(flags,0);
const IdxTy ndoi=CheckForDoi( m_prog,src,lbl);
if (debug_flag) { MM_ERR(" found "<<MMPR(ndoi)) } 
if ( ndoi!=0)
{
//m_prog.dump_dois("page"); }
Imap m;
CountUniq(m,m_prog.dois(lbl));
BibMap bm;
if (m.size()!=0)
{
auto ii=m_prog.dois(lbl).begin();
// do grep if bit 1 is zero 
StrTy l2=lbl+StrTy("doi");
GetAndTest(bm, l2, src, (*ii), flags);
}

} // ndoi 

return ndoi;
}

IdxTy CheckSuspects(const StrTy & src,const IdxTy flags)
{
while (true)
{
typename TempProg::suspect_type  x= m_prog.next_suspect();
if (!x.valid()) break;
BibMap bm;
GetAndTest(bm,x.handler(),src,x.thing(),x.flags());

}

return 0;
}

StrTy Find(const StrTy & url,const IdxTy flags)
{
const bool debug_flag=Bit(flags,0);
// bit 1 is to turn off grepping the test output for reference 
m_prog.clear();
m_prog.url(url);
GetDoiBibs(url,"url",flags);
/*
const IdxTy ndoi=CheckForDoi( m_prog,url,"url");
if (debug_flag) { MM_ERR(" found "<<MMPR(ndoi)) } 
if ( ndoi!=0)
{
//m_prog.dump_dois("page"); }
Imap m;
CountUniq(m,m_prog.dois("url"));
BibMap bm;
if (m.size()!=0)
{
auto ii=m_prog.dois("url").begin();
// do grep if bit 1 is zero 
GetAndTest(bm, "urldoi", url, (*ii), flags);
}

} // ndoi 
*/

m_ext.get_url(m_prog.page(),url,debug_flag?2:0);
std::map<StrTy,StrTy> exmap;
Exif(exmap,m_prog.page("exif"),m_prog.page());
if (exmap["type"]=="HTML") FindInHTML(url,flags);
else if (exmap["type"]=="PDF") FindInPDF(url,flags);
else 
{
MM_LOOP(ii,exmap) { MM_ERR(MMPR2((*ii).first, exmap[(*ii).first]))}

}
const bool check_motif=true| (m_prog.size()==0);
if (check_motif)
{
m_motif.check(m_prog,flags);
MM_ERR(MMPR(m_prog.nsuspects()))
// see if any suspects were added...
CheckSuspects("motif", flags);

}  // check_motif
const bool check_domain=true| (m_prog.size()==0);
if (check_domain)
{
m_motif.check_domains(m_prog,flags);
MM_ERR(MMPR(m_prog.nsuspects()))
// see if any suspects were added...
CheckSuspects("domains", flags);

}
MM_ERR(MMPR2(m_prog.size(),m_prog.nbibs()))

// validate chose and save bibtex 


return "";

} // Find




StrTy FindOld(const StrTy & url,const IdxTy flags)
{
const bool debug_flag=Bit(flags,0);
// bit 1 is to turn off grepping the test output for reference 
//ExtThings et;
//const StrTy x=m_ext.get_clipboard();
//MM_ERR(MMPR2(cmd,x))
//ExtThings et;
//const StrTy y=et.get_url(x,1);
m_prog.clear();

m_prog.url(url);

const IdxTy ndoi=CheckForDoi( m_prog,url,"url");
if (debug_flag) { MM_ERR(" found "<<MMPR(ndoi)) } 
//m_prog.dump_dois("url");


//{
//const auto & v = m_prog.dois("url");
//MM_LOOP(ii,v) { MM_ERR("url doi "<<MMPR((*ii))) } 
//}

// wonderful this does not work for binary data doh
// no pdf... 
// zero is for no redner

// first m_prog needs to load a restart file and 
// maintain a cache 
// this needs to get a binary file NOT a string. 

//const StrTy page=m_ext.get_url(url,0);
// flags: 0=return cmd, 1= debug conn, 2=print cm
m_ext.get_url(m_prog.page(),url,debug_flag?2:0);
// determine what this is, or maybe try again and get wget 
// server response headers 
// exitutil, pdftotext, strings etc 
// ASCII version 

std::map<StrTy,StrTy> exmap;
Exif(exmap,m_prog.page("exif"),m_prog.page());
if (exmap["type"]=="HTML") FindInHTML(url,flags);
if (exmap["type"]=="PDF") FindInPDF(url,flags);

//m_ext.exif_info(m_prog.page("exif"),m_prog.page(),StrTy(""));
//MM_ERR(MMPR(m_prog.page("exif").dump()))

// validate chose and save bibtex 


return "";

} // Find

// http://api.crossref.org/works/10.5555/12345678/transform/application/x-bibtex
StrTy GetDoiUrl(const StrTy &doi)
{
return "http://api.crossref.org/works/"+doi+"/transform/application/x-bibtex";
}
StrTy GetDoi(const StrTy &doi)
{
return m_ext.get_url(GetDoiUrl(doi),6&0);
}
StrTy GetDoi(BibMap & m, const StrTy &doi)
{
const StrTy url=GetDoiUrl(doi);
const StrTy bib= m_ext.get_url(url,6&0);
m["citeurl"]=url;
m["bibtex"]=bib;
m["date"]=m_ext.today();
return bib;
}

StrTy GetABib(BibMap & m, const StrTy &thing, const IdxTy flags) // , const StrTy & pd=StrTy() )
{
const bool is_doi=!Bit(0,flags);
const StrTy url=is_doi?GetDoiUrl(thing):thing;
const StrTy bib= m_ext.get_url(url,6&0);
m["citeurl"]=url;
m["bibtex"]=bib;
m["date"]=m_ext.today();
return bib;
}



IdxTy CheckForDoi(TempProg & prog, const StrTy & s,const StrTy & lbl)
{
IdxTy n=0;
IdxTy st=0;
IdxTy ed=0;
//IdxTy i=0;
const Ch * p=s.c_str();
while (true)
{
// the first ed is reference and the second is the value 
IdxTy rc=m_f.find_doi(st,ed,p,ed);
if (rc==0)
{ ++n;  m_prog.add_doi(lbl,p,st,ed); }
else break;
}
return n; 
}
void IsolateLinks(Vec & links,const StrTy & plinks)
{
m_f.to_eol(links, " text ",plinks);


}
#if 0 
IdxTy ParseURL(Pmap & m, const StrTy & s)
{

m_scratch.clear();
m_scratch.append(s);
m_scratch.cap();

m_scratch2.clear();
IdxTy i=0;
IdxTy state=~0;
const Ch * p=s.c_str();
while ( p[i]!=0)
{

++i;
}

return state; 
}
#endif
void ParseBib(BibEntryMap & bem, BibMap & m)
{
//typedef mjm_bibtex_parse<Tr> BibParse;
//typedef mjm_bibtex_entry<Tr> BibEntry;
//typedef mjm_bibtex_entry_map<Tr> BibEntryMap;
//m["citeurl"]=url; m["bibtex"]=bib; m["date"]=m_ext.today();
//BibParse bp;
//BibEntry be;
//BibEntryMap bem;
RdBuf rd;
MM_LOOP(ii,m)
{
const auto & k= (*ii).first;
// I thikn a spur is getting in... 
if (k.length()==0) continue;
//if ((*ii).first!="bibtex")
// use a leading space to delete entry from finished bib 
if ((k!="bibtex")&&(k.c_str()[0]!=' '))
{
Ss ss;
ss<<"% "<<(*ii).first<<" : "<<(*ii).second<<CRLF;
//MM_ERR(ss.str())
rd.append(ss.str());
}

}
//std::cerr.write(rd.ptr(),rd.size());
//MM_ERR("above was rd")

rd.append(m["bibtex"]);
//bp.parse(be,rd.ptr(),rd.size(),0);
//bm.parse(StrTy("pdfpage"),rd.ptr(),rd.size());
bem.parse(m["handler"],rd.ptr(),rd.size());
//MM_ERR(MMPR(be.dump(0)))
//MM_ERR("dukmping ")
//MM_ERR(bem.dump(0))
}
 StrTy TestBib(const StrTy & bib)
{
Blob bs(TestText(bib));
//MM_ERR(MMPR(StrTy(bs)))
Blob bd;
m_ext.test_latex(bd,bs,"");
// search for errors, and final output shold be the reference formatted
// but if not, keep entire thing somewhere. 
StrTy x=StrTy(bd);
//MM_ERR(MMPR(x))
return x;
}

StrTy TestText(const StrTy & bib )
{
Ss ss;
ss<<"\\documentclass{article}"<<CRLF;
ss<<"\\usepackage{hyperref}"<<CRLF;
ss<<"\\begin{filecontents}{mybibtemp.bib}"<<CRLF;
ss<<bib<<CRLF;
ss<<"\\end{filecontents}"<<CRLF;
ss<<"\\begin{document}"<<CRLF;
ss<<"\\nocite{*}"<<CRLF;
ss<<"\\bibliographystyle{plainurl}"<<CRLF;
ss<<"\\bibliography{mybibtemp}"<<CRLF;
ss<<"\\end{document}"<<CRLF;

return ss.str();
}




StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }



ExtThings m_ext;
TempProg m_prog;
Features m_f;
RdBuf m_scratch,m_scratch2;
Motif m_motif;

}; // mjm_bibtex_find

//////////////////////////////////////////////

template <class Tr>
class mjm_bibtex_find_map : public std::map<typename Tr::StrTy, mjm_bibtex_find< Tr > >  
{
 typedef mjm_bibtex_find_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bibtex_find< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bibtex_find_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bibtex_find_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIBTEX_FIND
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIBTEX_FIND "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bibtex_find<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIBTEX_FIND_H__ 
