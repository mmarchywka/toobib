#ifndef MJM_IDIOSYNCRATIC_SOURCE_LOCATOR_H__
#define MJM_IDIOSYNCRATIC_SOURCE_LOCATOR_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_strings.h"
#include "mjm_collections.h"
#include "mjm_cpp_regex.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Mon Jul 26 16:56:43 EDT 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_idiosyncratic_source_locator   
// g++  -Wall -std=gnu++11 -DTEST_MJM_IDIOSYNCRATIC_SOURCE_LOCATOR -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_idiosyncratic_source_locator.h  -lpthread -lreadline

template <class Tr>
class mjm_idiosyncratic_source_locator 
{
 typedef mjm_idiosyncratic_source_locator Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_cpp_regex::stuff MyRegex;

class _classifier_regex
{
_classifier_regex() {}
_classifier_regex(const StrTy & regex) {m_s=regex;}

public:
StrTy m_s;


}; // _classifier_regex

typedef _classifier_regex classifier_regex;
typedef std::map<StrTy , classifier_regex> Crx;
typedef std::map<StrTy, Crx> CrxMap;

class url_pieces
{
typedef std::vector<StrTy> V;
public:
// exact string broken into units by the 
// Ragged parser.. 
/*
1336|  |116|(|38|)|:|19126|-|-|19135|,| |2019|.
1337|\|newblock| |URL|:| |\|url|{|https|:|/|/|www|.|pnas|.|org|/|content|/|116|/|38|/|19126|}|,| |\|href
1338|  |{|http|:|/|/|arxiv|.|org|/|abs|/|https|:|/|/|www|.|pnas|.|org|/|content|/|116|/|38|/|19126|.|full|.|pdf|}
1339|  |{|\|path|{|arXiv|:|https|:|/|/|www|.|pnas|.|org|/|content|/|116|/|38|/|19126|.|full|.|pdf|}|}|,| |\|href
1340|  |{|http|:|/|/|dx|.|doi|.|org|/|10|.|1073|/|pnas|.|1909604116|}
1341|  |{|\|path|{|doi|:|10|.|1073|/|pnas|.|1909604116|}|}|.
1342
*/

url_pieces(const V & s) { Init(s); } 


void Init(const V & s)
{

} // Init

StrTy m_string;
StrTy m_proto;
StrTy m_fragment;
V m_domain, m_path, m_query;
}; // url_pieces


public:
mjm_idiosyncratic_source_locator() {Init(); }
mjm_idiosyncratic_source_locator(const StrTy & s ) {m_string=s; Init();}
~mjm_idiosyncratic_source_locator() {}
IdxTy parse(const IdxTy flags=0 ) { return Parse(flags); } 
const StrTy & domain() const  { return m_domain; } 
bool maybe_doi() const { return m_maybe_doi;}
const StrTy & doi() const { return m_doi;} 
bool local() {GuessType(m_string); return m_proto_file ||m_assume_file; } 
StrTy fs_path() { return FS_Path(); } 
bool http() const {
typedef mjm_strings StrUtil;
StrTy lc=StrUtil::fancy_to_lower(m_proto);
return (lc=="http")||(lc=="https"); 
}
bool ftp() const { return m_proto_ftp; } 
StrTy find_doi(const IdxTy flags) { return  FindDoi( flags); }
const StrTy&  fragment() const { return m_frag;}

Myt & operator=(const StrTy & that) { m_string=that; return *this; } 
operator const StrTy&() const { return m_string; } 
const char * c_str() const { return m_string.c_str(); } 
IdxTy load_crx(const StrTy & nm, const StrTy & fn) { return LoadCrx(nm,fn); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  

// MEMBERS
ss<<MMPR2(m_string, m_flags);
ss<<MMPR4(m_doi,m_proto, m_domain, m_pieces.size());
ss<<MMPR4( m_proto_http,m_proto_https,m_proto_ftp,m_proto_file);
ss<<MMPR3(m_frag,m_maybe_doi,m_assume_file);
//static CrxMap m_types;



return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

IdxTy LoadCrx(const StrTy & nm, const StrTy & fn) { 
IdxTy rc=0;
Ragged r;
// words, "1" code splitter, sep
r.load_params(1,1," ");
r.load(fn,1);
MM_ERR(r.dump())
for(IdxTy i=0; i<r.size(); ++i)
{

m_types[nm][r[i][0]]=classifier_regex(r[i][1]);

}

return rc; } 
/*
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=18 l[i]=10
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=19 l[i]=.
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=20 l[i]=1038
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=21 l[i]=@
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=22 l[i]=s
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=23 l[i]=41560
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=24 l[i]=-
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=25 l[i]=019
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=26 l[i]=-
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=27 l[i]=0404
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=28 l[i]=-
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=29 l[i]=4
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=30 l[i]=.
./mjm_idiosyncratic_source_locator.h147  __FUNCTION__=FindDoi i=31 l[i]=pdf


*/
StrTy FindDoi(const IdxTy flags)
{
StrTy z;
Ragged& r=m_pieces;
if (r.size()==0) return z;
IdxTy state=~0;
IdxTy start=0;
StrTy doix;
Ragged::Line  l=r[0]; // copy and modify 
MM_SZ_LOOP(i,l,szl)
{
MM_ERR(MMPR3(__FUNCTION__,i,l[i]))
const StrTy & w=l[i];
if (w=="doi")
{ // may need to stop a build in progrss... 

} 
if (state==~0) if (w=="/"){  state=0; continue;  } 
if (state==0) if (w=="10") {start=i; doix="10"; state=1; continue;  } 
if (state==1) if (w=="@") {doix+="/";  continue;  }  // dumb links... 
if (state==1) if (w=="?") {break;  }  // dumb links... 
if (state==1) if (w=="#") {break;  }  // dumb links... 
if (state==1) if (w=="&") {break;  }  // dumb links... 
if (state==1) if (w==".") {
if ((i+1)>=szl) { doix+=w; continue; }
if ( l[i+1]=="pdf") break;
doix+=w;
continue;
 }  // dumb links... 
if (state==1) doix+=w;
} // i
z=doix;
MM_ERR(MMPR(z))
return z;
} // FindDoi
StrTy FS_Path() { 
// remove file://
const char * p=m_string.c_str();
if (m_string.length()<8) return StrTy();
return  StrTy(p+7); 
} 

IdxTy Parse(const IdxTy flags ) { 
Ragged& r=m_pieces;
r.clear();
r.splitter(8);
Ss ss;
ss<<m_string;
r.load(ss,0);
if (r.size()==0) return 0;
Ragged::Line  l=r[0]; // copy and modify 
IdxTy lws=0;
while (lws<l.size()) { if (l[lws].c_str()[0]!=' ') break; ++lws; } 
Ragged::Line l2;
for(IdxTy i=lws; i<l.size(); ++i) { l2.push_back(l[i]); } 
l=l2;
const IdxTy sz=l.size();
IdxTy pos=0;
if (sz>=4 ) {
bool maybe_doi_or_file=(l[0]=="10")&&(l[1]==".")&&(l[3]=="/");
if (maybe_doi_or_file) 
{
m_maybe_doi=true;
m_doi=m_string;
}
bool psep=(l[1]==":")&&(l[2]=="/")&&(l[3]=="/");
if (psep) m_proto=l[0];
IdxTy ifirst=4;
if(sz>ifirst) if (l[ifirst]=="/") ++ifirst;
for(IdxTy i=ifirst; i<sz; ++i)
{
const StrTy & x=l[i];
const bool eod=(x=="/")||(x=="?")||(x=="#"); 
if (eod) break;
 m_domain+=l[i];
} // i 


} // >=4
// kluge to get the frag... 
typedef mjm_strings StrUtil;
const char * p=m_string.c_str();
int  fragpos=StrUtil::indexOf(p,"#");
if (fragpos>=0)
{
m_frag=StrTy(p+fragpos+1); // don't get hash 

}
return 0; 
} // Parse 

IdxTy GuessType(const StrTy & urlq) 
{
typedef mjm_strings StrUtil;
StrTy lc=StrUtil::fancy_to_lower(urlq);
const char * lcp=lc.c_str();

// first see if the url is actually a file...
// don't bother with case sensivity now it will fall thought lol 
// really should also trim crap as using quotes a lot 
const bool proto=(0==strncmp("http://",lcp,7));
const bool proto2=(0==strncmp("https://",lcp,8));
const bool protoftp=(0==strncmp("ftp://",lcp,8));
const bool proto_file=(0==strncmp("file://",lcp,7));
const bool assume_local=!proto&&!proto2&&!protoftp;
m_proto_http=proto;
m_proto_https=proto2;
m_proto_file=proto_file;
m_proto_ftp=protoftp;
m_assume_file=assume_local;


return 0; 
} // GuessType
void Init()
{
m_proto_http=false;
m_proto_https=false;
m_proto_ftp=false;
m_proto_file=false;
m_assume_file=false;
m_maybe_doi=false;
m_flags=0;

}

// MEMBERS
StrTy m_string;
IdxTy m_flags;

StrTy m_proto, m_domain,m_doi,m_frag;
Ragged m_pieces;

bool m_proto_http,m_proto_https,m_proto_ftp,m_proto_file,m_assume_file,m_maybe_doi;

static CrxMap m_types;

}; // mjm_idiosyncratic_source_locator

//////////////////////////////////////////////

template <class Tr>
class mjm_idiosyncratic_source_locator_map : public std::map<typename Tr::StrTy, mjm_idiosyncratic_source_locator< Tr > >  
{
 typedef mjm_idiosyncratic_source_locator_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_idiosyncratic_source_locator< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_idiosyncratic_source_locator_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_idiosyncratic_source_locator_map


namespace{
template <class Tr>  std::ostream & operator<<(std::ostream & os, const mjm_idiosyncratic_source_locator<Tr>  & x) {  os<<std::string(x); return os; } 
};




////////////////////////////////////////////
#ifdef  TEST_MJM_IDIOSYNCRATIC_SOURCE_LOCATOR
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_idiosyncratic_source_locator <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_IDIOSYNCRATIC_SOURCE_LOCATOR "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_idiosyncratic_source_locator<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_IDIOSYNCRATIC_SOURCE_LOCATOR_H__ 
