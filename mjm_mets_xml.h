#ifndef MJM_METS_XML_H__
#define MJM_METS_XML_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
// copied from bomtex and xref_json
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_strings.h"
#include "testHTML.h"
//#include <../mjsonu/mjsonu.h>

#include "mjm_hier_two.h"

//#include <../mjsonu/mjsonu.h>

#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_strings.h"




// Tue Feb  8 07:46:50 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_mets_xml   
//g++  -Wall -std=gnu++11 -DTEST_MJM_METS_XML -I. -I../../mjm/hlib -I../../mjm/num  -I /usr/include/libxml2  -gdwarf-3 -O0  -x c++ mjm_mets_xml.h  -lpthread -lreadline -lxml2 -Wno-unused-variable -Wno-unused-function
// g++  -Wall -std=gnu++11 -DTEST_MJM_METS_XML -I. -I../../mjm/hlib -I../../mjm/num  -I /usr/include/libxml2  -gdwarf-3 -O0  -x c++ mjm_mets_xml.h  -lpthread -lreadline -lxml2
// g++  -Wall -std=gnu++11 -DTEST_MJM_METS_XML -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mets_xml.h  -lpthread -lreadline

// -I /usr/include/libxml2 -I/home/documents/cpp/pkg/include  -gdwarf-3 -O0  -x c++ mjm_bomtex_json.h  -lpthread -lreadline -lxml2


template <class Tr>
class mjm_mets_xml 
{
 typedef mjm_mets_xml Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;


typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_ragged_cursor RaggedCursor;
typedef mjm_wovdb<Tr,StrTy> Tdb;
typedef mjm_hier_two<Tr> HierUtil;


//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_mets_xml() {}
~mjm_mets_xml() {}

StrTy mets_xform( const StrTy & fn, const IdxTy  flags) const
{
Ragged r;
IdxTy rc=load_ragged(r,fn,0);
std::map<StrTy,StrTy> m;
IdxTy rca=assemble(m,r,0);
StrTy s;
IdxTy rcf=format(s,m,0);
MM_ERR(MMPR(fn)<<MMPR4(s,m.size(),r.size(),rc))
return s;
} // crossref_xform


IdxTy load_ragged(Ragged & r, const StrTy & fn, const IdxTy  flags) const
{
//MM_MSG(" using integrated json for xref may not work doh ")
std::ifstream is(fn);
IdxTy rc=testHTML::parse_stream(r,is,0);
MM_ERR(r.dump())
return 0;
}


template <class Tm > IdxTy assemble(Tm & m, const Ragged & r,  const IdxTy  flags) const
{
return Assemble(m,r,flags);
}
template <class Tm > IdxTy format(StrTy & s, Tm & m,  const IdxTy  flags) const
{
return Format(s,m,flags);
}




StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// this seems to be hierarchial and may generate multiple
// entries. The raged could be chopped to one article v and h dirs
// or they can be partsed into a map of Tm;s.

/*
    
more asdf| grep -v filesec | grep "|119|"
53|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|120|type|121|text|personal
54|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|122|namepart|123|text|Hertz, Joel John
55|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|124|namepart|125|type|126|text|given
56|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|124|namepart|127|text|Joel John
57|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|128|namepart|129|type|130|text|family
58|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|128|namepart|131|text|Hertz
59|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|132|namepart|133|type|134|text|date
60|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|132|namepart|135|text|1926-
61|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|136|role|137|roleterm|138|text|Main Entity
33|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|77|genre|78|auth
ority|79|text|marcgt
34|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|77|genre|80|text
|bibliography
35|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|81|genre|82|auth
ority|83|text|marcgt
36|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|81|genre|84|text
|non-fiction
37|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|85|identifier|86
|type|87|text|ALEPH
38|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|85|identifier|88
|text|024250310
39|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|89|identifier|90
|type|91|text|OCLC
40|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|89|identifier|92
|text|25743313
41|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|93|identifier|94
|type|95|text|NOTIS
42|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|93|identifier|96
|text|AEK7303
43|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|97|identifier|98
|type|99|text|sobekcm
44|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|97|identifier|10
0|text|AA00004956_00001


53|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|120|type|121|text|personal
54|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|122|namepart|123|text|Hertz, Joel John
55|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|124|namepart|125|type|126|text|given
56|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|124|namepart|127|text|Joel John
57|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|128|namepart|129|type|130|text|family
58|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|128|namepart|131|text|Hertz
59|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|132|namepart|133|type|134|text|date
60|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|132|namepart|135|text|1926-
61|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|119|name|136|role|137|roleterm|138|text|Main Entity

*/

class _datafield
{
typedef std::map<StrTy,StrTy> DfKV;
public:
const StrTy & parse_id() const { return m_parser_id; } 
const StrTy & name() const { return m_name; } 
const StrTy & v() const { return m_v; } 
const StrTy & value() const { return m_v; } 
const StrTy & field(const StrTy & x) const {
const auto ii=m_map.find(x); if (ii!=m_map.end()) return (*ii).second; 
static StrTy y="";
 return y; } 
StrTy dump( const IdxTy flags=0) const { return Dump(flags); } 
// idcol points to a parser_id number for this entry, 
// idcol points to the parser node number, similar ones for the elements
IdxTy parse(const Ragged & r, IdxTy & i,const IdxTy sz, const IdxTy idcol, const IdxTy flags)
{
IdxTy rc=0;
const IdxTy lmin=idcol+3;
//StrTy sfid, sfk,sfv;
typedef std::map<StrTy, StrTy> Km;
Km keys,values;
while (i<sz)
{
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
if (len<lmin) { rc=1; break; } // return 1; 
const IdxTy off=(l[len-2]=="=")?1:0;
const StrTy& v=l[len-1];
const StrTy& type_or_key=l[len-4-off];
const StrTy & nid=l[idcol];
const StrTy & nname=l[idcol+1];
IdxTy inoff=4;
inoff=2;
const StrTy & innernid=l[idcol+inoff];
IdxTy thr=idcol+inoff+4+off+1;
if (nname=="origininfo") {  inoff=6; thr-=4; } 

if ((m_parser_id=="")) 
{ m_v=v; m_parser_id=l[idcol]; m_name=l[idcol+1]; ++i; 
//if (len>=thr) {  keys[innernid]+=type_or_key; values[innernid]+=v;  } 
continue; }
else if (m_parser_id!=l[idcol]) break; //  return 0; 
//mjm_mets_xml.h216 SHTSS0|1|html|3|body|4|p|8|mets|63|dmdsec|66|mdwrap|73|xmldata|74|mods|155|origininfo|163|dateissued|164|text|1954
//mjm_mets_xml.h217 SHTSS m_parser_id=155 len=23 thr=27 type_or_key=dateissued nid=155 nname=origininfo innernid=1954
Ss ss;
MM_LOOP(ii,l) {ss<<"|"<<(*ii) ; }
MM_ERR(" " << ss.str())
MM_ERR(" " << MMPR3(m_parser_id,len,thr)<<MMPR4(type_or_key,nid,nname,innernid))
if ( type_or_key=="type") keys[innernid]=v;
else {
// the value is always a value, the key matters 
if (len>thr) keys[innernid]+=type_or_key; 
values[innernid]+=v; 
}

/*
MM_ERR(MMPR4(len,v,l[idcol+1],l[idcol]))
if ((m_parser_id=="")) { m_v=v; m_parser_id=l[idcol]; m_name=l[idcol+1]; ++i; continue; }
else if (m_parser_id!=l[idcol]) break; //  return 0; 
// except now we have backed up doh  
if (( len-idcol)>4)
{
//m_map[l[idcol+3]]+=v;
IdxTy tc=4; // need to remove crap here ... 
m_map[l[len-off-tc]]+=v+" ";
++i;
continue;
}
// tis is the id of a group..
//const StrTy& f=l[idcol+3];
MM_ERR(" adfasdsf "<<MMPR4(f,v,idcol,l[idcol+3]))
if (f=="type") sfk=v;
else sfv=v;
if (sfk.length() &&sfv.length()){
 m_map[sfk]+=sfv+" ";
sfk=""; sfv="";
}
*/
++i;
} // i<sz
MM_LOOP(ii,keys) { m_map[(*ii).second]+=values[(*ii).first];}
MM_LOOP(ii,values) 
{if (keys.find(((*ii).first))==keys.end())
 m_map[keys[(*ii).first]]+=(*ii).second;
}

return 0; 
} // parse

StrTy Dump( const IdxTy flags=0) const 
{ 
Ss ss;
ss<<"DF0 "<<MMPR3(m_parser_id,m_name,m_v)<<CRLF;
MM_LOOP(ii,m_map) { ss<<"DF1 "<<MMPR3(m_parser_id,(*ii).first,(*ii).second)<<CRLF; } 
return ss.str(); 
} // Dump 

StrTy m_parser_id,m_name,m_v;
//StrTy m_tag,m_ind1,m_ind2;
DfKV m_map;

}; // _datafield
typedef _datafield datafield;
typedef datafield Df;
template <class Tm > IdxTy Assemble(Tm & _m, const Ragged & r,  const IdxTy  flags) const
{
IdxTy rc=0;
//typedef std::map<StrTy, Tm > Tmx;
typedef std::map<StrTy, Df > Tdfm;
//Tmx tmx;
Tdfm dfm;
const IdxTy sz=r.size();
IdxTy i=0;
IdxTy fickingparser=0;
while (i<sz)
{
const IdxTy izer=i;
const IdxTy len=r[i].size();
//1 html 3 body 4 collection 7 record 60 datafield 61 tag 62 text = 035
//IdxTy parse(const Ragged & r, IdxTy & i,const IdxTy sz, const IdxTy idcol, const IdxTy flags)
// the  parser puts in a "p" node when called form code
// but not command line  
fickingparser=0;
if (fickingparser==0) {
IdxTy pos=0; 
bool havexmldata=false;
MM_LOOP(ii,r[i])
{
if ((*ii)=="metshdr") {fickingparser=pos+1; break; } 
if ((*ii)=="xmldata") {havexmldata=true; } 
if (((*ii)=="mods")&&havexmldata) {
if (( pos+1<len)&& (Backup( r[i][pos+2]))) fickingparser=pos+1; else 
fickingparser=pos+3; break; } 
if (((*ii)=="etd")&&havexmldata) {
if (( pos+1<len)&& (Backup( r[i][pos+2]))) fickingparser=pos+1; else 
fickingparser=pos+3; break; } 



++pos;
}
 } // fickingparser=0
if (fickingparser==0) { ++i; continue; }
datafield df;
IdxTy rcdf=df.parse(r,i,sz,fickingparser,0);
MM_ERR(" asdfasdf "<<MMPR2(i,df.dump()))
dfm[df.parse_id()]=df;
if (i==izer) ++i;
} // i<sz
MM_LOOP(ii,dfm)
{
MM_ERR(MMPR2((*ii).first,(*ii).second.dump()))
} 
Tm & m=_m;
m["type-name"]="article";
m["name-name"]="xxx";
MM_LOOP(ii,dfm)
{
auto & df=(*ii).second;
if (df.name()=="identifier"){  m[df.value()]=df.field(""); continue; } 
if (df.name()=="titleinfo"){  m["title"]=df.field(""); continue; } 
if (df.name()=="language"){  m["language"]=df.field(""); continue; } 
if (df.name()=="name"){  AddAnd(m["author"],df.field("")); continue; } 
if (df.name()=="origininfo"){  AddAnd(m["date"],df.field("dateissued")); continue; } 
if (df.name()=="lastmoddate"){  AddAnd(m["updated_date"],df.v()); continue; } 
if (df.name()=="accesscondition"){  AddAnd(m["copyright"],df.v()); continue; } 
if (df.name()=="location"){  AddAnd(m["school"],df.v()); continue; } 
//if (df.name()=="note"){ if (df.v()=="thesis") m["type-name"]="thesis"; continue; } 
if (df.name()=="note"){ if (df.v()=="thesis") m["type"]="thesis"; continue; } 
if (df.name()=="committeemember"){  AddAnd(m["committee"],df.v()); continue; } 
if (df.name()=="committeechair"){  AddAnd(m["committee"],df.v()); continue; } 
if (df.name()=="degreediscipline"){  AddAnd(m["discipline"],df.v()); continue; } 
if (df.name()=="degreelevel"){  AddAnd(m["level"],df.v()); continue; } 
if (df.name()=="degreegrantor"){  AddAnd(m["institution"],df.v()); continue; } 

//MM_ERR(MMPR2((*ii).first,(*ii).second.dump()))
}  // 
return rc; 
} // Assemble 
void AddAnd(StrTy & d, const StrTy & s) const 
{
if (d!="") d+=" and ";
d+=s;
}
bool Backup(const StrTy & s) const
{
//if ( s=="name") return true;
//if ( s=="identifier") return true;

return !false;
}
#if 0 
const IdxTy aid_pos=4; // aritcle node id pos
const IdxTy kid_pos=11; // key id  pos
const IdxTy sz=r.size();
typedef std::map< StrTy, std::map< StrTy, std::vector<StrTy >  > > TwoMap;
std::map<StrTy, TwoMap>  tmmm;
for(IdxTy i=0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if (len<2) continue; // no kvp 
MM_ERR(MMPR2(len,l[len-1]))
if (len<=kid_pos) continue; // no kvp 
const StrTy & v=l[len-1];
Tm & m=tmx[l[aid_pos]];
TwoMap& tmm=tmmm[l[aid_pos]];;
const StrTy & kid=l[kid_pos];
MM_ERR(MMPR2(l[aid_pos],kid))
if (kid=="journal-id") m["journal"]=(v);
else if (kid=="publisher") m["publisher"]=(v);
//7|1|html|3|body|4|article|15|front|22|article-meta|23|article-id|24|pub-id-type|
//8|1|html|3|body|4|article|15|front|22|article-meta|23|article-id|26|text|10.2254
else if (kid=="contrib-group")
{  
//StrTy q=l[kid_pos+2];
//if (q=="name") q=l[kid_pos+4];
//tmm[l[kid_pos+3]][q].push_back(v);
MM_ERR(MMPR3(l[kid_pos+1],l[len-4],v))
tmm[l[kid_pos+1]][l[len-4]].push_back(v);
}
else if (kid=="article-id")  tmm[l[kid_pos]][l[kid_pos+2]].push_back(v);
else tmm[l[kid_pos+3]][l[len-4]].push_back(v);
} // i main line loop 
//////////////////////////////////////////
MM_LOOP(oo,tmx)
{
Tm & m=tmx[(*oo).first];
TwoMap& tmm=tmmm[(*oo).first];
bool used=false;
// now dismember the misc map in tmm...
auto& aidm=tmm["article-id"];
if (aidm.size())
{
const StrTy & t=aidm["pub-id-type"][0];
if (t.length()){  m[t]=aidm["text"][0]; } 
} // aidm.size
//if (!used) 
if ( tmm["abstract"].size())
{ // this  doesnt  do  see the r later in loop  
auto& aidm=tmm["abstract"];
const StrTy & t=aidm["p"][0];
if (t.length()) m["abstract"]=t; // aidm["text"][0];
} // abstract
//else 
if (!used) { 
MM_LOOP(ii,tmm)
{
auto & em=(*ii).second;
if (em.find("contrib-type")!=em.end())
{
const StrTy ty=em["contrib-type"][0];
if (ty=="author")
{
MM_LOOP(ff,em)
{
MM_ERR(" fuc "<<MMPR2((*ff).first,(*ff).second[0]))
}
Vadd(em,m,"author","surname","given-names",0);
/*
StrTy last;
MM_LOOP(jj,em["surname"]) last+=(*jj);
 StrTy first;
MM_LOOP(jj,em["given-names"]) first+=(*jj);
if (m["author"].length()) m["author"]+=" and ";
m["author"]+=first+" "+last;
*/
} // author
else 
Vc(em,m,0);
//MM_LOOP(jj,em) m[(*jj).first]+=(*jj).second[0];
} // contrib-type
else
{
Vc(em,m,0);
//MM_LOOP(jj,em) m[(*jj).first]+=(*jj).second[0];

}
} // ii
} // else 
m["abstract"]=m["p"];
Mv(m,"title","article-title");
Mv(m,"abstract","p");
m["type-name"]="article";
m["name-name"]="xxx";


} // oo 

MM_ERR(MMPR(tmx.size()))
if (tmx.size()>0) _m=(*tmx.begin()).second;
return 0;
}
#endif


template <class Tm,class Te> 
IdxTy Vc(Te & em, Tm & m, const IdxTy flags)
const 
{
MM_LOOP(jj,em)
{
const auto k=(*jj).first;

 const auto ve=(*jj).second;
MM_LOOP(kk,ve) {
if (m[k].length()) m[k]+=", ";
 m[k]+=(*kk);
} // kk 
}
return 0; 
} // Vc


template <class Tm> 
IdxTy Mv( Tm & m, const StrTy & d, const StrTy & s, const IdxTy flags=0)
const 
{
auto ii=m.find(s);
if (ii==m.end()) return 1;
m[d]=m[s];
m.erase(ii);
return 0;
} // Mv


template <class Tm,class Te> 
IdxTy Vadd(Te & em, Tm & m, const StrTy & d, const StrTy & dx,const StrTy & s, const IdxTy flags)
const 
{
StrTy last;
 StrTy first;
MM_LOOP(jj,em[s]) last+=(*jj);
if (dx.length()) { MM_LOOP(jj,em[dx]) first+=(*jj); } 
if (m[d].length()) m[d]+=" and ";
if ( first.length()) m[d]+=first+" ";
m[d]+=last;

return 0;
}


template <class Tm > IdxTy Format(StrTy & s, Tm & m,  const IdxTy  flags) const
{
Ss ss;
ss<<"@"<<m["type-name"]<<"{"<<m["name-name"]; // <<","<<CRLF;
MM_LOOP(ii,m)
{
const StrTy & key=(*ii).first;
if (key=="type-name") continue;
if (key=="name-name") continue;

ss<<","<<CRLF;
const StrTy & v=(*ii).second;
ss<<key<<" = {"<<v<<"} ";

}
ss<<CRLF<<"}"<<CRLF;

s=ss.str();
return 0;
}// Format 

// MEMBERS
mutable Hand m_hand;



}; // mjm_mets_xml

//////////////////////////////////////////////

template <class Tr>
class mjm_mets_xml_map : public std::map<typename Tr::StrTy, mjm_mets_xml< Tr > >  
{
 typedef mjm_mets_xml_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_mets_xml< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_mets_xml_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_mets_xml_map




////////////////////////////////////////////
#ifdef  TEST_MJM_METS_XML
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_mets_xml <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;

typedef mjm_ragged_table Ragged;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_METS_XML "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_mets_xml<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;

if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") {
// x.load(li.words(),1); 
Ragged r;
IdxTy rc=x.load_ragged(r,cip.p1,0);
std::map<StrTy,StrTy> m;
IdxTy rca=x.assemble(m,r,0);
StrTy s;
IdxTy rcf=x.format(s,m,0);
//MM_MSG(r.dump())
MM_MSG(MMPR4(s,m.size(),r.size(),rc))

//IdxTy load_ragged(Ragged & r, const StrTy & fn, const IdxTy  flags) const
}


//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_METS_XML_H__ 
