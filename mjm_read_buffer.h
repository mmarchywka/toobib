#ifndef MJM_READ_BUFFER_H__
#define MJM_READ_BUFFER_H__


#include "mjm_thread_util.h"

// for default traits
#include "mjm_globals.h"
#include <map>
#include <vector>
// added for dumping output in string form even when bin 
// casuing include loops due to commandinterpretter in color_tablr
//#include "mjm_misc_parse.h"


// Wed May  8 19:08:39 EDT 2019
// generated by -classhdr mjm_read_buffer  
// really just a place for concatenating strings but
// expanded for double buffering input

class mjm_read_buffer_traits
{
public: 
typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream OsTy;
 typedef std::ofstream Ofs;

}; 

template <class Tr=mjm_read_buffer_traits, class _Ch=char>
class mjm_read_buffer 
{
 typedef mjm_read_buffer Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
//typedef char Ch;
typedef _Ch Ch;
//typedef mjm_misc_parse<Tr> CharLut;

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
enum { MAP_MU=0 , MU_SZ};

enum { DEFAULT_BUFFER_LN2=14};

public:
mjm_read_buffer() {Init();}
mjm_read_buffer(const IdxTy pad) {Init(); Pad(pad); }
mjm_read_buffer(const IdxTy pad, const IdxTy blocks) {Init(); Pad(pad); Expand(blocks*(m_mask+1)); }
mjm_read_buffer(const StrTy & x) {Init(); clear(); mark(); append(x);  cap(); }
// take ownership of buffer p and copy and expand and delete
// as needed now. 
mjm_read_buffer(Ch * p, const IdxTy sz, const IdxTy alloc,  const IdxTy pad, const IdxTy blocks) 
{
Init(); Pad(pad); 
m_ptr=p; m_size=alloc; m_pc=sz; 
Expand(blocks*(m_mask+1)); 
}
//Ch * m_ptr;
//IdxTy m_size,  // total buffer size
//m_inc,  // apparently never used 
//m_pc,  // current write position 
//m_pad,m_mask; // allocation round up 
private:
mjm_read_buffer(const Myt & x) {}
Myt & operator=(const Myt & x) {}
public:

~mjm_read_buffer() {Release();}
Myt & operator=(const StrTy & x) { clear(); mark(); append(x);  cap(); }

void load(const StrTy & fn) { Load(fn); } 
void pad(const IdxTy pad, const IdxTy blocks) { Pad(pad); Expand(blocks*(m_mask+1)); }
void clear() { m_pc=0; m_mark.clear(); } 
const IdxTy &  size() const { return m_pc; }  // actually length, used chars 
const IdxTy  space() const  { return m_size-m_pc; } 
const IdxTy  alloc() const  { return m_size; } 
void release()  {LetGo(); } //  Release(); } 
Ch * buf() { return m_ptr; } 
// const ptr or const data pointed at?
const Ch * buf() const  { return m_ptr; } 
Ch * next() { return m_ptr+m_pc; } 
void appended(const IdxTy n ) { m_pc+=n; } 
void push_back(const Ch _c) { append(_c); } 
void append(const Ch _c) { Ch c[2]; c[0]=_c; c[1]=0; Append(c,1); }
IdxTy write(std::ostream & os, const IdxTy flags ) {os.write(m_ptr,m_pc); return 0;  }
// https://stackoverflow.com/questions/116038/how-do-i-read-an-entire-file-into-a-stdstring-in-c
IdxTy write_file(const StrTy fn, const IdxTy flags=0)
{
std::ofstream ofs(fn);
return write(ofs,flags); 
}
IdxTy read_file(const StrTy fn, const IdxTy flags=0)
{
std::ifstream ifs(fn.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    std::ifstream::pos_type fileSize = ifs.tellg();
if (fileSize==0)
{
MM_ERR(" empty of missing file "<<MMPR(fn))
return ~0; 
}
    ifs.seekg(0, std::ios::beg);
    //vector<char> bytes(fileSize);
    //ifs.read(bytes.data(), fileSize);
// it would make more sense to expand and then append directly 
 //Ch * p= new Ch[fileSize];
 //   ifs.read(p, fileSize);
//	Append(p,fileSize);
IdxTy tgt=m_pc+fileSize+1;
Expand(tgt);
   ifs.read(m_ptr+m_pc, fileSize);
//memcpy(m_ptr+m_pc,c,len);
m_pc+=fileSize;
return 0; 
} // read_file

// TODO there is no assurance this has an eos 0 or even allocated
// space at this point, not pushing valid string start? 
// put next available location on the mark stack 
void mark_pc() { m_mark.push_back(m_pc); }
// begin a new string with c
void mark_append(const Ch _c) { m_mark.push_back(m_pc);append(_c); }
// terminate the prior string and start a new one marked on the stack 
void new_append(const Ch _c) { append(Ch(0)); m_mark.push_back(m_pc);append(_c); }
// append the char to old string, terminate and mark for a new one. 
void append_new(const Ch _c) {append(_c);  append(Ch(0)); m_mark.push_back(m_pc); }
void cap() {append(Ch(0));   }
void capif() {if ((m_pc==0)||(m_ptr[m_pc-1]!=0)) cap();    }
// terminate current string point to a new one. 
void start_new() {append(Ch(0));   m_mark.push_back(m_pc); }
//void cap() {append(Ch(0));   }
void append(const StrTy & s) { Append(s.c_str(),s.length()); }
void mark_append(const StrTy & s) { m_mark.push_back(m_pc);append(s); }
void new_append(const StrTy & s) {append(Ch(0));  m_mark.push_back(m_pc);append(s); }
// get the most recent string and remove it from the buffer
StrTy mark_string() { return MarkString(); } 

void mark() { m_mark.push_back(m_pc); } 
void mark(const IdxTy i ) { m_mark.push_back(i); } 
Ch * ptr() { return m_ptr; } 
void append(const char *  c) { Append(c,strlen(c)); }
void push_string(const char *  c) {mark();  Append(c,strlen(c)+1); }
void push_string(const char *  c,const IdxTy sz) {mark();  Append(c,sz);cap(); }
void append(const char *  c, const IdxTy sz ) { Append(c,sz); }
// this makes the contents into a string for extraction  although
// after all of that should just let caller do StrTy(pt()) lol
// although ctor sthould stupidly be elided.. 
StrTy string()
{
m_ptr[m_pc]=0;
return StrTy(m_ptr);
}
StrTy summary(const IdxTy flags) const
{
Ss ss;
IdxTy n=strings();
ss<<MMPR(n);
if (n<2) return ss.str();
for(IdxTy i=0; i<n; ++i) ss<<MMPR2(i,string(i))<<",";
if (m_mark.size()==0) return ss.str();
ss<<" final string starts :  ";
char * p=m_ptr+m_mark[m_mark.size()-1];
IdxTy f=p-m_ptr;
IdxTy e=m_pc;
if ((e-f)>30) e=f+30;
for(IdxTy i=f; i<e; ++i)
{
const char c=*(p+i);
if (c==0) break;
 ss<<c;

}
return ss.str();
}
// the first string is not supposed to be marked but
// that may makemore sense , I guess if the first one in m_mark
// is zero that means something and otherwise a null first
// string would have a zero written 
StrTy string(const IdxTy i ) const  {if (i==0) return StrTy(m_ptr);  return StrTy(m_ptr+m_mark[i-1]); } 
StrTy string_sane(const IdxTy i ) {  return StrTy(m_ptr+m_mark[i]); } 
const char *  operator[](const IdxTy i ) {  return (m_ptr+m_mark[i]); } 
const char *  operator[](const IdxTy i ) const  {  return (m_ptr+m_mark[i]); } 
StrTy last_string( ) {  return string(strings()); } 
StrTy next_last_string( ) {  return string(strings()-1); } 

IdxTy strings() const  { return m_mark.size(); } 
IdxTy string_count() { return m_mark.size(); } 
void minimize() { Minimize(); } 
// this needs to use lut printing... 
StrTy dump_char(IdxTy n=0,const IdxTy flags=0)
{
Ss ss;
if (m_ptr==0) { ss<<"null"; return ss.str(); } 
const IdxTy max=((n>0)&&(n<m_pc))?n:m_pc;
for(IdxTy i=0; i<n; ++i)
{
const char c=m_ptr[i];
if (c==0) ss<<"\\0";
else ss<<c;

}
if ((flags&1)!=0)
{
int  i=int(m_pc)-int(n);
if (i<0) return ss.str(); 
ss<<"[...]"; 
while (i<int(m_pc))
{
const char c=m_ptr[i];
if (c==0) ss<<"\\0";
else ss<<c;
++i;
} // while 

} // if 

if ((flags&2)!=0)
{
ss<<" strings :";
for(IdxTy i=0; i<m_mark.size(); ++i)
{
IdxTy j=m_mark[i];
ss<<"["<<i<<"]";
IdxTy jfin=j+8; if (jfin>=m_pc) jfin=m_pc;
while (j<jfin) { ss<<m_ptr[j]; ++j; } 
ss<<",";
} // i 

} // if 2

return ss.str();
}

// change char i to f in streing n 
IdxTy csub( const Ch f, const Ch i, const IdxTy n)
{
IdxTy nc=0;
 char *  p=(m_ptr+m_mark[n]);  
while (*p!=0) { if (*p==i) { ++nc;  *p=f;}  ++p; }// p 
return nc; 
} // csub


void take_between(const Myt & that, const Ch s, const Ch e,const Ch ex=0, const bool init=false)
{
// appends len chars no added 0 
//void Append(const Ch * c, const IdxTy len)
clear();
const IdxTy n=that.size();
bool taking=init;
if (taking) mark();
for(IdxTy i=0; i<n; ++i)
{
const Ch & c=that.buf()[i];
if (taking) {if(c!=e) {if (c!=ex)  Append(&c,1);  } 
else { cap();taking=false; }
 } // taking
else{
if (c==s) {mark(); taking=true; }
} // not taking 

} // i 
 capif();
}// take_between

void split_and_mark(const Ch c,const bool sane=false)
{
m_mark.clear();
IdxTy i=0;
if (m_pc==0) return; 
if ((m_ptr[i]!=0))  mark(i);
// did not want to mark first one twice... wtf 
if (!sane) ++i;
const IdxTy lim=m_pc-1;
while (i<lim)
{
//if (m_ptr[i]==' ') {m_ptr[i]=0;  mark(i+1); } 
if (m_ptr[i]==c) {m_ptr[i]=0;  mark(i+1); } 
++i;
}

}

void split_and_mark(const StrTy & s, const Ch c)
{
clear();
append(s);
cap();
split_and_mark(c);
}
template <class Tv> void vectorize(Tv & v,const StrTy & s, const Ch c)
{
split_and_mark(s,c);
const IdxTy sz=string_count();
for( IdxTy i=0; i<sz; ++i) { v.push_back(StrTy((*this)[i])); } // i 


} // vectorize


private:


mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }

void Init()
{
m_ptr=0;
m_pc=0;
m_size=0;
Pad(DEFAULT_BUFFER_LN2);
// there is no string here yet. 
//m_mark.push_back(0); // should subclass to keep this lightweight 
m_mutex_vector = MutexVector(MU_SZ);
}
void Pad(const IdxTy lpad)
{
m_pad=lpad; // 14;
m_mask=(1<<m_pad)-1;

}
StrTy MarkString()
{
// taking a series of these removes from the last mark
// to the prior mark or end. Adding again will append and be taken
// with full buffer or previous mark . 
IdxTy back=m_mark.back();
Ch * b=m_ptr+back;
m_ptr[m_pc]=0;
StrTy x= StrTy(b);
*b=0; // doh added star- TODO FIXME anyone else used this behavior???
m_pc=back+1; // doh overwrite the zero then 
m_mark.pop_back();
return x;

}

void Load(const StrTy & fn) {
//std::ifstream f(fn.c_str()); 
std::ifstream* pf=0; // (fn.c_str()); 
if (fn!="-") pf= new std::ifstream(fn.c_str());
std::istream&  f = (pf)?(*pf):std::cin; // (fn.c_str()); 

// this is really a mask though.. 
const IdxTy psz=m_mask+1;
char p[psz];
while (f.good()&&!f.eof())
{
//IdxTy len= 
f.read(p,psz);
IdxTy len= f.gcount(); // read(p,psz);

Append(p,len);
}
delete pf;
 } 
void Append(const Ch * c, const IdxTy len)
{
IdxTy tgt=m_pc+len+1;
Expand(tgt);
memcpy(m_ptr+m_pc,c,len);
m_pc+=len;
}
void Expand(const IdxTy sz)
{
if (sz<=m_size) return;
const IdxTy M=m_mask; // (1<<10)-1;
const IdxTy szx= (sz+M)&(~M); 
if (szx<sz) { MM_ERR(" logic error "<<MMPR2(szx,sz))} 
//else  { MM_ERR(" normal expand  "<<MMPR2(szx,sz))} 
Ch * x= new Ch[szx];
if (m_size!=0)
{
memcpy(x,m_ptr,m_pc);
delete [] m_ptr;
}
m_ptr=x;
m_size=szx;
}
void Minimize()
{
Release(); // should return to our memallocer

}
void Release()
{
delete m_ptr; 
LetGo();
//m_ptr=0;
//m_ptr=0; m_pc=0; m_size=0;
}

void LetGo()
{
m_ptr=0;
m_pc=0;
m_size=0;
}


Ch * m_ptr;
IdxTy m_size,  // total buffer size
m_inc,  // apparently never used 
m_pc,  // current write position 
m_pad,m_mask; // allocation round up 
// subsclass to keep base lightweight

std::vector<IdxTy> m_mark;

}; // mjm_read_buffer

template <class Tr=mjm_read_buffer_traits, class _Ch=char>
class mjm_indexed_read_buffer //  : public  mjm_read_buffer<Tr,_Ch>
{
 typedef mjm_indexed_read_buffer Myt;
typedef mjm_read_buffer<Tr,_Ch>  Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
//typedef char Ch;
typedef _Ch Ch;
//typedef mjm_misc_parse<Tr> CharLut;

public:
typedef std::vector<IdxTy> Vec;
typedef std::map<StrTy, Vec> Map;
mjm_indexed_read_buffer(const char * s, const char c) {Init(s,c);}
IdxTy size() const { return m_n; } 
const char * operator[](const IdxTy i ) const { return m_rb[i]; }
const Vec & operator[](const char *  s)  { return m_map[StrTy(s)]; } 
const Vec & operator[](StrTy & s)  { return m_map[s]; } 
template <class Tm > IdxTy first_of(const Tm & m) const { return FirstOf(m); } 
template <class Tm > IdxTy first(const Tm & m) const { return First(m); } 
private: 
template <class Tm > IdxTy First(const Tm & m) const { 
IdxTy lo=~0;
{
const StrTy & k=m; // (*ii).first;
auto jj=m_map.find(k);
if (jj==m_map.end()) return lo; // continue;
if ((*jj).second.size()==0)
{
MM_ERR(" danger size is zero will bomb "<<MMPR2((*jj).first,k))
return lo; // continue;
}
if ((*jj).second[0]<lo) { lo=(*jj).second[0]; } 
} // ii
// if(lo== ~0 )  return lo;
return lo; // m[m_rb[lo]];
//return loc; // m[m_rb[lo]];
} // Firsf
 
// NOT, return map value of earliest occuring key in map in the input strings
// actually return the position instead doh 
template <class Tm > IdxTy FirstOf(const Tm & m) const { 
IdxTy lo=~0;
// mjm 2023-07-22 fixing mikemail warnings 
//IdxTy loc=~0;
MM_LOOP(ii,m)
{
const StrTy & k=(*ii).first;
auto jj=m_map.find(k);
if (jj==m_map.end()) continue;
if ((*jj).second.size()==0)
{
MM_ERR(" danger size is zero will bomb "<<MMPR2((*jj).first,k))
continue;
}
// mjm 2023-07-22 fixing mikemail warnings 
//if ((*jj).second[0]<lo) { lo=(*jj).second[0]; loc=(*ii).second; } 
if ((*jj).second[0]<lo) { lo=(*jj).second[0];  } 
} // ii
// if(lo== ~0 )  return lo;
return lo; // m[m_rb[lo]];
//return loc; // m[m_rb[lo]];
} // FirstOf
 
void Init(const char * s, const char c)
{
// the StrTy thins is stupid wtf 
m_rb.split_and_mark(StrTy(s),c);
m_n=m_rb.strings();
for(IdxTy i=0; i<m_n; ++i)
{
m_map[StrTy(m_rb[i])].push_back(i); 
} // i 

} // Init


Super m_rb;
IdxTy m_n;
Map m_map;
}; // mjm_indexed_read_buffer




#endif // MJM_READ_BUFFER_H__ 
