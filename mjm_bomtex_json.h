#ifndef MJM_BOMTEX_JSON_H__
#define MJM_BOMTEX_JSON_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_strings.h"
#include "testHTML.h"
#include <../mjsonu/mjsonu.h>
#include "mjm_html_features.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

// made from mjm_xref_json 2021-10-20
// Sun Oct  3 18:38:51 EDT 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bomtex_json   

// g++  -Wall -Wno-unused-variable -std=gnu++11 -DTEST_MJM_BOMTEX_JSON -I. -I../../mjm/hlib -I../../mjm/num -I /usr/include/libxml2 -I/home/documents/cpp/pkg/include  -gdwarf-3 -O0  -x c++ mjm_bomtex_json.h  -lpthread -lreadline -lxml2


// g++  -Wall -std=gnu++11 -DTEST_MJM_BOMTEX_JSON -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bomtex_json.h  -lpthread -lreadline

template <class Tr>
class mjm_bomtex_json 
{
 typedef mjm_bomtex_json Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_ragged_cursor RaggedCursor;
typedef std::vector<Ragged> RagVec;


typedef mjm_wovdb<Tr,StrTy> Tdb;


typedef mjm_html_features<Tr> Feat;

public:
mjm_bomtex_json() {}
~mjm_bomtex_json() {}

#if 0 
StrTy crossref_xform( const StrTy & fn, const IdxTy  flags) const
{
Ragged r;
IdxTy rc=load_ragged(r,fn,0);
std::map<StrTy,StrTy> m;
IdxTy rca=assemble(m,r,0);
StrTy s;
IdxTy rcf=format(s,m,0);
MM_ERR(MMPR4(s,m.size(),r.size(),rc))
return s; 
} // crossref_xform
#endif

//  TODO maybe derive from the xref base class? 
// This really idally should not be parsing json but reading it
// instead of html... 
//  testHTML --mjmflags hier -mjm -

#if 0

  wget -O wmt.html  -S -v --user-agent="asdcasdcasdc" "https://www.walmart.com/ip/Swanson-Thyroid-Glandular-Thryroxin-Free-Formula-200-mg-60-Caps/890335711"
 2394  cat wmt.html  | testHTML -mjmflags hier -mjm -  |  more
 2395  cat wmt.html  | testHTML -mjmflags hier -mjm -  | mjsonu.out -cmd sax-json - 1 | more
 2396  cat wmt.html  | testHTML -mjmflags hier -mjm -  | mjsonu.out -cmd "sax-json - 1" | more



#endif

IdxTy load_ragged(Ragged & r, const StrTy & fn, const IdxTy  flags) const
{
return LoadRagged(r,fn,flags);
}
IdxTy parse_both(Ragged & h, Ragged & j, const StrTy & fn, const IdxTy  flags) const
{
return ParseBoth(h,j,fn,flags);
}

template <class Tm > IdxTy assemble_easy_bib(Tm & m, const Ragged & r,  const IdxTy  flags) const
{ return AssembleEasyBib(m,r,flags); }



template <class Tm > IdxTy assemble(Tm & m, const Ragged & r,  const IdxTy  flags) const
{ return Assemble(m,r,flags); }

template <class Tm > IdxTy assemble(Tm & m,  const std::vector<Tm> & tmv, const RagVec & rv,  const IdxTy  flags) const
{ return Assemble(m,tmv,rv,flags); }



template <class Tm > IdxTy format(StrTy & s, Tm & m,  const IdxTy  flags) const
{
return Format(s,m,flags);
}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
/*
 2098  wget -O swanson.html -S -v "https://www.swansonvitamins.com/swanson-premium-thyroid-glandular-thyroxin-free-200-mg-60-caps"
 2099  toobib -hhtml swanson.html 
 2100  toobib -hhtml swanson.html  > swanson.htmlout
 2101  toobib -json1 swanson.htmlout 
 2102  toobib -json1 swanson.htmlout  > swanson.jsonout
 2104  more swanson.jsonout 
 2105  more swanson.jsonout  | grep -v " GLOBAL =" | more
 2106  more swanson.jsonout  | grep -v " GLOBAL =" | grep -i thyroid
 2107  more swanson.jsonout  | grep -v " GLOBAL =" | grep -i thyroid | more
 2109  more swanson.jsonout  | grep -v " GLOBAL =" |  more
 2110  more swanson.jsonout  | grep -v " GLOBAL =" |  grep -v categoryRes
 2111  more swanson.jsonout  | grep -v " GLOBAL =" |  grep -v categoryRes | more
 2112  more swanson.jsonout  | grep -v " GLOBAL =" |  grep -v categoryRes | sed -e 's/ [0-9][0-9]* //g'  | more
 2113  more swanson.jsonout  | grep -v " GLOBAL =" |  grep -v categoryRes | sed -e 's/ [0-9][0-9]* //g'  | mjm zed 1 | more
 2114  more swanson.jsonout  | grep -v " GLOBAL =" |  grep -v categoryRes | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more
 2115  more swanson.jsonout  | grep -v " GLOBAL =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more
 2116  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more
 2117  more swanson.jsonout  | grep -i price
 2118  more swanson.jsonout  | grep -i price | more
 2121  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more
 2122  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more| grep -i price
 2123  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more
 2124  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" | more
 2125  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more
 2126  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap" | sed -e 's/ [0-9][0-9]* / /g'  | mjm zed 1 | more | grep mg
 2127  more swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap"   | mjm zed 1 | more | grep mg
 2145  more ref/swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap"   | mjm zed 1 | more | grep mg
 2153  history | grep swanson



 more ref/swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap"   | mjm zed 1 | more 



*/

class _msg_state
{
public:
_msg_state():mpos(~0) {} 
StrTy dump() const
{
Ss ss;
ss<<MMPR4(mpos,type,auno,status);
return ss.str();}
IdxTy mpos;
StrTy type,auno,status;

}; 
typedef _msg_state msg_state;
// This was crossref specific, need to eliminate this crap now 
// now Swanson specific lol 
//  more ref/swanson.jsonout  | grep -v " GLOBAL =\|adobeRecord =" |  grep -v "categoryRes\|dropdownMap"   | mjm zed 1 |more
#if 0
GLOBAL 294 9 9 48 10 1 1 4 1 10 1 3 10 3 11 49 2 2 2 5 2 1 1 8 14 1 35 8 2 3 8 6
 28 3 3 23 2 adobeRecord 1 productVendor = Swanson Premium
GLOBAL 294 9 9 48 10 1 1 4 1 10 1 3 10 3 11 49 2 2 2 5 2 1 1 8 14 1 35 8 2 3 8 6
 28 3 3 23 2 adobeRecord 2 brandUrl = /view/swanson-premium
GLOBAL 294 9 9 48 10 1 1 4 1 10 1 3 10 3 11 49 2 2 2 5 2 1 1 8 14 1 35 8 2 3 8 6
 28 3 3 23 2 adobeRecord 3 productName = Thyroid Glandular - Thyroxin-Free Formu
la

GLOBAL 294 9 9 48 10 1 1 4 1 10 1 3 10 3 11 49 2 2 2 5 2 1 1 8 14 1 14 2 dropdow
nMap 1 Herbs 4 products 1 2 adobeRecord 41 flagMap 4 nongmo = nongmo

#endif

#if 0
https://www.ahajournals.org/doi/abs/10.1161/circ.144.suppl_1.10712
aha also has json,
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 1 publicationDate = Nov 16, 2021, 12:00:00 AM
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 2 authors = Gundry, Steven R
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 1  1 label = Acute coronary syndromes
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 1  2 searchUrl = /keyword/Acute+coronary+syndromes
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 2  1 label = Antibodies
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 2  2 searchUrl = /keyword/Antibodies
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 3  1 label = COVID-19
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 3  2 searchUrl = /keyword/COVID-19
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 4  1 label = Inflammation and inflammatory markers
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 4  2 searchUrl = /keyword/Inflammation+and+inflammatory+markers
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 5  1 label = Myocarditis
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 3 articleKeywords 5  2 searchUrl = /keyword/Myocarditis
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 4 format 1 format = ABSTRACT
@         

./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 5 assetTitle = Abstract 10712: Mrna COVID Vaccines Dramatically Increase Endothelial Inflammatory Markers and ACS Risk as Measured by the PULS Cardiac Test: a Warning
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 6 doi = 10.1161/circ.144.suppl_1.10712
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 7 issue = Suppl_1
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 8 volume = 144
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 9 sku 1 value = 0009-7322
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 9 sku 2 type = ISSN
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 9 sku 3 subtype = PPUB_IDSUBTYPE
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 9 sku 4 source = CONTENT
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 10 parentTitle = Circulation
./mjsonu.h622   json dies before parse fck  ok=1 eof=1 good=0 n=908484 cc=s

./mjsonu.h496  FCK  i=3 argc=4 args[i]=-quit s=-quit
./mjsonu.h280 GLOBAL 220  240  4  1  2  1  20  3 content 1 productInfo 11 viewType = Abstract
marchywka@happy:/home/documents/cpp/proj/toobib/junk$ toobib -hhtml aha.html  | toobib -json1 - | grep -v " GLOBAL = " | grep -i productInfo



#endif


bool NotJunk(const Line & l ) const
{
MM_SZ_LOOP(i,l,sz) 
{ 
if (l[i]=="dropdownMap") return false; 
if (l[i]=="catagoryRes") return false; 

} 
return true; 
}
template <class Tm > IdxTy Assemble(Tm & m, const StrTy & k, const StrTy & v,  const IdxTy  flags) const
{
m[k]+=v;
return 0;
}
// https://www.sra-solder.com/bar-solder-96-4-lead-free
template <class Tm > IdxTy Assemble(Tm & m,  const std::vector<Tm> & tmv, const RagVec & rv,  const IdxTy  flags) const
{  
IdxTy rc=0;


return rc;
} // Assemble vector 
/*
./mjsonu.h312 GLOBAL 422  423 source = book
./mjsonu.h312 GLOBAL 422  423 style = apa
./mjsonu.h312 GLOBAL 422  423 contributors 424  425 function = author
./mjsonu.h312 GLOBAL 422  423 contributors 424  425 last = Matlack
./mjsonu.h312 GLOBAL 422  423 contributors 424  425 first = Albert
./mjsonu.h312 GLOBAL 422  423 contributors 424  425 middle = S
./mjsonu.h312 GLOBAL 422  423 pubtype 426 main = pubnonperiodical
./mjsonu.h312 GLOBAL 422  423 pubnonperiodical 427 title = Introduction to green chemistry
./mjsonu.h312 GLOBAL 422  423 pubnonperiodical 427 publisher = CRC Press-Taylor & Francis
./mjsonu.h312 GLOBAL 422  423 pubnonperiodical 427 city = Boca Raton
./mjsonu.h312 GLOBAL 422  423 pubnonperiodical 427 year = 2010
./mjsonu.h312 GLOBAL 422  423 datasource = /z-wcorg/
./mjsonu.h312 GLOBAL 422  423 datasource = http://www.worldcat.org
./mjsonu.h312 GLOBAL 422  423 oclc = 865160441
./mjsonu.h312 GLOBAL 422  423 isbn = 9781420078114 1420078119



*/


template <class Tm > IdxTy AssembleEasyBib(Tm & m, const Ragged & r,  const IdxTy  flags) const
{
MM_ERR(" begin easy bib assembly")
 m["type-name"]="article";
const IdxTy sz=r.size();
typedef std::map<StrTy, StrTy> Vm;
typedef std::map<StrTy, Vm> Hm;
Hm contrib;
for(IdxTy i=0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
//MM_ERR(MMPR(l[len-1]))
if (len<6) continue; // no adobeRecord 
const int off=(l[len-2]=="=")?1:0 ;
//Ss ss; MM_LOOP(ii,l) { ss<<(*ii)<<" "; } MM_ERR(MMPR(ss.str()))
const IdxTy idx_q=4;
const IdxTy idx_k=len-2-off;
const IdxTy idx_v=len-1;
const StrTy & q=l[idx_q];
const StrTy & k=l[idx_k];
const StrTy & v=l[idx_v];
Ss ss;
MM_SZ_LOOP(i,l,lszz) { ss<<MMPR2(i,l[i])<<" "; } 
MM_ERR(__FUNCTION__<<" "<< ss.str())
if (q=="contributors")
{
const IdxTy idx_c=len-3-off;
contrib[l[idx_c]][k]+=v;

continue;
} // contibutors
if (m[k].length()) m[k]+=" ";
m[k]+=v;

} // i 
MM_LOOP(ii,contrib)
{
//#if 0 
MM_ERR(MMPR2((*ii).first, (*ii).second.size()))
auto iv=(*ii).second;
StrTy mk="nokey";
const auto iff=iv.find("function");
if ( iff!=iv.end()) mk=(*iff).second; 
if (mk=="author")
{
auto & x=m[mk];
if (x.length()) x=x+" and ";
x+=iv["first"]+ " "+iv["middle"]+ " "+iv["last"];
MM_ERR(MMPR(x))
continue;
} // auithor
MM_LOOP(jj,iv)
{
m[mk]+= (*jj).first+" "+(*jj).second;
MM_ERR(MMPR3(m[mk],(*jj).first,(*jj).second))
} // jj 
//#endif

} // ii 
 if (m["source"]=="book") m["type-name"]="book";
return 0;
} // AssembleEasyBib


// the loader does the json parsing FCK 
template <class Tm > IdxTy Assemble(Tm & m, const Ragged & r,  const IdxTy  flags) const
{
msg_state ms;
MM_ERR(" begin assembly")
 m["type-name"]="article"; 
const IdxTy sz=r.size();
for(IdxTy i=0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if (len<2) continue; // no kvp 
//MM_ERR(MMPR(l[len-1]))
if (len<4) continue; // no adobeRecord 
//Ss ss; MM_LOOP(ii,l) { ss<<(*ii)<<" "; } MM_ERR(MMPR(ss.str()))
const IdxTy idx_q=len-4;
const IdxTy idx_k=len-2;
const IdxTy idx_v=len-1; 
const StrTy & q=l[idx_q];
const StrTy & k=l[idx_k];
const StrTy & v=l[idx_v];
//MM_ERR(MMPR4(q,k,v,m.size()))
if (q=="adobeRecord")
{
//MM_ERR(MMPR4(q,k,v,m.size()))
if (k!=q)  if (NotJunk(l))  Assemble(m,k,v,0);
continue;
}

IdxTy idx_p=idx_k;
// can not be in pos 0 
while (idx_p!=0)
{
if (l[idx_p]=="productInfo")
{
//MM_ERR(MMPR4(q,k,v,m.size()))
if (k!=l[idx_p])  if (NotJunk(l))  Assemble(m,k,v,0);
//--idx_p;
break; // continue;
}
--idx_p;
}// idx_p
if (idx_p) continue; 
// needs 
#if 0
if (ms.mpos==~0U)
{
if (l[len-2]=="message-type")
{
ms.mpos=len-2;
ms.type=l[len-1];
continue;
} // msg-type
if (l[len-2]=="status")
{
ms.status=l[len-1];
continue;

} // status

} // mpos==-1
if (len<=ms.mpos) continue;
MM_ERR(MMPR(l[ms.mpos]))
if (l[ms.mpos]!="message") continue;
//9|./mjsonu.h280|GLOBAL|1||4|message|3|publisher|Canadian Science Publishing
if (len<=( ms.mpos+3)) continue;
const StrTy & k1=l[ms.mpos+2];
const StrTy & v=l[len-1];
// TODO most of these are the same, can use a map... 
if (k1=="publisher"){  m[k1]=v; continue; } 
if (k1=="issue"){  m[k1]=v; continue; } 
if (k1=="volume"){  m[k1]=v; continue; } 
if (k1=="title"){  m[k1]=v; continue; } 
if (k1=="page"){  m[k1]=v; continue; } 
if (k1=="abstract"){  m[k1]=v; continue; } 
if (k1=="DOI"){  m["doi"]=v; continue; } 
if (k1=="source"){  m["bib-source"]=v; continue; } 
if (k1=="subject"){  m["subject"]=v; continue; } 
if (k1=="ISSN"){  m["issn"]=v; continue; } 
if (k1=="URL"){  m["url"]=v; continue; } 
if (k1=="short-container-title"){  m["abbrvjrnl"]=v; continue; } 
if (k1=="container-title"){  m["journal"]=v; continue; }
// TODO dates about the same too 
if (k1=="published"){ if (m["date"].length()!=0) m["date"]+="-";  
if (v.length()==1) m["date"]+=StrTy("0")+v; else m["date"]+=v; 
continue; } 
if (k1=="type"){  m["type-name"]=v; 
if (v=="journal-article") m["type-name"]="article"; 
continue; } 
if (k1=="author"){  
/*
38|./mjsonu.h280|GLOBAL|1||4|message|19|author|1||1|given|E. G.
39|./mjsonu.h280|GLOBAL|1||4|message|19|author|1||2|family|Bligh
40|./mjsonu.h280|GLOBAL|1||4|message|19|author|1||3|sequence|first
41|./mjsonu.h280|GLOBAL|1||4|message|19|author|2||1|given|W. J.
42|./mjsonu.h280|GLOBAL|1||4|message|19|author|2||2|family|Dyer
43|./mjsonu.h280|GLOBAL|1||4|message|19|author|2||3|sequence|addi
*/
const StrTy ty=l[len-2];
const StrTy no=l[len-5];
MM_ERR(MMPR3(ty,no,v))
StrTy newt;
const IdxTy la=m["author"].length();
if (ty=="sequence" ) continue;
if (la)  m["author"]+=" ";
if (la) if( ms.auno!=no) m["author"]+="and ";

if (la) if( ms.auno==no)if (ty=="given")  m["author"]+=", ";
m["author"]+=v; // newt;
ms.auno=no;
continue; }  // author
if (k1=="indexed"){  
// ./mjsonu.h280 GLOBAL 1  4 message 1 indexed 2 date-time = 2021-10-03T16:45:09Z
const StrTy ty=l[len-2];
if (ty=="date-time") m["date-indexed"]=v; 
continue; 
} // indexed

if (k1=="created"){  
// ./mjsonu.h280 GLOBAL 1  4 message 1 indexed 2 date-time = 2021-10-03T16:45:09Z
const StrTy ty=l[len-2];
if (ty=="date-time") m["date-created"]=v; 
continue; 
} // indexed


//continue;
// } // mpos==0

#endif

} // i 
m["name-name"]="xxx";
return 0; 
} // Assemble 
template <class Tm > IdxTy Format(StrTy & s, Tm & m,  const IdxTy  flags) const
{
Ss ss;
ss<<"@"<<m["type-name"]<<"{"<<m["name-name"]; // <<","<<CRLF;
MM_LOOP(ii,m)
{
const StrTy & key=(*ii).first;
if (key=="type-name") continue;
if (key=="name-name") continue;

ss<<","<<CRLF;
const StrTy & v=(*ii).second;
ss<<key<<" = {"<<v<<"} ";

}
ss<<CRLF<<"}"<<CRLF;

s=ss.str();
return 0; 
}// Format 


// TODO VERY SLOW need the headers for both now... 
IdxTy LoadRaggedOld(Ragged & r, const StrTy & fn, const IdxTy  flags) const
{// by default, zero, json parse only
// 2 removes json parse 
const bool xh=Bit(flags,0);
const bool xj=!Bit(flags,1); // earlier default but bad pattern 

//const StrTy cmd=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
const StrTy cmdj=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
const StrTy cmdh="testHTML --mjmflags hier -mjm -";
const StrTy cmd=(!xh&&!xj)?"cat - ":((xj&&!xh)?cmdj:(xh&&!xj)?cmdh:((cmdh+"|"+cmdj)));

Blob out,err,data;
data.load(fn);
IdxTy c=m_hand.fileio(out,err,data,cmd,2);
//MM_ERR(MMPR(StrTy(err)));
//MM_ERR(MMPR(StrTy(out)));
///Ragged r;
r.kvp_splitter(0);
Ss ss;
ss<<StrTy(out);
r.load(ss); // this should now be parsed with value in the end of line field 

//MM_ERR(r.dump())
return 0; 
} // LoadRagged
////////////////////////////////////////
IdxTy LoadRagged(Ragged & r, const StrTy & fn, const IdxTy  flags) const
{// by default, zero, json parse only
// 2 removes json parse 
const bool xh=Bit(flags,0);
const bool xj=!Bit(flags,1); // earlier default but bad pattern 
const bool punt=Bit(flags,2); // earlier default but bad pattern 
const bool only_good_json=Bit(flags,3); // earlier default but bad pattern 
const bool wtf=Bit(flags,4); // earlier default but bad pattern 
const bool debug=Bit(flags,8); // earlier default but bad pattern 

//const StrTy cmd=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
//const StrTy cmdj=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
//const StrTy cmdh="testHTML --mjmflags hier -mjm -";
//const StrTy cmd=(!xh&&!xj)?"cat - ":((xj&&!xh)?cmdj:(xh&&!xj)?cmdh:((cmdh+"|"+cmdj)));
MM_ERR(MMPR4(xh,xj,punt,only_good_json))
 // xh and xj case 
if (!xh || ! xj  || punt ) {  return LoadRaggedOld(r,fn,flags); } 
typedef mjm_mjsonu JsonTy;
JsonTy json;
Ragged s;
std::ifstream is(fn);
IdxTy rc=testHTML::parse_stream(s,is,wtf?0:1);
//MM_ERR(r.dump())
MM_ERR(MMPR(s.size()))
MM_SZ_LOOP(i,s,ssz)
{
const IdxTy len=s[i].size();
if (len==0) continue;
// this does cause bad upstream to screw up others... 
Ss ss;
ss<<s[i][len-1];
auto pr=json.dirty_parse(ss,0);
Ragged & rn=pr.res;
if (debug) { MM_ERR(MMPR(rn.dump())) }
MM_SZ_LOOP(j,rn,rndz)
{
const auto & l=rn[j];
if (only_good_json)
{
const IdxTy sz=l.size();
if (sz<3) continue;
// TODO this is my marker may be ambiguous with real data lol 
if ( l[sz-3]=="GLOBAL") continue;
} // only_good_json
r.add(l);
}
} // 


//Ss js(ss.str());
//auto pr=json.dirty_parse(js,0);
//Ragged & r=pr.res;


MM_ERR(r.dump())
return 0; 
} // LoadRagged
////////////////////////////////////////
/*
1 html 9 head 168 script 169 type 170 text = application/ld+json
1 html 9 head 168 script 171 (null) = {  "@context": "http://schema.org",  "@type": "Periodical",  "issn": "0009-2347",  "hasPart": {    "@id": "cen-20190614lnp2",    "@type": "PublicationVolume",    "volumeNumber": "0",    "datePublished": "20190619"  }}
1 html 9 head 172 script 173 type 174 text = text/javascript
1 html 9 head 172 script 175 src 176 text = /etc.clientlibs/clientlibs/granite/jquery.min.js
1 html 9 head 177 script 178 type 179 text = text/javascript
1 html 9 head 177 script 180 src 181 text = /etc.clientlibs/clientlibs/granite/utils.min.js

Now it looks like this, 
69|1|html|9|head|168|script|169|type|170|text|application/ld+json
70|1|html|9|head|168|script|171||
{
  "@context": "http://schema.org",
  "@type": "Periodical",
  "issn": "0009-2347",
  "hasPart": {
    "@id": "cen-20190614lnp2",
    "@type": "PublicationVolume",
    "volumeNumber": "0",
    "datePublished": "20190619"
  }
}

71|1|html|9|head|172|script|173|type|174|text|text/javascript
72|1|html|9|head|172|script|175|src|176|text|/etc.clientlibs/clientlibs/granite/jquery.min.js



*/


IdxTy ParseBoth(Ragged & h, Ragged & j, const StrTy & fn, const IdxTy  flags) const
{
const bool insure_neq=Bit(flags,0); // earlier default but bad pattern 
const bool insure_eq=Bit(flags,1); // earlier default but bad pattern 
const bool only_ldjson= Bit(flags,2); // earlier default but bad pattern 
const bool only_good_json=Bit(flags,3); // earlier default but bad pattern 
const bool skip_json=Bit(flags,4); // earlier default but bad pattern 
const bool debug=Bit(flags,8); // earlier default but bad pattern 
//if(only_ldjson) MM_ERR(" ignoring ldjson restrict")
MM_ERR(MMPR4(__FUNCTION__,only_ldjson,only_good_json,debug)<<MMPR2(skip_json,flags))
//const StrTy cmd=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
//const StrTy cmdj=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
IdxTy rc=0;
typedef mjm_mjsonu JsonTy;
JsonTy json;
std::ifstream is(fn);
// the "1" here is to only return json losing the other cool stuff.. 
// this is ok if not doing ld only, 
//IdxTy rch=testHTML::parse_stream(h,is,1);
//IdxTy rch=testHTML::parse_stream(h,is,only_ldjson?0:1);
// this would be ok in all cases though 
IdxTy rch=testHTML::parse_stream(h,is,0);
MM_ERR(MMPR(h.dump()))
if (!skip_json) { 
Ragged r;
if (only_ldjson)
{
Feat f;
// there are no equals and there are cr in the values  
f.collect_scripts(h);
f.ld_json_scripts(r,0);
} // only_ldjson 

Ragged & s=(only_ldjson)?r:h;
//Blob b; b=h.dump(); b.save("wwww");
IdxTy objn=0;
MM_SZ_LOOP(i,s,ssz)
{
const IdxTy len=s[i].size();
if (len==0) continue;
// this does cause bad upstream to screw up others... 
Ss ss;
ss<<s[i][len-1];
// 2022-07-03 this does not inc the numbers doh 
//auto pr=json.dirty_parse(ss,0);
auto pr=json.better_parse(ss,objn,0);
Ragged & rn=pr.res;
objn=pr.count+1;
if (debug) { MM_ERR(MMPR(rn.dump())) }
{ MM_ERR(MMPR(rn.dump())) }
MM_SZ_LOOP(k,rn,rndz)
{
const auto & l=rn[k];
if (only_good_json)
{
const IdxTy sz=l.size();
if (sz<3) continue;
// TODO this is my marker may be ambiguous with real data lol 
if ( l[sz-3]=="GLOBAL") continue;
} // only_good_json
j.add(l);
}
} //  i
} // !skip_json 
if(insure_eq) { InsureEq(h,h,1); InsureEq(j,j,1); }
if(insure_neq) { InsureEq(h,h,0); InsureEq(j,j,0); }

if (debug) MM_ERR(j.dump())
return rc;
} // ParseBoth
void InsureEq(Ragged & d, const Ragged &s, const IdxTy flags) const
{
const bool eq=Bit(flags,0);
Ragged r;
MM_LOOP(ii,s) { const  Line&  x=(*ii);     
const IdxTy len=x.size();
if (len>1)
{
const bool has_eq=(x[len-2]=="=");
if (eq&&has_eq) { r.add(x); continue;}
if (!eq&&!has_eq) { r.add(x); continue;}
Line y;
const IdxTy lp=len-1;
for(IdxTy i=0; i<lp; ++i)  y.push_back(x[i]);
if (eq) { y.push_back("="); y.push_back(x[len-1]); }
else { y.back()=(x[len-1]); }
r.add(y);
continue; 
} // len 
r.add(x);
} // ii
d=r;

}
////////////////////////////////////////
// MEMBERS
mutable Hand m_hand;


}; // mjm_bomtex_json

//////////////////////////////////////////////

template <class Tr>
class mjm_bomtex_json_map : public std::map<typename Tr::StrTy, mjm_bomtex_json< Tr > >  
{
 typedef mjm_bomtex_json_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bomtex_json< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bomtex_json_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bomtex_json_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BOMTEX_JSON
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_bomtex_json <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BOMTEX_JSON "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

typedef mjm_ragged_table Ragged;
int main(int argc,char **args)
{
about();
typedef mjm_bomtex_json<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") {
// x.load(li.words(),1); 
Ragged r; 
IdxTy rc=x.load_ragged(r,cip.p1,atoi(cip.p2.c_str()));
MM_ERR(" loaded "<<MMPR(r.size()))
MM_ERR(" loaded "<<MMPR(r.dump()))
std::map<StrTy,StrTy> m;
IdxTy rca=x.assemble(m,r,0);
StrTy s; 
IdxTy rcf=x.format(s,m,0);
MM_ERR(MMPR2(rca,rcf)<< MMPR4(s,m.size(),r.size(),rc))

//IdxTy load_ragged(Ragged & r, const StrTy & fn, const IdxTy  flags) const
}
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BOMTEX_JSON_H__ 
