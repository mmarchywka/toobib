#ifndef MJM_TRY_N_GET_H__
#define MJM_TRY_N_GET_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_strings.h"
#include "mjm_xref_json.h"
#include "mjm_chromate.h"

#include "mjm_idiosyncratic_source_locator.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun Jan  3 20:22:22 EST 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_try_n_get   
// g++  -Wall -std=gnu++11 -DTEST_MJM_TRY_N_GET -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_try_n_get.h  -lpthread -lreadline

template <class Tr>
class mjm_try_n_get  : public mjm_ragged_config
{
 typedef mjm_try_n_get Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_idiosyncratic_source_locator<Tr> IdioRL;
typedef IdioRL UrlTy;
typedef mjm_chromate<Tr> Chromate;
typedef mjm_xref_json<Tr> Jxref;

typedef mjm_wovdb<Tr,StrTy> Tdb;

class _ResultType
{
typedef _ResultType Myt;
public:
_ResultType() {Init(0); } 
_ResultType(const IdxTy n ) {Init(n); } 
Myt & operator=(const IdxTy n ) { Init(n);  return *this; } 
operator IdxTy() const { return m_int; } 
const StrTy & url() const { return m_url; } 
void url(const StrTy & u)  {  m_url=u; } 
const StrTy & name() const { return m_name; } 
void name(const StrTy & u)  {  m_name=u; } 


const StrTy & rc() const { return m_rc; } 
void server_response(const StrTy & u)  {  m_rc=u; } 
private:

void Init(const IdxTy n) { m_int=0; }
StrTy m_url; 
StrTy m_name; 
StrTy m_rc;
IdxTy m_int;
}; // _Result_Type

typedef _ResultType ResultType;
typedef ResultType AccessTy;


public:
typedef std::map<StrTy, StrTy> HdrMap;
mjm_try_n_get() {Init();}
mjm_try_n_get(const Ragged &r ) {Init(); Init(r);}
~mjm_try_n_get() {}
void set_chromate_launch_flags(const IdxTy f) { m_chromate_use_flags=f; }

IdxTy configure(RaggedCursor & rc ) { return Init(rc); } 

bool exists(const StrTy & fn, const IdxTy flags=0) { return  Exists(fn,flags); } 
IdxTy size(const StrTy & fn, const IdxTy flags=0) { return Size(fn,flags); } 
IdxTy embedded_etc(const StrTy & fn, const IdxTy flags=0) { return EmbeddedEtc(fn,flags); } 
IdxTy clear(const StrTy & fn, const IdxTy flags=0) { return Remove(fn,flags); } 
typedef AccessTy return_code;
AccessTy meget(const StrTy & dest, const StrTy & url, const IdxTy flags)
{ return MeGet(dest, url,  flags); }

AccessTy headlessget(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{ return HeadlessGet(dest, url,  flags); }
AccessTy headlessdownload(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{ return ChromateDownload(dest, url,  flags); }



AccessTy normalget(const StrTy & dest, const UrlTy & url, const IdxTy flags, const HdrMap & hdr_map=HdrMap())
{ return NormalGet(dest, url,  flags,hdr_map); }

AccessTy normalpost(const StrTy & dest, const UrlTy & url, const StrTy & data, const IdxTy flags)
{ return NormalPost(dest, url,  data, flags); }

#if 0

uc=`echo $canhandle | urlencode`
echo remove urlencode from doi fwiw | smsg
uc=`echo $canhandle`
url="http://api.crossref.org/works/$uc/transform/application/x-bibtex"
echo found something for $2 with doi=$canhandle  use $url | smsg
# either check rc or file len
normalget "$fn2" "$url"

note that this is not documented for crossref but is avialble
on doi.org too, 
marchywka@happy:/home/documents/cpp/proj/toobib/junk$ wget -O xxx -S -v --heade="Accept: application/x-bibtex"  "http://doi.org/10.1523/jneurosci.0519-17.2017" 
https://github.com/CrossRef/rest-api-doc/issues/115

#endif


AccessTy crossref(const StrTy & fn, const StrTy & doi,const IdxTy flags)
{
bool homemade=true;
//  https://api.datacite.org/dois/10.5438/0012
StrTy datacite="https://api.datacite.org/dois/";
StrTy url="http://api.crossref.org/works/"+doi;
if (!homemade) url+= "/transform/application/x-bibtex";
HdrMap hdrs; // hdr_ua
hdrs["user-agent"]=m_me_ua; // " TooBib/Dev ; build "+StrTy(__DATE__)+StrTy(__TIME__)+   " mailto:marchywka@hotmail.com ; hardcoded developer version; see texhax or google marchywka toobib  "; 
// special UA and don't put googlecrap in there.. 
AccessTy at= normalget(fn,url,flags|(3<<8),hdrs); 
const StrTy&  resp=at.rc();
MM_ERR(MMPR2(url,resp))
if (resp=="404")
{
StrTy url=datacite+doi;
AccessTy at= normalget(fn,url,flags|(3<<8),hdrs); 
const StrTy&  resp=at.rc();
MM_ERR(MMPR2(url,resp))
Blob bx;
bx.load(fn);
MM_ERR(MMPR(StrTy(bx)))
Jxref jxr;
//StrTy sb=jxr.crossref_xform(fn,0);
StrTy sb=jxr.datacite_xform(fn,0);
at.name("datacite");
Blob b(sb);
b.save(fn);
return at;
}
if (homemade)
{
Blob bx;
bx.load(fn);
MM_ERR(MMPR(StrTy(bx)))
Jxref jxr;
StrTy sb=jxr.crossref_xform(fn,0);
Blob b(sb);
b.save(fn);
at.name("crossref");
}
return at; 
} //  crossref

// eutilsnew -out xxx -db pubmed -report medline 12633389
// DOPMC="$EU -v -out $eu_output -db pmc -report medline"
AccessTy pubmed(const StrTy & fn, const StrTy& id, const StrTy& db, const IdxTy flags)
{
AccessTy rc=0;
const StrTy cmd="eutilsnew -out \""+fn+"\" -v -db "+db+" -report medline "+id;
MM_ERR(MMPR2(__FUNCTION__,cmd))
Blob out,err,data;
IdxTy c=m_hand.fileio(out,err,data,cmd,3);
MM_ERR(MMPR(StrTy(err)));
MM_ERR(MMPR(StrTy(out)));
rc.url(cmd);
return rc;
} // pubmed



StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
AccessTy ChromateDownload(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{
AccessTy rc=0;
typedef typename Chromate::fetch_info Fi;
m_chromate.use_user(StrTy(),m_chromate_use_flags);
m_chromate.launch();
Remove(dest);
// the  operator does not ??? 
MM_ERR(__FUNCTION__<<MMPR2(dest,StrTy(url)))
MM_ERR(__FUNCTION__<<MMPR2(dest,(url)))
Fi fi=m_chromate.wget(dest,url,0);
// fi.doc has some json head and tail junk
if ((fi.error.length()!=0)) { 
MM_ERR(MMPR(fi.error))
rc=1; return rc; } 

return rc;
} // ChromateDownload

AccessTy ChromateGet(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{
AccessTy rc=0;
// print-to-pdf is default 
const bool dump_dom=Bit(flags,0);
// this requires relanuching the browser if it chances
// or at least a cookie clear 
const bool include_cookies=Bit(flags,1);
// should allow for friendly and emulated modes 
const bool include_profile=Bit(flags,2);
const bool exact=Bit(flags,3);
UrlTy rurl=url;
if (dump_dom) if (rurl.local()) 
{
MM_ERR(" local file bug should die now "<<MMPR2(dest,StrTy(url)))
//int * p=0; MM_ERR(*p)

Copy(dest,url);
rc=1;
return rc;
}
typedef typename Chromate::fetch_info Fi;
// eh this is async I'll bet doh 
m_chromate.use_user(StrTy(),m_chromate_use_flags);
m_chromate.launch();
Remove(dest);
Fi fi=dump_dom? m_chromate.fetch(url,0):m_chromate.print_page(dest,url,flags);
// fi.doc has some json head and tail junk
if ((fi.error.length()!=0)) {
MM_ERR(" getting DOM with chromate failed "<<MMPR3(fi.error,dest,StrTy(url)))
 rc=1; return rc; } 
if (dump_dom&&(fi.error.length()==0))
{
Blob b;
b=fi.doc;
b.save(dest);
}
// wtf???? 
WaitFile(dest);
//MM_ERR(MMPR(cmd))
//IdxTy c=m_hand.fileio(out,err,data,cmd,3);
//MM_ERR(MMPR(StrTy(err)));
//MM_ERR(MMPR(StrTy(out)));

return rc;
} // ChromateGet
AccessTy HeadlessGet(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{ 
// note print-to-pdf is default ... 
const bool dump_dom=Bit(flags,0);
// not implemented 
const bool include_cookies=Bit(flags,1);
const bool include_profile=Bit(flags,2);
// this is probably obsolete as chromate should be exact 

const bool if_not_exists=Bit(flags,4); // use stale version if there  
//MM_ERR(" MeGet  "<<MMPR4(dump_dom,include_cookies,include_profile,skip_personals)<<MMPR3(if_not_exists,url,dest))
if (if_not_exists) if (Exists(dest,0))
{
MM_ERR(" not getting as exists "<<MMPR2(dest,StrTy(url)))
return 0; 
}



const bool exact=Bit(flags,3);
//if (dump_dom&&!exact)
if (!exact)
{
return ChromateGet(dest,url,flags); 
}
AccessTy rc=0;
Blob out,err,data;
StrTy bro=m_bro; // "/opt/google/chrome/google-chrome";
StrTy cmd;
 // https://bugs.chromium.org/p/chromium/issues/detail?id=722431
 //  /opt/google/chrome/google-chrome --headless --disable-gpu --print-to-pdf="xxx.pdf" --user-data-dir="/home/marchywka/.config/google-chrome" "http://www.facebook.com"
/*
variants should be in srecord profile dir is usually Default and will download in exiting
// session if not headless. This is great if you can find the download file... 
 google-chrome-stable --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  "https://www.google.com"
 2289  google-chrome-stable ==headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  "https://www.google.com"
 2290  google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  "https://www.google.com"
 2294  google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  --dump-dom  "https://www.google.com"
 2295  google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  --dump-dom  "https://media-exp1.licdn.com/dms/image/C4D03AQFIHzdC0kjLkw/profile-displayphoto-shrink_100_100/0/1516862364008?e=1619654400&v=beta&t=IrUomCjJHtWtdXd8r7OV1WL7HmjJ58eG1WKYNTnyK1s"

// bmj very picky 
google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  --dump-dom  "https://heart.bmj.com/content/52/1/82"

*/
const StrTy base=" --headless  --disable-gpu --user-data-dir=\"/home/marchywka/.config/google-chrome/\" --profile-directory=\"Headless\" ";

if (dump_dom) cmd= bro+ base+" --dump-dom \""+StrTy(url)+"\" | tee \""+dest+"\"";  
else cmd= bro+ base+"\""+dest+"\" --print-to-pdf=\""+dest+"\" \""+StrTy(url)+"\"";  


//if (dump_dom) cmd= bro+ " --headless --dump-dom \""+url+"\" | tee \""+dest+"\"";  
//else cmd= bro+ " --headless --print-to-pdf=\""+dest+"\" \""+url+"\"";  


MM_ERR(MMPR(cmd))
IdxTy c=m_hand.fileio(out,err,data,cmd,3);
MM_ERR(MMPR(StrTy(err)));
MM_ERR(MMPR(StrTy(out)));

return rc;
} // HeadlessGet 
////////////////////////////////////////////////////////////////////
AccessTy MeGetOld(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{ 
const bool dump_dom=Bit(flags,0);
// ignored but for compat
const bool include_cookies=Bit(flags,1);
const bool include_profile=Bit(flags,2);
const bool skip_personals=Bit(flags,3); // 8 for possible page load issue 
const bool if_not_exists=Bit(flags,4); // use stale version if there  
MM_ERR(" MeGet  "<<MMPR4(dump_dom,include_cookies,include_profile,skip_personals)<<MMPR3(if_not_exists,url,dest))
if (if_not_exists)
if (Exists(dest,0))
{
MM_ERR(" not getting as exists "<<MMPR2(dest,url))
return 0; 
}
AccessTy rc=0;
Blob out,err,data;
StrTy bro=m_bro; // "/opt/google/chrome/google-chrome";
StrTy cmd;
 // https://bugs.chromium.org/p/chromium/issues/detail?id=722431
 //  /opt/google/chrome/google-chrome --headless --disable-gpu --print-to-pdf="xxx.pdf" --user-data-dir="/home/marchywka/.config/google-chrome" "http://www.facebook.com"
/*
variants should be in srecord profile dir is usually Default and will download in exiting
// session if not headless. This is great if you can find the download file... 
 google-chrome-stable --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  "https://www.google.com"
 2289  google-chrome-stable ==headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  "https://www.google.com"
 2290  google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  "https://www.google.com"
 2294  google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  --dump-dom  "https://www.google.com"
 2295  google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  --dump-dom  "https://media-exp1.licdn.com/dms/image/C4D03AQFIHzdC0kjLkw/profile-displayphoto-shrink_100_100/0/1516862364008?e=1619654400&v=beta&t=IrUomCjJHtWtdXd8r7OV1WL7HmjJ58eG1WKYNTnyK1s"

// bmj very picky 
google-chrome-stable --headless  --disable-gpu --user-data-dir="/home/marchywka/.config/google-chrome/" --profile-directory="Headless" --disable-plugins  --dump-dom  "https://heart.bmj.com/content/52/1/82"

*/


//MYBRO="google-chrome-stable --headless --disable-gpu --user-data-dir=\"/home/marchywka/.config/google-chromex/\" --profile-directory=\"Default\"  --disable-plugins  --dump-dom  "


//const StrTy base=" --headless  --disable-gpu --user-data-dir=\"/home/marchywka/.config/google-chrome/\" --profile-directory=\"Headless\" ";
//const StrTy base1="google-chrome-stable --headless --disable-gpu --user-data-dir=\"/home/marchywka/.config/google-chrome/\" --profile-directory=\"Default\"  --disable-plugins  "; 
const StrTy base1="google-chrome-stable --headless --disable-gpu --user-data-dir=/home/marchywka/.config/google-chrome/ --profile-directory=Default  --disable-plugins  "; 
const StrTy base2="google-chrome-stable --headless  --disable-plugins  "; 


const StrTy base=skip_personals?base2:base1; 
// TODO FIXME if the url points to a missing file, it seems to list the "/" dir DANGER WILLROBINSON 
//IdxTy LocalFileStatus(StrTy * furl, const StrTy & urlq, const IdxTy flags) const 
StrTy furl;
IdxTy local_code=LocalFileStatus(&furl,  url, 0); 
//return 1|(ex?2:0)|(sz?4:0)|(proto_file?8:0); 
if (local_code&1) if (!(local_code&4)||!(local_code&2))
{
MM_ERR(" the source url was determined to be a file that is not useful "<<MMPR2(url,local_code))
 return 2;
}
//if (dump_dom) cmd= base+" --dump-dom \""+url+"\" | tee \""+dest+"\"";  
// TODO FIXME this is getting called isntead of chromate.... 
if (dump_dom) { 
if (skip_personals) 
cmd="me -sbro \""+url  +"\"";  
else cmd="me -bro \""+url  +"\"";  


}           //  cmd= base+" --dump-dom \""+url+"\" | tee \""+dest+"\"";  
//else cmd=  base+dest+"\" --print-to-pdf=\""+dest+"\" \""+url+"\"";  
//else cmd=  base+"\" --print-to-pdf=\""+dest+"\" \""+url+"\"";  
else cmd=  base+" --print-to-pdf=\""+dest+"\" \""+url+"\"";  


//if (dump_dom) cmd= bro+ " --headless --dump-dom \""+url+"\" | tee \""+dest+"\"";  
//else cmd= bro+ " --headless --print-to-pdf=\""+dest+"\" \""+url+"\"";  


MM_ERR(MMPR(cmd))
//IdxTy c=m_hand.fileio(out,err,data,cmd,3);
// adding parens fcks it up fck 
IdxTy c=m_hand.fileio(out,err,data,cmd,4);
MM_ERR(MMPR(StrTy(err)));
if ( dump_dom) MM_ERR(MMPR(StrTy(out)));
if ( dump_dom) out.save(dest);
return rc;
} // MeGetOld 
//////////////////////////////////////////////////////////
AccessTy MeGet(const StrTy & dest, const UrlTy & url, const IdxTy flags)
{ 
const bool dump_dom=Bit(flags,0);
// ignored but for compat
const bool include_cookies=Bit(flags,1);
const bool include_profile=Bit(flags,2);
const bool skip_personals=Bit(flags,3); // 8 for possible page load issue 
const bool if_not_exists=Bit(flags,4); // use stale version if there  
MM_ERR(" MeGet "<<MMPR4(dump_dom,include_cookies,include_profile,skip_personals)<<MMPR3(if_not_exists,StrTy(url),dest))
if (if_not_exists)
if (Exists(dest,0))
{
MM_ERR(" not getting as exists "<<MMPR2(dest,StrTy(url)))
return 0; 
}
AccessTy rc=0;

// TODO FIXME if the url points to a missing file, it seems to list the "/" dir DANGER WILLROBINSON 
StrTy furl;
IdxTy local_code=LocalFileStatus(&furl,  StrTy(url), 0); 
//return 1|(ex?2:0)|(sz?4:0)|(proto_file?8:0); 
if (local_code&1) if (!(local_code&4)||!(local_code&2))
{
MM_ERR(" the source url was determined to be a file that is not useful "<<MMPR2(StrTy(url),local_code))
 return 2;
}
//if (dump_dom) cmd= base+" --dump-dom \""+url+"\" | tee \""+dest+"\"";  
// TODO FIXME this is getting called isntead of chromate.... 

typedef typename Chromate::fetch_info Fi;
// eh this is async I'll bet doh 
//m_chromate.use_user(skip_personals?"":"");
m_chromate.use_user(StrTy(),m_chromate_use_flags);
m_chromate.launch();
// the print may be asynchronous.. 
Fi fi=dump_dom? m_chromate.fetch(url,0):m_chromate.print_page(dest,url,flags);
Blob out;
out=fi.doc;
if ( dump_dom) MM_ERR(MMPR(StrTy(out)));
if ( dump_dom) out.save(dest);
return rc;
} // MeGet 



//  stat -c %s aaaa

IdxTy Size(const StrTy & fn, const IdxTy flags=0) const 
{
Blob out,err,data;
StrTy cmd=StrTy("stat -c %s \"")+fn+StrTy("\"");
IdxTy c=m_hand.fileio(out,err,data,cmd);
if (StrTy(err).length()!=0) { MM_ERR(MMPR3(c,cmd,StrTy(err))) } 
return atoi(StrTy(out).c_str());
} //Size 
/*
downloading a pdf file will open it with this html lol,

 StrTy(b)=<!DOCTYPE html><html><head></head><body style="height: 100%; width: 100%; overflow: hidden; margin:0px; background-color: rgb(38, 38, 38);"><embed name="443125E30422542C4FB3B334E1426AC2" style="position:absolute; left: 0; top: 0;" width="100%" height="100%" src="about:blank" type="application/pdf" internalid="443125E30422542C4FB3B334E1426AC2"></body></html>

*/
IdxTy EmbeddedEtc(const StrTy & fn, const IdxTy flags=0) const
{
IdxTy rc=0;
Blob out,err,data;
StrTy cmd=StrTy("( cat \"")+fn+StrTy("\" | grep application/pdf | grep \"about:blank\"  | grep internalid | grep \"<embed \") ");
IdxTy c=m_hand.fileio(out,err,data,cmd);
if (StrTy(err).length()!=0) {rc= ~0;  MM_ERR(MMPR3(c,cmd,StrTy(err))) } 
if (StrTy(out).length()!=0) {rc= 1;  MM_ERR(MMPR3(c,cmd,StrTy(out))) } 
const IdxTy fnsz=Size(fn,0);
if (fnsz>1000) {
if (rc!=0) {MM_MSG(" reseting Emvedded error flag on size"<<MMPR3(fn,rc,fnsz))}
rc=0; } 
return rc;
}

IdxTy Remove(const StrTy & fn, const IdxTy flags=0) const 
{
Blob out,err,data;
StrTy cmd=StrTy("rm \"")+fn+StrTy("\"");
IdxTy c=m_hand.fileio(out,err,data,cmd);
if (StrTy(err).length()!=0) { MM_ERR(MMPR3(c,cmd,StrTy(err))) } 
return atoi(StrTy(out).c_str());
} //Remove 

IdxTy Copy(const StrTy & d, const StrTy & s, const IdxTy flags=0) const 
{
Blob out,err,data;
StrTy cmd=StrTy("cp \"")+s+StrTy("\" \"")+d+"\"";
IdxTy c=m_hand.fileio(out,err,data,cmd);
if (StrTy(err).length()!=0) { MM_ERR(MMPR3(c,cmd,StrTy(err))) } 
return atoi(StrTy(out).c_str());
} //Remove 



IdxTy WaitFile(const StrTy & fn, const IdxTy flags=0) const 
{
IdxTy ntries=10;
while (Size(fn)==0)
{
if (ntries==0) return 1;
--ntries;
sleep(1);
} // while 

sleep(1);
return 0; 
} // WaitFile

bool Exists(const StrTy & fn, const IdxTy flags=0) const 
{
Blob out,err,data;
StrTy cmd=StrTy("stat ")+fn;
IdxTy c=m_hand.fileio(out,err,data,cmd);
//MM_ERR(MMPR3(c,cmd,StrTy(err)));
return (c==0);
} // Exists

AccessTy NormalGet(const StrTy & dest, const UrlTy & url, const IdxTy flags,const HdrMap & hdr_map)
{
return NormalWhatever(dest,url,flags,StrTy(),0, hdr_map);
}

AccessTy NormalPost(const StrTy & dest, const UrlTy & url, const StrTy & data, const IdxTy flags)
{ 
return NormalWhatever(dest,url,flags,data,1);
}

// headless can react badly to a missing local file... 
IdxTy LocalFileStatus(StrTy * furl, const UrlTy & urlq, const IdxTy flags) const 
{
typedef mjm_strings StrUtil;
StrTy lc=StrUtil::fancy_to_lower(urlq);
const char * lcp=lc.c_str();

// first see if the url is actually a file...
// don't bother with case sensivity now it will fall thought lol 
// really should also trim crap as using quotes a lot 
const bool proto=(0==strncmp("http://",lcp,7));
const bool proto2=(0==strncmp("https://",lcp,8));
const bool proto_file=(0==strncmp("file://",lcp,7));
const bool assume_local=!proto&&!proto2;
StrTy fnm=urlq;
if (!proto&&!proto2)
{
if (proto_file) fnm=StrTy(urlq.c_str()+7); 
if (furl) *furl=fnm;
//if (debug) { MM_ERR( " url seems to be a file "<<MMPR4(proto,proto2,url,furl)) } 

} // proto 
if (assume_local)
{
const bool ex=Exists(fnm,0);
const IdxTy sz=Size(fnm,0);
return 1|(ex?2:0)|(sz?4:0)|(proto_file?8:0); 
}
return 0;

} // LocalFileStatus

//flags|((1+2+8)
AccessTy NormalWhatever(const StrTy & dest, const UrlTy & url, const IdxTy flags, const StrTy & pdata, const IdxTy meflags, const HdrMap & hdr_map=HdrMap())
{ 
AccessTy rc=0;
rc.url(url);
const bool post=Bit(meflags,0); // NB MEflags

const bool bro_ua=!Bit(flags,0); // use a browser UA
const bool bro_acc=Bit(flags,1); // use a browser accept header 
const bool bib_acc=Bit(flags,2); // use a prefered  accept header 
const bool clear_cookies=Bit(flags,3); // clear cookies first 
const bool only_if_missing=Bit(flags,4); // only get if not exists 
const bool debug=Bit(flags,5); // clear cookies first 
const bool retry_on_error=!Bit(flags,6); // a server error try with new headers  
const bool admonish_idiot_webmaster=Bit(flags,7); // for problem sites if anyone cares to look lol  
const bool hdr_ua=Bit(flags,8); // use user-agent in hdr map  
const bool extra_chrome_headers=!Bit(flags,9); // use stuff that chrome added  
//const bool debug=Bit(flags,8); // dump more output 
const bool me_ua=Bit(flags,10); // use user-agent in hdr map  

const bool use_ua=bro_ua;
const bool use_acc=bro_acc||bib_acc;
MM_ERR(MMPR4(flags,use_ua,me_ua,bro_ua))
if (only_if_missing)
{
const bool exists=Exists(dest);
if (debug) {MM_ERR(" testing prior exist "<<MMPR2(dest,exists))}
 if (exists) return rc; 
}
const StrTy lc=mjm_strings::fancy_to_lower(StrTy(url));
// first see if the url is actually a file...
// don't bother with case sensivity now it will fall thought lol 
// really should also trim crap as using quotes a lot 
const bool proto=(0==strncmp("http://",lc.c_str(),7));
const bool proto2=(0==strncmp("https://",lc.c_str(),8));
const bool proto_file=(0==strncmp("file://",lc.c_str(),7));
const bool maybe_doi=(0==strncmp("10.",lc.c_str(),3));
if (!proto&&!proto2)
{
StrTy furl=url;
if (proto_file) furl=StrTy(url.c_str()+7); 
// TODO if this is a doi, wget tries to turn it into an IP address and
// hangs waiting to find 10.0.xxxx lol 
if (debug) { MM_ERR( " url seems to be a file "<<MMPR4(proto,proto2,StrTy(url),furl)) } 

if (Exists(furl)) 
{
Blob out,err,data;
StrTy cmd=StrTy("cp \"")+furl+"\" \""+dest+"\"";
IdxTy c=m_hand.fileio(out,err,data,cmd);
MM_ERR(MMPR2(cmd,StrTy(err)));
if (!Exists(dest))
{
MM_ERR(" failed attempt to copy file try as url "<<MMPR2(dest,StrTy(url)))
}
else return rc;
} // exists
// wget hangs with the wrong crap so return now...
MM_ERR(" return now since wget hangs with bad url "<<MMPR2(dest,StrTy(url))) 
return rc;
} // proto



////
if (clear_cookies)
{
Blob out,err,data;
StrTy cmd=StrTy("rm ")+m_cookie_file;
IdxTy c=m_hand.fileio(out,err,data,cmd);
MM_ERR(MMPR2(cmd,StrTy(err)));
}

Blob out,err,data;
//#rm crapcookie.txt
//echo if fails try removing   crapcookie | smsg
const StrTy cook=m_cook; 
const StrTy uahey=m_uahey; 
const StrTy acchey=m_acchey;
const StrTy accheyb=m_accheyb; 
StrTy  acc="";
if (bro_acc) acc=acchey;
if (bib_acc) acc=accheyb;

//WGET_BASE=" --no-use-server-timestamps $cook --no-check-certificate "
const StrTy opt2=" --no-use-server-timestamps --no-check-certificate ";

//$WGET $WGET_BASE  --user-agent="$uahey"  -q  -O "$fnxxx" "$urlxxx"

// verbose is always ok now 
StrTy cmd=m_cmd; // "wget -S -v  ";
cmd+=cook;
cmd+=opt2;
if ( use_ua&&!hdr_ua) cmd+=" --user-agent=\""+uahey+"\" ";
else if ( me_ua&&!hdr_ua) cmd+=" --user-agent=\""+m_me_ua+"\" ";

if ( hdr_ua)
{
StrTy hdr_map_ua="";
const auto ii =hdr_map.find("user-agent");
if (ii!=hdr_map.end()) hdr_map_ua=(*ii).second; 
if (hdr_map_ua!="")  cmd+=" --user-agent=\""+hdr_map_ua+"\" ";
}
if (use_acc) cmd+=" --header=\"Accept: "+acc+"\" ";
if (admonish_idiot_webmaster) cmd+=" --header=\"X-admonish-webmaster: I am trying to credit work on your cite by downloading citation information and your past web pages have been unfriendly. Mike Marchywka\"";
MM_LOOP(ii,hdr_map)
{
if ((*ii).first!="user-agent") 
cmd+=" --header=\""+(*ii).first+": "+(*ii).second+"\"";
} // ii 
const bool king_sht= extra_chrome_headers; // true;
if (king_sht)
{
HdrMap foup;
#if 0 
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/90.0.4430.212 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,* / *;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US

sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"
sec-ch-ua-mobile: ?0

#endif

foup["Connection"]= "keep-alive" ;
foup["Upgrade-Insecure-Requests"]="1";
foup["Sec-Fetch-Site"]="none";
foup["Sec-Fetch-Mode"]="navigate";
foup["Sec-Fetch-User"]="?1";
foup["Sec-Fetch-Dest"]="document";
// it is returning gzip lol 
//fckoup["Accept-Encoding"]="gzip, deflate, br";
foup["Accept-Language"]="en-US";
foup["sec-ch-ua"]="\\\" Not A;Brand\\\";v=\\\"99\\\", \\\"Chromium\\\";v=\\\"90\\\", \\\"Google Chrome\\\";v=\\\"90\\\"";
foup["sec-ch-ua-mobile"]="?0";
foup["Referer"]="https://www.google.com";

MM_LOOP(ii,foup)
{
cmd+=" --header=\""+(*ii).first+": "+(*ii).second+"\"";
} // ii 

} // king_sht


// TODO FIXME this may have issues with pathological data but so far so good
if (post) cmd+=" --post-data=\""+pdata+"\" ";
cmd+=" -O \""+dest+"\" \""+StrTy(url)+"\"";
//MM_ERR(MMPR(cmd))
IdxTy c=m_hand.fileio(out,err,data,cmd);
bool bad_resp=false;
{
Blob xout,xerr,xdata,yout,yerr;
xdata=StrTy(err);
// awk print $2 is the response code ... 
//StrTy xcmd=StrTy(" ( grep \"  HTTP\" | head -n 1 ) ");
StrTy xcmd=StrTy(" ( grep \"  HTTP\" | tail -n 1  ) ");
IdxTy xc=m_hand.fileio(xout,xerr,xdata,xcmd,1);
MM_ERR(MMPR3(xcmd,StrTy(xout),StrTy(xerr)));
//MM_MSG(MMPR3(xcmd,StrTy(xout),StrTy(xerr)));
//StrTy ycmd=StrTy(" ( awk '{print $2}'  ) ");
StrTy ycmd=StrTy(" (head -n 1 |  awk '{printf \"%s\", $2}'  ) ");
IdxTy yc=m_hand.fileio(yout,yerr,xout,ycmd,1);
const StrTy rcc=(StrTy(yout));
rc.server_response(rcc);
IdxTy respi=atoi(rcc.c_str());
bad_resp=(respi<200)||(respi>=400);
MM_ERR("response code "<< MMPR4(bad_resp,respi,StrTy(yout),StrTy(yerr)));

}

if (c|| debug ) {  // code 8 does seem to mean server error as per the docs, try again
MM_ERR(MMPR(StrTy(err)));
MM_ERR(MMPR(StrTy(out)));
MM_ERR(MMPR2(c,cmd))
}
if (c) {
//if ((retry_on_error) &&(c==8))
if ((retry_on_error) &&(bad_resp))
{
{
Blob out,err,data;
StrTy cmd=StrTy("rm ")+dest;
IdxTy c=m_hand.fileio(out,err,data,cmd);
MM_ERR(MMPR2(cmd,StrTy(err)));
}
//flags|((1+2+8)
const IdxTy newflag=flags|(1+2+8+32);
MM_ERR(" try again "<<MMPR4(c,StrTy(url),flags,newflag))
if (newflag!=flags)  { 
AccessTy rcretry=  NormalWhatever(dest, url, newflag, pdata, meflags);
IdxTy cnew=IdxTy(rcretry);
c=cnew;
}
} // retry_on_error 
} // c
else {MM_ERR( " wget returns ok "<<MMPR2(dest,StrTy(url))) } 
return rc; 
}
//IdxTy c=m_hand.fileio(dest,err,data,cmd);
void Init()
{
//m_chromate_creds=false;
m_chromate_use_flags=0;
m_cookie_file="crapcookie.txt";
m_cook=StrTy(" --load-cookies=")+m_cookie_file+StrTy(" --save-cookies=")
+m_cookie_file +StrTy(" --keep-session-cookies") ;


m_me_ua=" TooBib/Dev ; build "+StrTy(__DATE__)+StrTy(__TIME__)+   " mailto:marchywka@hotmail.com ; hardcoded developer version; see texhax or google marchywka toobib  "; 


//m_uahey="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36";
m_uahey="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36";
m_acchey="text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9";
m_accheyb="text/plain,text/bibtex,text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9";
//WGET_BASE=" --no-use-server-timestamps $cook --no-check-certificate "
m_opt2=" --no-use-server-timestamps --no-check-certificate ";
m_cmd="wget -S -v  ";
//m_bro="/opt/google/chrome/google-chrome";
m_bro="google-chrome-stable";
//$WGET $WGET_BASE  --user-agent="$uahey"  -q  -O "$fnxxx" "$urlxxx"
m_map["cookie_file"]= &Myt::m_cookie_file;
} // Init

typedef StrTy Myt:: * MemPtr;
typedef std::vector<StrTy>  Myt:: * MemVecPtr;
typedef std::map<StrTy, MemPtr> MemMap;
typedef std::map<StrTy, MemVecPtr> MemVecMap;

void Init(const Ragged & r)
{
const IdxTy sz=r.size();
for(IdxTy i=0; i<sz; ++i)
{
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
if (len<2) continue;
{auto ii=m_map.find(l[0]);
if (ii!=m_map.end()) { this->*((*ii).second)  = l[1]; continue; } 
}
{
auto ii=m_vec_map.find(l[0]);
if (ii!=m_vec_map.end()) { this->*((*ii).second).push_back(l[1]); continue; } 
}

} // i 

} // Init 
IdxTy Init(RaggedCursor & rc ) { 

const StrTy s4new=" sed -e 's/\\\\\\\"/mjm_bs_bug/g' | mjsonu.out -cmd \"sax-json - 1\"  | sed -e 's/mjm_bs_bug/\\\\\\\"/g'  ";
m_json_cmd=s4new;
return 0; 

} 
// MEMBERS
MemMap m_map;
MemVecMap m_vec_map;
mutable Hand m_hand;
mutable Chromate m_chromate;
//bool m_chromate_creds;
IdxTy m_chromate_use_flags;
Tdb m_config;
StrTy m_cookie_file;
StrTy m_cook,m_me_ua,m_uahey,m_acchey,m_accheyb, m_opt2;
StrTy m_cmd,m_bro;
StrTy m_json_cmd; 
}; // mjm_try_n_get

//////////////////////////////////////////////

template <class Tr>
class mjm_try_n_get_map : public std::map<typename Tr::StrTy, mjm_try_n_get< Tr > >  
{
 typedef mjm_try_n_get_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_try_n_get< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_try_n_get_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_try_n_get_map




////////////////////////////////////////////
#ifdef  TEST_MJM_TRY_N_GET
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_try_n_get <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_TRY_N_GET "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_try_n_get<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
const StrTy & p1=cip.p1;
const StrTy & p2=cip.p2;
const StrTy  p3=cip.wif(3);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="get") {x.normalget(p1,p2,atoi(p3.c_str()));  MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_TRY_N_GET_H__ 
