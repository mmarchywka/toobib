#ifndef MJM_HAS_BIBTEX_H__
#define MJM_HAS_BIBTEX_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_bibtex_entry.h"
#include "mjm_blob.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_strings.h"
#include "mjm_cpp_regex.h"
#include "mjm_hier_two.h"
#include "mjm_bibtex_fields.h"
#include "mjm_wovdb.h"
#include "mjm_ext_things.h"
#include "mjm_assemble_putative_bibtex.h"
#include "mjm_hierarchial_kvp.h"
#include "mjm_misc_parse.h"
#include "mjm_idiosyncratic_source_locator.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Feb 17 08:41:21 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_has_bibtex   
// g++  -Wall -std=gnu++11 -DTEST_MJM_HAS_BIBTEX -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_has_bibtex.h  -lpthread -lreadline

template <class Tr>
class mjm_has_bibtex 
{
 typedef mjm_has_bibtex Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_blob<Tr>  Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_ragged_cursor RaggedCursor;


typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibMap;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;
typedef mjm_bibtex_fields<Tr> Fields;

typedef mjm_assemble_putative_bibtex<Tr> Finisher;
typedef typename Finisher::return_code Frc;
typedef typename Finisher::assem_opt Ao;
typedef mjm_ext_things<Tr> Ext;

typedef mjm_var_parse<Tr> ParseTable;
typedef typename ParseTable::Iv Iv;


typedef mjm_hierarchial_kvp<Tr> HierKvp;
typedef mjm_hier_two<Tr> HierUtil;

typedef mjm_strings StrUtil;

typedef mjm_idiosyncratic_source_locator<Tr> IdioRL;

class _scan_result
{

public:
void add(const StrTy & s) { m_v.push_back(s); } 
std::vector<StrTy> m_v;

}; // _scan_result





public:
typedef _scan_result scan_result;
mjm_has_bibtex() {}
~mjm_has_bibtex() {}
//scan_result scan(const StrTy & fn, const IdxTy flags)
//{ return Scan(fn,flags); }
IdxTy  scan(scan_result & sr, const StrTy & fn, const IdxTy flags)
{ return Scan(sr,fn,flags); }


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

IdxTy  Scan(scan_result & sr, const StrTy & fn, const IdxTy flags)
{
Ragged r;
r.splitter(8);
r.load(fn,0);
 Scan(sr, r,flags);
return 0; 

}// Scan
IdxTy Scan(scan_result & sr, const Ragged & r, const IdxTy flags)
{
//scan_result sr;
//return sr;
RaggedCursor rc(r);
typedef std::vector<RaggedCursor> CurseVec;
CurseVec cv;
StrTy prior="";
//MM_ERR(MMPR2(r.size(),rc.dump()))
MM_ERR(MMPR(r.size()))
while (rc)
{
const Word & w=*rc;
if (w=="@")
{
MM_ERR(" have ampersand "<<MMPR(w))
cv.push_back(rc);
++rc;
if (!rc) break;
StrTy type="";
IdxTy q=GetType(type,rc,flags);
MM_ERR(MMPR2(type,type.length()))
if ((m_types.find(type)!=m_types.end())||((type.length()>2)&&(type.length()<100)))
{
MM_ERR(MMPR(type))
if (SkipWhite(rc)) {rc= cv.back(); cv.pop_back();prior=*rc;  ++rc; continue; } 
if (!rc) break;
if (*rc=="{")
{
MM_ERR(MMPR(type))
StrTy name;
IdxTy q=GetName(name,rc,flags);
MM_ERR(MMPR(name))
if (SkipWhite(rc)) {rc= cv.back(); cv.pop_back();prior=*rc;  ++rc; continue; } 
if (!rc) break;
if (*rc==",")
{
// This could be a spiur masking real one but ok for now.. 
GetResult(sr,cv.back(),rc,flags);
 cv.pop_back();prior=*rc;  ++rc; continue;  
} // good start 
} // left found
else {rc= cv.back(); cv.pop_back();prior=*rc;  ++rc; continue; } 
} // type reasonable 
} // ampersand 
prior=*rc;
++rc;
} // rc 
return 0; 
} // Scan 


IdxTy GetResult(scan_result & sr,RaggedCursor & cb,RaggedCursor &rc,const IdxTy flags)
{
Ss ss;
RaggedCursor c=cb;
int braces=0;
StrTy prior="";
IdxTy state=0;
bool esc=false;
bool quote=false;
while (c)
{
const Word &  w=(*c);
MM_ERR(MMPR4(esc,quote,braces,w))
if ( w=="\\") esc=!esc;
else if (w=="\"") quote=!quote;
else
{
if (!esc&&!quote) 
{
if (w=="{") ++braces;
else if (w=="}")
{
if (braces==1) { ss<<w<<CRLF; break; } // ==1

 --braces;
}
} // eq

esc=false;
} // else
ss<<w; // 
prior=w;
++c;
IdxTy nl=c.dline();
while  (nl){ --nl;  ss<<CRLF; }
} // c 
MM_ERR(ss.str());

sr.add(ss.str());
return 0;
} // GetResult 

IdxTy SkipWhite(  RaggedCursor & rc, const IdxTy flags=0)
{
IdxTy lines=0;
while (rc)
{
if (*rc==" ") { ++rc; }
else if (*rc=="\t") { ++rc; }
else break;
if (rc.dline()) ++lines;

} // rc
return lines; 
}
IdxTy GetType( StrTy & type, RaggedCursor & rc, const IdxTy flags)
{
const IdxTy mask= ParseTable::UC|ParseTable::LC|ParseTable::DIGIT; 
while(rc)
{
const Word & w=*rc;
MM_ERR(MMPR(w))
if (w=="{") return 0;
const Word lc=StrUtil::fancy_to_lower(w);
const unsigned char c=(unsigned char ) lc.c_str()[0];
const bool ok=m_clut.mask(c,mask);
if (!ok) if (c!='-') return 0;
//Iv val=m_clut.lut(c);

type+=lc;
++rc;
} // rc

return 0;
}
IdxTy GetName( StrTy & type, RaggedCursor & rc, const IdxTy flags)
{
const IdxTy mask= ParseTable::DARK; // UC|ParseTable::LC|ParseTable::DIGIT; 
while(rc)
{
const Word & w=*rc;
if (w==",") return 0;
const Word lc=StrUtil::fancy_to_lower(w);
//const unsigned char c=(unsigned char ) lc.c_str()[0];
//const bool ok=m_clut.mask(c,mask);
if (!mask)  return 0;

type+=lc;
++rc;
} // rc

return 0;
}




// MEMBERS
std::map<StrTy,IdxTy> m_types;
ParseTable m_clut;

}; // mjm_has_bibtex

//////////////////////////////////////////////

template <class Tr>
class mjm_has_bibtex_map : public std::map<typename Tr::StrTy, mjm_has_bibtex< Tr > >  
{
 typedef mjm_has_bibtex_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_has_bibtex< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_has_bibtex_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_has_bibtex_map




////////////////////////////////////////////
#ifdef  TEST_MJM_HAS_BIBTEX
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_has_bibtex <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_HAS_BIBTEX "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_has_bibtex<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
else if (cmd=="scan") { x.scan(cip.p1,0); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_HAS_BIBTEX_H__ 
