#ifndef MJM_WSCAT_BOT_H__
#define MJM_WSCAT_BOT_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#include <mjm_pawnoff.h>


// Tue Jan  4 07:47:10 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_wscat_bot   
// g++  -Wall -std=gnu++11 -DTEST_MJM_WSCAT_BOT -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_wscat_bot.h  -lpthread -lreadline

template <class Tr>
class mjm_wscat_bot 
{
 typedef mjm_wscat_bot Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_pawnoff<Tr> Hand;
// needs to use pawn def 
typedef mjm_blob<Tr> Blob;
typedef pthread_t ThreadId;

typedef std::ifstream FifoIn;
typedef std::ofstream FifoOut;

public:
mjm_wscat_bot() {Init();}
~mjm_wscat_bot() {Free();}
// originally designed solely for wscat with headless, allow ner things
void set_bro(const StrTy & cmd) { m_bro=cmd; } 
// these are gated out for now... 
FifoIn * in() { return m_ifs;}
FifoOut * out() { return m_ofs;}
// these should work... 
int infd() { return fdin;}
int outfd() { return fdout;}
bool inf_ok() const{ return fddin!=0; } 
FILE* infdd() { return fddin; }
FILE* outfdd() { return fddout; }
void done_output() { if (fdout!= ~0) close(fdout); fdout=~0;  } 
StrTy send_recv(const StrTy & cmd, const IdxTy flags) { return SR(cmd,flags); } 
StrTy send(const StrTy & cmd) { return SR(cmd,3); } 
StrTy  to_eof(const IdxTy flags) { return ToEof(flags); } 
StrTy  read(const IdxTy flags) { return drain(1,0,flags); } 
StrTy  drain(const IdxTy n, const IdxTy ns,const IdxTy flags)
{ return Drain(n,ns,flags); } 

void set_fifo(const StrTy & f1, const StrTy & f2) {  SetFifo( f1,  f2); } 

void kill() { Free(); } 
bool isalive() {  return IsAlive(m_pid); } 
IdxTy launch(const StrTy & url, const IdxTy flags=0 ) { return Launch(url,flags);}

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR4( m_pid, m_fifo1,m_fifo2, m_bro);
ss<<MMPR4(  m_url, m_thread, m_state,fdin);
ss<<MMPR(fdout);
return ss.str(); }
typedef mjm_thread_util<Tr> ThreadTy;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
bool IsAlive(const StrTy & pid)
{
const StrTy res=Exec(StrTy("(ps a | awk -v pid=")+pid+"  '{ if ($1 == pid ) print $0; }') ");
MM_ERR(MMPR(res))
return (res.length()!=0);
}

StrTy Exec(const StrTy & cmd) 
{
Blob dest,err,data;
// no trailing crtlf
const IdxTy rc=m_hand.fileio(dest,err,data,cmd,1);
MM_ERR(MMPR3(rc,StrTy(dest),StrTy(err)))
return StrTy(dest);
}
//m_mutex_vector = MutexVector(MU_SZ);
class tpclass
{
public:
Myt * p;
StrTy cmd;
}; // tpclass
static void * LaunchBro (void * p)
{
tpclass * tpc=(tpclass*) p;
Myt * pp=tpc->p; // (Myt*) p;
pp->Exec(tpc->cmd);
//Blob dest,err,data;
//pp->m_hand.fileio(dest,err,data,tpc->cmd);
//MM_ERR(MMPR2(StrTy(dest),StrTy(err)))
delete tpc;
return 0;
}
IdxTy Launch(const StrTy & url, const IdxTy flags ) 
{ 
// this dettached.. 
StrTy aval=m_pid;
if (aval.length())
{
MM_ERR(" not launching wscat  as already a listener "<<MMPR3(url,aval,aval.length()))
return ~0; 
}
m_url=url;
// cat /tmp/fifo1 | wscat -c ws://127.0.0.1:9222/foo | tee /tmp/fifo2 > /dev/null
// the blocking and eof behavior here is bizarre
StrTy pfx=StrTy("( echo $$ >> ")+m_fifo2+StrTy("  ; cat  ")+m_fifo1+" | " ;
StrTy cmd=pfx+m_bro+ url +"  2>&1 | tee -a "+m_fifo2+" >/dev/null ) " ;
MM_ERR(MMPR(cmd))
tpclass* ptpc = new tpclass();
tpclass & tpc=*ptpc;
tpc.p=this;
tpc.cmd=cmd;
auto tp=ThreadTy::launch(& Myt::LaunchBro,&tpc);
m_thread=tp;
m_state=1;
const bool do_files=false;
// if thread fails these hang... 
// these block waiting for other end... 
MM_ERR(" open fifos ")
if (do_files) {  m_ifs= new FifoIn(m_fifo2); } 
else {
fdin=open(m_fifo2.c_str(),O_RDONLY|O_NONBLOCK);
fddin=fdopen(fdin,"r");
}
//MM_ERR(" open output fifos ")
if (do_files) { MM_ERR(" don e init"<<MMPR2((*m_ifs).eof(),(*m_ifs).good()))
m_ofs= new FifoOut(m_fifo1); }
else
{ fdout=open(m_fifo1.c_str(),O_WRONLY);
fddout=fdopen(fdout,"a");}

//MM_ERR(" don e init"<<MMPR2((*m_ofs).eof(),(*m_ofs).good()))
MM_ERR(" don e init")
//mkfifo(m_fifo.c_str(),0777);
#if 1 
// need streams first... 
// if someone else has this open, it misses the pid... 
std::ifstream& ifs= *m_ifs; // (m_fifo2);
if (do_files) {
MM_ERR(MMPR3(m_pid,ifs.good(),ifs.eof()))
}
else MM_ERR(MMPR3(m_pid,fdin,fdout))
// DevTools listening on ws://127.0.0.1:9222/devtools/browser/4fa153b9-25fd-471f-aa37-73f2a5450262
//while(ifs.good())
if (do_files ){
while(true)
{
if ( ifs.eof()||!ifs.good())
{
MM_ERR(MMPR3(m_pid,ifs.good(),ifs.eof()))
if (0==m_pid.length())
{
sleep(1);
ifs.clear();
}
else break;
} // eof
// this is putting a cr or lf wtf
ifs>>m_pid;
// https://stackoverflow.com/questions/10178700/c-strip-non-ascii-characters-from-string
//m_pid.erase(remove_if(m_pid.begin(),m_pid.end(), __isascii), m_pid.end());  
m_pid=mjm_strings::trim_int(m_pid);
//MM_ERR(MMPR(xx))
if (m_pid.length())
{
MM_ERR(MMPR(m_pid))
return 0;
} //pid.len 
} // while  
} // do_files
else
{
char * line= new char[4096];
while (true)
{
long unsigned int sz=4094;
IdxTy copilewarn=getline(&line,&sz,fddin);
if (line[0]==0) { sleep(1); }
else { m_pid=line; 
// AUCK
m_pid=mjm_strings::trim_int(m_pid); 
MM_ERR(MMPR2(m_pid,strlen(line))); 
// shoudl wait for connect message too 
// this was crucial for the fetch programmatically after
// launch need something more robust though
sleep(2);
delete  line;  break; } 

} // true 

} // do_files
#endif
return 0;

} // Launch 
//////////////////////////////////////////////////
// baseline io copied from mjm_chromate.h
// send a line 
StrTy SR(const StrTy & cmd, const IdxTy flags)
{
const bool no_wait=Bit(flags,0);
const bool lf=Bit(flags,1);
//++m_id_cnt;
StrTy x;
FILE* otf=outfdd();
if (otf==0)
{
MM_ERR(" otf is null probably shutdown  and dynamic hazard lol ")
return StrTy();
}
MM_ERR(MMPR2(otf,cmd))
//MM_ERR(MMPR(Drain(0,0,0)))
MM_ERR("")
//StrTy carap=cmd+"\r";
StrTy carap=cmd+(lf?"\n":"\r");
fwrite(carap.c_str(),1,carap.length(),otf);
fflush(otf);
//(*otf)<<cmd<<"\n";
//(*otf).flush();
if (!no_wait) x=Drain(1,5,0);
MM_ERR(MMPR(cmd))
MM_ERR("")
MM_ERR(MMPR(x))

return x;
}

StrTy  ToEof(const IdxTy flags)
{
StrTy x;
FILE* inf=infdd();
MM_ERR(MMPR(inf))
if (inf==0)
{
// this happens during shutdown and leaks files... 
MM_ERR(" null file pointer "<<MMPR(inf))
return StrTy();
}
IdxTy lines=0;
IdxTy sleeps=0;
IdxTy pos=0;
const IdxTy sz=1<<20;
const IdxTy fszlim=sz-1;
char * line = new char[sz];
while (true)
{
int c=fgetc(inf);
if (c==EOF)break;
{
line[pos]=c;
++pos;
//MM_ERR(MMPR4(c,char(c),pos,x.length()))
if (pos==fszlim)
{
line[pos]=0;
x+=StrTy(line);
pos=0;
} // pos 
} // EOF 
} // while 
//sleep(1);
line[pos]=0;
x+=StrTy(line);

delete[] line;
return x;
} //wscato 


StrTy  Drain(const IdxTy n, const IdxTy ns,const IdxTy flags)
{
StrTy x;
FILE* inf=infdd();
MM_ERR(MMPR(inf))
if (inf==0)
{
// this happens during shutdown and leaks files... 
MM_ERR(" null file pointer "<<MMPR(inf))
return StrTy();
}
// this could still die though if inf is killed
/// try catch? ... 
long unsigned int fsz=1<<20;
long unsigned int fszlim=fsz-4;
char * line= new char[fsz];
IdxTy lines=0;
IdxTy sleeps=0;
IdxTy pos=0;

while (true)
{
int c=fgetc(inf);
if (c!=EOF)
{
line[pos]=c;
++pos;
//MM_ERR(MMPR4(c,char(c),pos,x.length()))
if (pos==fszlim)
{
line[pos]=0;
x+=StrTy(line);
pos=0;
} // pos 
if (c=='\r') ++lines;
else if (c=='\n') ++lines;
} // EOF 
else {
MM_ERR("EOF"<< MMPR3(x,lines,sleeps))
if (lines>=n)if ((ns==0)||(sleeps>0)) break;
if (sleeps>=ns) break;
sleep(1);
++sleeps;
continue;
}
//sleep(1);
} // while 
line[pos]=0;
x+=StrTy(line);

delete[] line;
return x;
} //wscato 




/////////////////////////////////////////////////
void SetFifo(const StrTy & f1, const StrTy & f2)
{
m_fifo1=f1; // "/tmp/fifo1";
m_fifo2=f2; // "/tmp/fifo2";
Exec(StrTy("mkfifo ") +m_fifo1);
Exec(StrTy("mkfifo ") +m_fifo2);
// these block waiting for other end... 

}

void Init()
{
Ss ss;
ss<<"wscat --connect ";
m_bro=ss.str();
m_ifs=0;
m_ofs=0;
m_state=0;
m_thread=0;
m_fifo1="/tmp/fifo1";
m_fifo2="/tmp/fifo2";
fdin=~0;
fdout=~0;
fddin=0;
fddout=0;
Exec(StrTy("mkfifo ") +m_fifo1);
Exec(StrTy("mkfifo ") +m_fifo2);
// these block waiting for other end... 
//MM_ERR(" open fifos ")
//m_ifs= new FifoIn(m_fifo2);
//MM_ERR(" open output fifos ")
//m_ofs= new FifoOut(m_fifo1);
//MM_ERR(" don e init")
//mkfifo(m_fifo.c_str(),0777);

} // Init
void Kill()
{
const StrTy pid=m_pid; // FindListener();
MM_ERR(" killing "<< MMPR2(pid.length(),pid))
if (pid.length())
{

Exec("kill "+pid);
} // pid 
m_hand.clean();
} // Kill 


void Free()
{
Kill();
delete m_ifs;
delete m_ofs;
m_ifs=0;
m_ofs=0;
if (fdout!= ~0) close(fdout);
MM_ERR(" omit drain which may be problem "<<MMPR2(__FUNCTION__,fdin))
//MM_ERR(MMPR(ToEof(0)))
if (fdin!= ~0) close(fdin);
if (m_state&&m_thread)
{
MM_ERR(" not killing thread should die  "<<MMPR2(m_state,m_thread))
// race condition?
//pthread_kill(m_thread,SIGTERM);
} // m_state
m_state=0;
m_hand.clean();
} // Free 

// MEMBERS
Hand m_hand;
StrTy m_pid;
StrTy m_fifo1,m_fifo2;
StrTy m_bro;
StrTy m_url;
ThreadId m_thread;
IdxTy m_state;
FifoIn *  m_ifs;
FifoOut *  m_ofs;
int fdin,fdout;
FILE * fddin,*fddout;
}; // mjm_wscat_bot

//////////////////////////////////////////////

template <class Tr>
class mjm_wscat_bot_map : public std::map<typename Tr::StrTy, mjm_wscat_bot< Tr > >  
{
 typedef mjm_wscat_bot_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_wscat_bot< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_wscat_bot_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_wscat_bot_map




////////////////////////////////////////////
#ifdef  TEST_MJM_WSCAT_BOT
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_wscat_bot <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_WSCAT_BOT "<<__DATE__<<" "<<__TIME__<<CRLF;
ss<<" MJM_WSCAT_BOT "<<"manipulate browser may use "<<CRLF;
ss<<" MJM_WSCAT_BOT "<<"wscat and rapidjson "<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_wscat_bot<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }
else if (cmd=="bro") { x.launch(cip.p1); }
//else if (cmd=="wait") {char * foo= readline("waiting"); delete foo; }
else if (cmd=="wait") {while (x.isalive()){{MM_ERR(MMPR(x.isalive()));} sleep(2); }  }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_WSCAT_BOT_H__ 
