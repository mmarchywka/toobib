#ifndef MJM_STRING_ARRAY_FORMATTER_H__
#define MJM_STRING_ARRAY_FORMATTER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_misc_parse.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun Jun  6 09:52:33 EDT 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_string_array_formatter   
// g++  -Wall -std=gnu++11 -DTEST_MJM_STRING_ARRAY_FORMATTER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_string_array_formatter.h  -lpthread -lreadline

template <class Tr>
class mjm_string_array_formatter 
{
 typedef mjm_string_array_formatter Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef mjm_var_parse<Tr> CharLUT;
typedef typename CharLUT::Iv Iv;
typedef char Ch;

//enum{ BAD=CharLUT::BAD};
// grep enum /home/documents/cpp/mjm/hlib//./mjm_misc_parse.h | sed -e 's/ /\n/g' | grep = | sed -e 's/=.*//' | sort | uniq  | awk '{x=x", "$1"=CharLUT::"$1}END{print x; }'
enum {  ALPHA=CharLUT::ALPHA, ALPHANUM=CharLUT::ALPHANUM, ASCII=CharLUT::ASCII, BAD=CharLUT::BAD, BITS=CharLUT::BITS, CARD=CharLUT::CARD, DIGIT=CharLUT::DIGIT,  PRINT=CharLUT::PRINT, SZC=CharLUT::SZC, SZTAB=CharLUT::SZTAB, TFLOAT=CharLUT::TFLOAT, TINT=CharLUT::TINT, TPUNC=CharLUT::TPUNC, UNUSED=CharLUT::UNUSED, UNUSEDB=CharLUT::UNUSEDB, VBITS=CharLUT::VBITS};

//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:


mjm_string_array_formatter() {Init(); }
~mjm_string_array_formatter() {}
template <class Tvec > StrTy format( Tvec & v) {Ss ss;  Format(ss,v); return ss.str(); }  
template <class Tvec > IdxTy format(Ss & ss, Tvec & v) {return Format(ss,v); }  
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
template <class Tvec > IdxTy Format(Ss & ss, Tvec & v) 
{
// return Format(ss,v); 
const StrTy sep=" ";
MM_SZ_LOOP(i,v,szv)
{
const StrTy & s=v[i];
if (i!=0) ss<<sep;
//MM_ERR(MMPR(s))
// this is dumb, if the json is wrong it will have something that
// can look like = or quote in the input string but
// we should fix that... 
if ( false) if (s=="=")
{
ss<<s; 
++i;
if (i<szv) ss<<sep<<v[i];
++i;
if (i!=szv ) {MM_ERR(" need one value only after eq "<<MMPR3(i,szv,s)) } 
break;
}
if (((i+1)>=szv)&&unescaped_value) ss<<s;
else ss<<FormatString(s);

} // ii 
return 0; 
}  // Format
StrTy  FormatString( const StrTy & s) const
{
const IdxTy n=s.length();
const Ch * p=s.c_str();
const IdxTy esz=ExpandString(0,p,n,0);
//IdxTy szb=5*n+10;
//Ch c[szb];
//MM_ERR(MMPR3(n,p,esz))
Ch c[esz];
const IdxTy asz=ExpandString(c,p,n,0);
if (asz!=esz) { MM_ERR(" overflow in string "<<MMPR3(asz,esz,s)) }
c[asz]=0;
/*
for(IdxTy i=0; i<n; ++i)
{
const Iv bits=m_lut.lut(p[i]);


} // i  
Ch c[szb];
IdxTy j=0;
for(IdxTy i=0; i<n; ++i)
{
const Iv bits=m_lut.lut(p[i]);
c[j]=p[i];
++j;
} // i  
c[j]=0;
*/

return StrTy(c);

}// FormatString
IdxTy ExpandString(Ch * c, const Ch * p, const IdxTy n, const IdxTy flags) const
{
IdxTy j=0;
for(IdxTy i=0; i<n; ++i)
{
const Ch cc=p[i];
const Iv bits=m_lut.lut(cc);
const bool hex=((bits&PRINT)==0)||(cc=='\r')||(cc=='\n');
const bool esc=false; // ((bits&ALPHANUM)==0);
if (hex) { SpecialChars(c,j,cc,0); }
else
{ 
	if (esc) {  if (c) c[j]='\\'; ++j; } 
	if (c) c[j]=cc; ++j;
}
} // i  
if (c) c[j]=0;
++j;

return j; 
} // ExpandString

IdxTy SpecialChars(Ch * c, IdxTy & j, const Ch cc, const IdxTy flags) const 
{
Ss ss;
ss<<"\\x";
//std::cout << std::setfill('0') << std::setw(5) << 25;
// great, it sign extends the signed char and lets field size
// explode lol. 
ss << std::setfill('0') << std::setw(2) <<std::hex
		<<(IdxTy(cc)&((sizeof(cc)<<8)-1));
const IdxTy sz=ss.str().length();
if (c==0){ j+=sz;  return sz; }
for(IdxTy i=0; i<sz; ++i)
{
c[j]=ss.str().c_str()[i];
++j;
}

return sz;
} // SpecialChars

void Init()
{

unescaped_value=false;
m_mode=0;
//m_esc_bit=
} // Init

// MEMBERS

bool unescaped_value;
CharLUT m_lut;
IdxTy m_esc_bit;
IdxTy m_mode;

}; // mjm_string_array_formatter

//////////////////////////////////////////////

template <class Tr>
class mjm_string_array_formatter_map : public std::map<typename Tr::StrTy, mjm_string_array_formatter< Tr > >  
{
 typedef mjm_string_array_formatter_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_string_array_formatter< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_string_array_formatter_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_string_array_formatter_map




////////////////////////////////////////////
#ifdef  TEST_MJM_STRING_ARRAY_FORMATTER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_string_array_formatter <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_STRING_ARRAY_FORMATTER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_string_array_formatter<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_STRING_ARRAY_FORMATTER_H__ 
