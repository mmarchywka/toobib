#ifndef MJM_HIERARCHIAL_KVP_H__
#define MJM_HIERARCHIAL_KVP_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Jun 10 15:50:53 EDT 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_hierarchial_kvp   
// g++  -Wall -std=gnu++11 -DTEST_MJM_HIERARCHIAL_KVP -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_hierarchial_kvp.h  -lpthread -lreadline

template <class Tr>
class mjm_hierarchial_kvp 
{
 typedef mjm_hierarchial_kvp Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
template <class Tgt> 
class serial_order_bi_index
{
// part of api need to expose
typedef IdxTy RcTy;
typedef IdxTy FwdTy;
typedef IdxTy RevTy;
typedef std::map<FwdTy,RevTy> Fmap;
typedef std::map<RevTy,FwdTy> Rmap;

public:
typedef Tgt * Tgtp;
typedef std::vector<Tgtp> Data;
enum { BAD=~0 } ;
~serial_order_bi_index() { Release(); } 
RcTy add(const FwdTy & f, const RevTy & r ) { return Add(f,r); } 
RevTy fwd(const FwdTy & f) { const auto ii=m_f.find(f);
if (ii==m_f.end()) return BAD; return (*ii).second; } 

FwdTy rev(const RevTy & r) { const auto ii=m_r.find(r);
if (ii==m_r.end()) return BAD; return (*ii).second; } 


// this is dumb, the object should have THE name of all entries
// as this name is used to call Tgt ctor wtf. 
Tgtp node(const StrTy & nm, const FwdTy & f) { return Node(nm,f); } 
Tgtp node( const FwdTy & f) { return Node(f); } 
Tgtp element( const IdxTy & f) { return Element(f); } 

IdxTy size() const { return m_v.size(); } 
void dump(Ss & ss, const IdxTy level)
{
IdxTy i=0;
MM_LOOP(ii,m_v)
{
ss<<" n= "<<rev(i)<<" ";
(*ii)->dump(ss,level+1);
++i;
}
} // dump2
void dump(const StrTy & pfx, Ss & ss, const IdxTy level)
{
IdxTy i=0;
MM_LOOP(ii,m_v)
{ Ss si;
si<<" "<<pfx<<" "<<i<<" ";
const StrTy pfxi=si.str();
//ss<<" n= "<<rev(i)<<" ";
(*ii)->dump(pfxi,ss,level+1);
++i;
}
} // dump3



private:
Tgtp Element( const IdxTy & i) { 
if (i>=m_v.size()) {   return 0; } 
return m_v[i];
} // Node 


Tgtp Node( const FwdTy & f) { 
auto ii=m_f.find(f);
if (ii==m_f.end()) {   return 0; } 
return m_v[(*ii).second];
} // Node 



Tgtp Node(const StrTy & nm, const FwdTy & f) { 
auto ii=m_f.find(f);
if (ii==m_f.end()) {  
	RcTy rca=add(f,m_v.size());
	Tgtp p= new Tgt(nm,f); 
	 m_v.push_back(p);
return p;
}
return m_v[(*ii).second];

} // Node 

RcTy Add(const FwdTy & f, const RevTy & r ) { 
const auto iif=m_f.find(f);
const auto iir=m_r.find(r);
const bool have_f=(iif!=m_f.end());
const bool have_r=(iir!=m_r.end());
if (!have_f&&!have_r) { m_f[f]=r; m_r[r]=f; return 0;  
} // have both 
if (have_f&&have_r) { 
const bool fwd_ok=(m_f[f]==r); 
const bool rev_ok=(m_r[r]==f); 
if (!fwd_ok||!rev_ok) {
RcTy rc=(fwd_ok?0:1) + ( rev_ok?0:2);
MM_ERR(" mismatch "<<MMPR4(f,r,m_f[f],m_r[r])<<MMPR(rc))
return rc;
}
return 0; 
}
if (have_f) { MM_ERR(" partial "<<MMPR3(f,r,m_f[f])) return 4;}
if (have_r) { MM_ERR(" partial "<<MMPR3(f,r,m_r[r])) return 8;}
MM_ERR(" logic error can not get here  "<<MMPR4(f,r,m_f[f],m_r[r]))
return 0; 

}  // Add
void Release() 
{
MM_LOOP(ii,m_v) { delete (*ii); } 
m_v.clear();
} // Release

Fmap m_f;
Rmap m_r;
// this is a vector of kvp_node pointers that all have the same name or key value. 
Data m_v;

}; // serial_order_bi_index


class kvp_node
{
typedef kvp_node Myt;
typedef serial_order_bi_index<Myt> SiBiIdx;
typedef std::map<StrTy, SiBiIdx> KidIdx;

public:
kvp_node() { m_name=""; m_level=0; have_value=false; }
kvp_node(const StrTy& nm, const IdxTy n) { m_name=nm; m_level=n; have_value=false; }
Myt * node(const StrTy& nm, const IdxTy n) { return Node(nm,n); }
void value(const StrTy & v) { m_value=v; have_value=true; } 
const StrTy & value() const { return m_value; }
// apparently not needed until now later 
const StrTy & name() const { return m_name; } 
const IdxTy level() const { return m_level; } 
void level(const IdxTy l )  {  m_level=l; } 
Myt * matching_value(const StrTy & val, const IdxTy flags)
{return MatchingValue(val,flags); } 
Myt * any_value( const IdxTy flags)
{return AnyValue(flags); } 
IdxTy size() const { return m_idx.size(); }
IdxTy size(const StrTy & nm) const { 
auto ii=m_idx.find(nm);
if (ii==m_idx.end()) return 0;

return (*ii).second.size(); 
}
template <class CandTy>
IdxTy find_candidates(CandTy & c, const StrTy &nm, const IdxTy flags )
{ return  FindCandidates( c, nm, flags ) ; } 
void dump(const StrTy & pfx,Ss & ss, const IdxTy level)
{
const StrTy sep=(pfx.length())?" ":"";
StrTy pfxv=pfx;
if (m_name!="") pfxv+=sep+m_name;
if (have_value) ss<<pfxv<<" = "<<m_value<<CRLF;
IdxTy i=0;
MM_LOOP(ii,m_idx)
{
// the i value is of no consequence... 
//Ss si; si<<" "<<pfxv<<" ["<<i<<"] ";
Ss si; 
if (m_name!="") si<<" "<<pfxv<<" ";
else si<<pfxv;
const StrTy pfxi=si.str();
//ss<<(*ii).first<<" ";
(*ii).second.dump(pfxi,ss,level+1);
++i;
}

} // dump3

void dump(Ss & ss, const IdxTy level)
{
ss<<Slevel(level)<<m_name;
if (have_value) ss<<" = "<<m_value<<CRLF;
// should be one or he oher. 
//else 
MM_LOOP(ii,m_idx)
{
ss<<(*ii).first<<" ";
(*ii).second.dump(ss,level+1);
}

} // dump 2
StrTy info(const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR4(m_name,m_level, m_value, have_value)<<MMPR(size());

return ss.str();
} // info 
template <class Tkvm > IdxTy kvp_map_get(Tkvm & m ) { return KvpMapGet(m); } 
private:


StrTy Slevel(const IdxTy l)
{
Ss ss;
ss<<"[ "<<l<<"[l]";
//IdxTy i=l; while (i) { ss<<" "; --i; } 
return ss.str();
}

Myt * Node(const StrTy& nm, const IdxTy n)
{
return m_idx[nm].node(nm,n);

}


template <class Tkvm > IdxTy KvpMapGet(Tkvm & m ) { 
IdxTy rc=0;
// may mess up the html getter, for json
if (have_value) { m[m_name]=m_value; } 

MM_LOOP(ii,m_idx)
{
const StrTy & name=(*ii).first;
SiBiIdx & si=(*ii).second;
StrTy v;
// should have only a single entry with a value but can concat multiples
const IdxTy sz=si.size();
// but it usually points to a text element need next in chain 

if (sz>1) rc|=1;
if (sz==0) rc|=2;

for(IdxTy i=0; i<sz; ++i)
{
Myt * p=si.element(i);
// hopefully just a dummy text element... 
if (!p->have_value)
{
if (p->size())
{
auto  ii = (*p).m_idx.begin();
const StrTy & nm=(*ii).first;
if (nm!="text") { MM_ERR( " digging "<<MMPR2(name,nm))  rc|=16; continue; } 
if( (*ii).second.size())
{
p=(*ii).second.element(0);
}
} // size
} // have_value
if (p->size()!=0) rc|=8;
if (!p->have_value) rc|=4;
else 
{
if (v=="") v=p->m_value;
else v=v+" , "+p->m_value;
} // have_value 
} /// i 
m[name]=v;
MM_ERR(MMPR2(name,v))
} // m_idx 
if (rc) MM_ERR( MMPR2(m.size(),rc))
return rc; 
}  // KvpMapGet
template <class CandTy>
IdxTy FindCandidates(CandTy & c, const StrTy &nm, const IdxTy flags )
{
const bool recurse=Bit(flags,0);
CandTy cnew;
auto ii=m_idx.find(nm);
if (ii!=m_idx.end())
{
SiBiIdx & si=(*ii).second;
const IdxTy sz=si.size();
//MM_MSG(" found something "<<MMPR2(nm,sz))

for(IdxTy i=0; i<sz; ++i) cnew.push_back(si.element(i)); 
} 
// now either return or recurse...
//MM_MSG(MMPR4(recurse,nm,m_idx.size(),cnew.size()))
if (recurse)
{ // this has to look at all the nodes... 
//MM_LOOP( jj,cnew)
MM_LOOP( jj,m_idx)
{
//MM_LOOP(kk, (*jj).second)
for(IdxTy kk=0; kk<(*jj).second.size(); ++kk)

{
(*jj).second.element(kk)->FindCandidates(c,nm,flags);
} // kk 

} // jj 
} // if
MM_LOOP(jj,cnew) { c.push_back(*jj); } 
return 0; 
} // FindCandidates 

Myt * MatchingValue(const StrTy & val, const IdxTy flags)
{
const bool recurse=Bit(flags,0);
const bool regex=Bit(flags,1);
if (regex) {MM_ERR(" not implement regex yet") } 
if (have_value) if (m_value==val) return this;
if (!recurse) return 0; 
MM_LOOP(ii,m_idx)
{
auto & v=(*ii).second;
for(IdxTy i=0; i<v.size(); ++i)
//MM_LOOP(jj,(*ii).second)
{
Myt * p= v.element(i)->MatchingValue(val,flags);
if (p) return p;
} // jj
} // ii
return 0; 
} // MatchingValue

Myt * AnyValue( const IdxTy flags)
{
const bool recurse=Bit(flags,0);
const bool regex=Bit(flags,1);
MM_ERR(" any value ... :"<<MMPR3(recurse,regex,flags))
if (regex) {MM_ERR(" not implement regex yet") } 
if (have_value) return this;
if (!recurse) return 0; 
MM_ERR(" recursing "<<MMPR(m_idx.size()))
MM_LOOP(ii,m_idx)
{
auto & v=(*ii).second;
MM_ERR(" recursing "<<MMPR2((*ii).first,v.size()))
for(IdxTy i=0; i<v.size(); ++i)
//MM_LOOP(jj,(*ii).second)
{
Myt * p= v.element(i)->AnyValue(flags);
MM_ERR(" recursing "<<MMPR3((*ii).first,i,p))
if (p) return p;
} // jj
} // ii
return 0; 
} // AnyValue




static bool Bit(const IdxTy f, const IdxTy b) { return (f&(1<<b))!=0; } 
StrTy m_name;
IdxTy m_level;
StrTy m_value;
bool have_value;
KidIdx m_idx;

}; // kvp_node
typedef kvp_node Nodes;
typedef std::map<StrTy,IdxTy> KeyLevelIndex;
typedef std::map<StrTy, StrTy> KvpMap;
typedef std::vector<KvpMap> KvpHits;
typedef std::vector<Nodes*> CandNodes;
public:

typedef KvpMap kvp_map_type;
typedef KvpHits kvp_lookup_type;
typedef std::vector<StrTy>  name_list_type;
typedef CandNodes candidate_nodes_type;
// for most content, a string tokenizer would be a hguge benefit
// but too easy to mess up now. As a comprmise, index the key
// fields which should have a limited number and are highly redundant.
// then, do exact string searches on the "DB". 
// integer searches would be much better eventually and there is a null
// tokenizer available... 
// actually will want to search on value too. 
mjm_hierarchial_kvp() {}
~mjm_hierarchial_kvp() {}
// a vector of number and names 
typedef std::vector<StrTy> V;
Nodes * root() { return &m_nodes; } 
const IdxTy size() const { return m_kidx.size(); } 
IdxTy add(const V & v, const StrTy & val)
{
const IdxTy sz=v.size();
Nodes * p=&m_nodes;
// ignore odd values 
const IdxTy szl=sz&(~1); 
const int off= -1;
IdxTy dep=0;
for(IdxTy i=0; i<(szl); i+=2)
{ 
int ix=sz-i-1;
const StrTy & nm=v[ix];
// 
++m_kidx[nm];
const IdxTy n =atoi(v[ix+off].c_str());
//p->level(i); // dumb here but ok I guess
p=p->node(nm,n);
++dep;
} // i 
p->level(dep); // dumb here but ok I guess
p->value(val);
return 0; 
} // add

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
CandNodes find(const name_list_type  & v, const IdxTy flags) { return Find(v,flags); } 
KvpHits lookup(const name_list_type & v, const IdxTy flags) { return Lookup(v,flags); } 
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; m_nodes.dump("",ss,0);   return ss.str(); }

CandNodes Find(const name_list_type & v, const IdxTy flags) { 
const bool recurse=Bit(flags,0);
const bool adjacent=Bit(flags,1);
IdxTy f2=flags;
CandNodes c;
c.push_back(&m_nodes);
// check each qualified descendent for the next entry 
MM_LOOP(ii,v)
{ 
//MM_MSG(" looking up "<<MMPR3(c.size(),(*ii),f2))
CandNodes cnew;
//MM_MSG(MMPR3((*ii),cnew.size(),c.size()))
// only recurses if bit 0 is set 
MM_LOOP(jj,c) { (*jj)->find_candidates(cnew,*ii,f2); }
c=cnew; 
if (adjacent) f2&=~1;
} // ii 

return c; 
} // Find 

#if 0
1 html 5 head 206 link 209 href 210 text = https://static-exp1.licdn.com/sc/h/7a4ujxvsdnd4s3x8tftdnnmt2
1 html 5 head 211 script 212 type 213 text = application/ld+json
//1 html 5 head 211 script 214 (null) =       {"@context":"http://schema.org","@graph":[{"@type":"Person","address":{"@ty

#endif

KvpHits Lookup(const name_list_type & v, const IdxTy flags) 
{ 
KvpHits kh;
CandNodes c=Find(v,flags);
//MM_MSG(MMPR(c.size()))
MM_LOOP(ii,c)
{
KvpMap m;
(*ii)->kvp_map_get(m);
kh.push_back(m);

}


return kh;
//return Lookup(v,flags); 

} 




typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// MEMBERS

Nodes m_nodes;
KeyLevelIndex m_kidx;

}; // mjm_hierarchial_kvp

//////////////////////////////////////////////

template <class Tr>
class mjm_hierarchial_kvp_map : public std::map<typename Tr::StrTy, mjm_hierarchial_kvp< Tr > >  
{
 typedef mjm_hierarchial_kvp_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_hierarchial_kvp< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_hierarchial_kvp_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_hierarchial_kvp_map




////////////////////////////////////////////
#ifdef  TEST_MJM_HIERARCHIAL_KVP
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_hierarchial_kvp <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_HIERARCHIAL_KVP "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_hierarchial_kvp<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_HIERARCHIAL_KVP_H__ 
