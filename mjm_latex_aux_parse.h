#ifndef MJM_LATEX_AUX_PARSE_H__
#define MJM_LATEX_AUX_PARSE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <map>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include "mjm_hier_two.h"
#include "mjm_bibtex_fields.h"
#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_cpp_regex.h"
#include "mjm_wovdb.h"
#include "mjm_blob.h"
#include "mjm_strings.h"
#include "mjm_collections.h"
#include "mjm_pawnoff.h"
#include "mjm_ext_things.h"

#include "mjm_assemble_putative_bibtex.h"
//#include "mjm_try_n_get.h"
#include "mjm_doi_scrape.h"
#include "mjm_scrape_xform.h"
#include "mjm_bibtex_entry.h"
#include "mjm_hierarchial_kvp.h"
//#include "mjm_bomtex_json.h"
//#include "mjm_jats_xml.h"
#include "mjm_wovdb.h"
#include "mjm_misc_parse.h"
#include "mjm_idiosyncratic_source_locator.h"


// Tue Feb 15 08:31:03 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_latex_aux_parse   
// g++  -Wall -std=gnu++11 -DTEST_MJM_LATEX_AUX_PARSE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_latex_aux_parse.h  -lpthread -lreadline

template <class Tr>
class mjm_latex_aux_parse 
{
 typedef mjm_latex_aux_parse Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_wovdb<Tr,StrTy> WovDB;
typedef typename WovDB::vector_type Vt;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_blob<Tr> Blob;
typedef mjm_pawnoff<Tr> Hand;

typedef mjm_assemble_putative_bibtex<Tr> Finisher;
typedef typename Finisher::return_code Frc;
typedef typename Finisher::assem_opt Ao;
typedef mjm_ext_things<Tr> Ext;

typedef mjm_var_parse<Tr> ParseTable;
typedef typename ParseTable::Iv Iv;

typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibMap;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;

typedef mjm_hierarchial_kvp<Tr> HierKvp;
typedef mjm_hier_two<Tr> HierUtil;

typedef mjm_strings StrUtil;

typedef mjm_idiosyncratic_source_locator<Tr> IdioRL;
typedef mjm_bibtex_fields<Tr> Fields;



#if 0 
class _aux_node
{
typedef _aux_node Myt;
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
public:
_aux_node() {Init(); }
~_aux_node() {Free(); }
StrTy dump(const IdxTy flags=0)
{
Ss ss;
ss<<MMPR(m_id);
if (m_name.length()) ss<<"\\"<<(m_name);
if (m_text.length()) ss<<(m_text);
if (m_kid) ss<<"{"<<(m_kid->dump(flags))<<"}";
if (m_next) ss<<(m_next->dump(flags));

return ss.str();
} // dump 

void Free()
{
delete m_next;
m_next=0;
delete m_kid;
m_kid=0;
} // Free
static IdxTy id() { static IdxTy id=0; ++id; return id; } 
void Init()
{
m_id=id();
m_next=0;
m_prior=0;
m_mom=0;
m_kid=0;
}// Init

IdxTy m_id;
StrTy m_name;
StrTy m_text;
Myt * m_next;
Myt * m_prior;

Myt * m_mom;
Myt * m_kid;


}; // _aux_node

#endif

class _aux_node
{
typedef _aux_node Myt;
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
public:
_aux_node() {Init(); }
_aux_node(Myt * p ) {Init(); m_mom=p; }
~_aux_node() {Free(); }

Myt * add_content(const StrTy & s) { return AddContent( s); } 
Myt * add_block() { return AddBlock(); } 
StrTy dump(const IdxTy flags=0)
{
Ss ss;
if (m_mom) ss<<MMPR2(m_id,m_mom->m_id);
else ss<<MMPR(m_id);
//if (m_kids.size()==0) ss<<m_content;
if (m_content.length()!=0) ss<<m_content;
else 
{
ss<<"{";
MM_LOOP(ii,m_kids) { ss<<(*ii)->dump(flags); } 
ss<<"}";
} 
//if (m_name.length()) ss<<"\\"<<(m_name);
//if (m_text.length()) ss<<(m_text);
//if (m_kid) ss<<"{"<<(m_kid->dump(flags))<<"}";
//if (m_next) ss<<(m_next->dump(flags));

return ss.str();
} // dump 
Myt * AddBlock() { 
m_kids.push_back(new Myt(this));
return m_kids.back(); } 

Myt * AddContent(const StrTy & s) 
{ 
if (s.length()==0) return this; // do nothing with blanks as it messes up things 
// the kids contains blocks and text strings. A new block has no text
// 
const bool new_always=true;
if ((m_kids.size()==0)|| new_always)
{
m_kids.push_back(new Myt(this));
m_kids.back()->m_content=s;
return this;
} 
Myt * p =m_kids.back();
if (p->m_content.length()!=0) 
{
p->m_content+=s; 
return this;
}
// the prior node is a block so now add a text node 
m_kids.push_back(new Myt(this));
m_kids.back()->m_content=s;
return this;


return this;
} 
void Free()
{
while ( m_kids.size()) { delete m_kids.back(); m_kids.pop_back(); } 
} // Free
static IdxTy id() { static IdxTy id=0; ++id; return id; } 
void Init()
{
m_id=id();
m_mom=0;
}// Init

IdxTy m_id;
StrTy m_content;

Myt * m_mom;

typedef std::vector<Myt * > Contents;
Contents m_kids;


}; // _aux_node


typedef _aux_node aux_node;
typedef aux_node A; 

// API 
public:
typedef std::vector<StrTy> find_vector_type;
mjm_latex_aux_parse() {Init();}
~mjm_latex_aux_parse() {Free(); }
IdxTy load(const StrTy & fn, const IdxTy flags) { return Load(fn,flags); } 
IdxTy top_cites(const StrTy & s, const IdxTy flags) { return TopCites(m_tree, s,flags); }
IdxTy bibcites(Ragged & r, const IdxTy flags)
{ return Find(r,m_tree,"bibcite",flags); } 
find_vector_type find(const StrTy & s, const IdxTy flags) { return Find(m_tree, s,flags); }

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; if (m_tree) ss<<(m_tree->dump());  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

//IdxTy bibtites(Ragged & r, const IdxTy flags)
//{ return Find(r,m_tree,"bibcite",flags); } 
//find_vector_type find(const StrTy & s, const IdxTy flags) { return Find(m_tree, s,flags); }
IdxTy Find(Ragged & r, A * p,const StrTy & s, const IdxTy flags)
{
const bool include_s=Bit(flags,0);
const auto & stack=p->m_kids;
MM_LOOP(ii,stack)
{
if ((*ii)->m_content==s)
{
Line l;
if (include_s) l.push_back(s);
++ii; // need to make sure this is ok ...
if (ii==stack.end()) break; 
const auto &  p1=(*ii)->m_kids;
Ss ss;
MM_LOOP(jj,p1)
{
// this part is really f-ing stupid wtf 
//l.push_back((*jj)->m_content);
ss<<((*jj)->m_content);

} // jj 
l.push_back(ss.str());
r.add(l); 
} // == s

} // ii 
MM_ERR(MMPR2(__FUNCTION__,r.size()))
return 0;
} // Find (Ragged) 

find_vector_type Find(A * p, const StrTy & s, const IdxTy flags)
{
find_vector_type fv;
const auto & stack=p->m_kids;
//MM_ERR(" checking "<<p->m_content)
MM_LOOP(ii,stack)
{
if ((*ii)->m_content==s)
{
StrTy x;
++ii; // need to make sure this is ok ...
if (ii==stack.end()) break; 
// next block is the thing.. 
const auto &  p1=(*ii)->m_kids;
MM_LOOP(jj,p1)
{
x+=(*jj)->m_content;
}
// MM_ERR((*ii)->dump());
MM_ERR(MMPR(x))
fv.push_back(x);
}
//TopCites((*ii),s,flags);
} // ii 

return fv; 
} // Find  


IdxTy TopCites(A * p, const StrTy & s, const IdxTy flags)
{
const auto & stack=p->m_kids;
//MM_ERR(" checking "<<p->m_content)
MM_LOOP(ii,stack)
{
if ((*ii)->m_content=="bibcite")
{
StrTy x;
++ii; // need to make sure this is ok ...
if (ii==stack.end()) break; 
// next block is the thing.. 
const auto &  p1=(*ii)->m_kids;
MM_LOOP(jj,p1)
{
x+=(*jj)->m_content;
}
// MM_ERR((*ii)->dump());
MM_ERR(MMPR(x))
}
//TopCites((*ii),s,flags);
} // ii 

return 0; 
} // TopCites


IdxTy TopCitesXXX(A * p, const StrTy & s, const IdxTy flags)
{
const auto & stack=p->m_kids;
//MM_ERR(" checking "<<p->m_content)
MM_LOOP(ii,stack)
{
if ((*ii)->m_content=="bibcite")
{
StrTy x;
const auto &  p1=(*ii)->m_mom->m_kids;
if (p1.size()) 
{
const auto & p2=p1; // p1.back()->m_kids;
MM_LOOP(jj,p2)
{
x+=(*jj)->m_content;

}
} // pq 
// MM_ERR((*ii)->dump());
MM_ERR(MMPR(x))
}
//TopCites((*ii),s,flags);
} // ii 

return 0; 
} // TopCites




IdxTy Load(const StrTy & fn, const IdxTy flags) 
{ 
IdxTy rc=0;
Ragged& r=m_r;
// use the char groups... 
r.splitter(8);
r.load(fn);
MM_ERR(MMPR2(fn,r.size()))
if (m_tree) delete m_tree;
m_tree= new A();
RaggedCursor curse(r);
A * p=m_tree;
Parse(p,curse,flags);
return rc;
} 
IdxTy Parse(A * p, RaggedCursor & curse, const IdxTy flags)
{
IdxTy rc=0;
while (curse)
{
if (curse.dline()) { p->add_content(CRLF) ; } //++curse; 
const StrTy & w=(*curse);
// the only text that matters is "{" and "}"
if ( w=="{")
{
++curse;
//if (curse.dline()) { p->add_content(CRLF) ; } //++curse; 
A * pnew= p->add_block();
Parse(pnew,curse,flags);
continue;
}
if ( w=="}")
{
++curse;
//if (curse.dline()) { p->add_content(CRLF) ; } //++curse; 
return 0; 
}

p->add_content(w);
++curse;
//if (curse.dline()) { p->add_content(CRLF) ; } //++curse; 
} // curse

return rc;
} // Parse

#if 0
// this should be moved into the node class.. 
IdxTy GetName(A * p, RaggedCursor & curse, const IdxTy flags)
{
while(curse)
{
if (curse.dline()) return 0;
const StrTy & w=(*curse);
if ( w=="@"){ p->m_name+=w; ++curse; continue; } 
if ( w==" "){ return 0 ; } 
// really anthing besides a char string... 
if ( w=="{"){ return 0 ; } 
if ( w=="\\"){ return 0 ; } 
if ( w=="}"){ return 0 ; } 

p->m_name+=w;
++curse;
} // curse
return 0;
} // GetName

IdxTy Parse(A * p, RaggedCursor & curse, const IdxTy flags)
{
MM_ERR(" enter zux parse")
IdxTy state=0; 
while (curse)
{
const StrTy & w=(*curse);
if (curse.dline()) { p->m_text+=CRLF; //++curse; 
// this throws out the word over the line doh 
//continue; 
} 
if (w=="\\")
{
if (p->m_name.length()) 
{
A* pnew= new A();
A* pp=p;
while (pp->m_next){ pp=pp->m_next; }
pp->m_next=pnew;
++curse;
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
if (curse) {GetName(pnew,curse,flags); } 
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
Parse(pnew,curse,flags);
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
} else { 
++curse;
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
//if (curse) {p->m_name=(*curse); } 
if (curse) {GetName(p,curse,flags); } 
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
}
}
//else if (w=="[") { }
else if (w=="{")
{
A* pnew= new A();
A* pp=p;
if (!pp->m_kid) { pp->m_kid=pnew; }
else {   pp=pp->m_kid; 
while (pp->m_next){ pp=pp->m_next; }
pp->m_next=pnew; }

++curse;
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
Parse(pnew,curse,flags);
if (curse) { if (*curse=="}") { ++curse ; MM_ERR(" exit up ") return 0; } }
}
else if (w=="}")
{

++curse;
MM_ERR(" exit zux parse")
return 0;

}
else {  p->m_text+=w; ++curse; } 
//p->m_next=pnew;
//p->m_kid=pnew;
//Parse(pnew,curse,flags);


//++curse;
} // curse

MM_ERR(" fini zux parse")
return 0;
} // Parse
#endif

void Free()
{
delete m_tree;
m_tree=0;

} // Free 
void Init()
{
m_tree=0;
} // Init 
// MEMBERS
StrTy m_fn;
Ragged m_r;
aux_node * m_tree;

}; // mjm_latex_aux_parse

//////////////////////////////////////////////

template <class Tr>
class mjm_latex_aux_parse_map : public std::map<typename Tr::StrTy, mjm_latex_aux_parse< Tr > >  
{
 typedef mjm_latex_aux_parse_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_latex_aux_parse< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_latex_aux_parse_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_latex_aux_parse_map




////////////////////////////////////////////
#ifdef  TEST_MJM_LATEX_AUX_PARSE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_latex_aux_parse <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_LATEX_AUX_PARSE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_latex_aux_parse<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") { x.load(cip.p1,0); }
else if (cmd=="cites") { x.top_cites(cip.p1,0); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_LATEX_AUX_PARSE_H__ 
