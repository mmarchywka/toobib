#ifndef MJM_SCRAPE_XFORM_H__
#define MJM_SCRAPE_XFORM_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_read_buffer.h"
#include "mjm_bibtex_entry.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

// caopy from mjm_scrape_xform 2021-01-05
// Mon Jan  4 13:43:47 EST 2021
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_scrape_xform   
// g++  -Wall -std=gnu++11 -DTEST_MJM_SCRAPE_XFORM -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_scrape_xform.h  -lpthread -lreadline

template <class Tr>
class mjm_scrape_xform 
{
 typedef mjm_scrape_xform Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;


typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_wovdb<Tr,StrTy> Tdb;
typedef mjm_wovdb<Tr,StrTy> WovDb;
typedef mjm_read_buffer<Tr> Rdbuf;

typedef std::map<StrTy, StrTy> XformMap;
typedef mjm_bibtex_entry<Tr> BibEntry;

class _ResultType
{
typedef _ResultType Myt;
public:
_ResultType() {Init(0); }
_ResultType(const IdxTy n) {Init(n); }
Myt & operator=(const IdxTy n ) { Init(n);  return *this; }
operator IdxTy() const { return 0; } 
private:

void Init(const IdxTy n) {}


}; // _Result_Type

typedef _ResultType ResultType;
typedef ResultType AccessTy;


/*
Scrape a file for anything that looks like a doi.
File could be text, html, pdf binary, rendered html,
pdf2text output, exif output, various structured formats.
Do not use various deefined methods or handlers yet. 

*/


public:
typedef AccessTy result_code;
mjm_scrape_xform() {Init();}
mjm_scrape_xform(const Ragged & r) {Init(r); }

StrTy dump(const IdxTy flags=0) { return Dump(flags); }



AccessTy any_to_exif(Blob & d, const StrTy & fn, const IdxTy flags)
{ return  FileToBlob( d,  fn,  "any_to_exif" ,  flags); } 

AccessTy pdf_to_text(Blob & d, const StrTy & fn, const IdxTy flags)
{ return  FileToBlob( d,  fn,  "pdf_to_text" ,  flags); } 

AccessTy pdf_to_text(const StrTy & d, const StrTy & fn, const IdxTy flags)
{ return  FileToFile( d,  fn,  "pdf_to_text" ,  flags); } 

AccessTy pdf_page(const StrTy & d, const StrTy & fn, const IdxTy page, const IdxTy flags)
{ return  PdfPage( d,  fn,  "pdf_page" ,page,  flags); } 



// silverchair download link 
AccessTy text_to_link( StrTy & d, const StrTy & fn,const StrTy cmd, const IdxTy flags)
{ return  FileToLine( d,  fn,  cmd ,  flags); } 


AccessTy html_to_rendered(Blob & d, const StrTy & fn, const IdxTy flags)
{ return  FileToBlob( d,  fn,  "html_to_rendered" ,  flags); } 
AccessTy html_to_rendered(const StrTy  & d, const StrTy & fn, const IdxTy flags)
{ return  FileToFile( d,  fn,  "html_to_rendered" ,  flags); } 

AccessTy html_to_parsed(Blob & d, const StrTy & fn, const IdxTy flags)
{ return  FileToBlob( d,  fn,  "html_to_parsed" ,  flags); } 
AccessTy html_to_parsed(const StrTy  & d, const StrTy & fn, const IdxTy flags)
{ return  FileToFile( d,  fn,  "html_to_parsed" ,  flags); } 

AccessTy html_to_parsed_hier(Blob & d, const StrTy & fn, const IdxTy flags)
{ return  FileToBlob( d,  fn,  "html_to_parsed_hier" ,  flags); } 
AccessTy html_to_parsed_hier(const StrTy  & d, const StrTy & fn, const IdxTy flags)
{ return  FileToFile( d,  fn,  "html_to_parsed_hier" ,  flags); } 


AccessTy json_to_kvp(Blob & d, const StrTy & fn, const IdxTy flags)
{ return  FileToBlob( d,  fn,  "json_to_kvp" ,  flags); } 

AccessTy json_to_kvp(const StrTy & d, const StrTy & fn, const IdxTy flags)
{ return  FileToFile( d,  fn,  "json_to_kvp" ,  flags); } 

/////////////// above, input formats; below bib formats 
// x-to-bib can go a lot of ways, to text or bibentry parsed...
// or dummy annotated k-v pairs 
// need ris first 
AccessTy ris_to_bib(BibEntry & d, const StrTy & fn, const IdxTy flags)
{ return  RisToBib( d,  fn,  flags); } 
AccessTy enw_to_bib(BibEntry & d, const StrTy & fn, const IdxTy flags)
{ return  EnwToBib( d,  fn,  flags); } 
AccessTy pmc_to_bib(BibEntry & d, const StrTy & fn, const IdxTy flags)
{ return  PmcToBib( d,  fn,  flags); } 




private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

IdxTy Cmd(StrTy & cmd, const StrTy & xform, const IdxTy flags)
{
auto ii=m_map.find(xform);
if (ii==m_map.end()) 
{
MM_ERR(" no xform for "<<MMPR3(xform,cmd,flags))
return ~0;
} 
 cmd=(*ii).second;
return 0;
} // Cmd
IdxTy Cmd2(StrTy & cmd, const StrTy & xform, const IdxTy flags)
{
auto ii=m_map_2.find(xform);
if (ii!=m_map_2.end()) { cmd+=(*ii).second; } 
return 0;
} // Cmd2


AccessTy FileToBlob(Blob & d, const StrTy & fn, const StrTy & xform,  const IdxTy flags)
{
AccessTy rc=0;
StrTy cmd;
if (Cmd(cmd,xform,flags)) return rc;
//cmd="cat \""+fn+"\" | "+cmd;
cmd=cmd+" "+fn;
Cmd2(cmd,xform,flags);
Blob data,err;
IdxTy c=m_hand.fileio(d,err,data,cmd);
MM_ERR(MMPR2(cmd,StrTy(d))<< MMPR4(c,StrTy(err),xform,fn))
return rc; 
}

AccessTy FileToLine(StrTy & d, const StrTy & fn, const StrTy & xform,  const IdxTy flags)
{
AccessTy rc=0;
StrTy cmd=xform;
//if (Cmd(cmd,xform,flags)) return rc;
cmd="cat \""+fn+"\" | "+cmd;
//cmd=cmd+" "+fn;
//Cmd2(cmd,xform,flags);
Blob dout,data,err;
IdxTy c=m_hand.fileio(dout,err,data,cmd,3);
MM_ERR(MMPR2(cmd,StrTy(d))<< MMPR4(c,StrTy(err),xform,fn))
d=StrTy(dout);
return rc; 
}



AccessTy FileToFile(const StrTy  & dfn, const StrTy & fn, const StrTy & xform,  const IdxTy flags)
{
AccessTy rc=0;
StrTy cmd;
if (Cmd(cmd,xform,flags)) return rc;
// hopefully ok with the fileio impl else write a new one 
//cmd="cat \""+fn+"\" | "+cmd+" > \""+dfn+"\"";;
cmd=cmd+" \""+fn+"\" \""+dfn+"\"";
//cmd=cmd+" "+fn;
Blob data,b,err;
IdxTy c=m_hand.fileio(data,err,b,cmd);
MM_ERR(MMPR4(c,StrTy(err),xform,fn))
MM_ERR(MMPR4(cmd,StrTy(b), StrTy(data),xform))
return rc; 
}

AccessTy PdfPage(const StrTy  & dfn, const StrTy & fn, const StrTy & xform, const IdxTy page,   const IdxTy flags)
{
AccessTy rc=0;
StrTy cmd;
Ss ss;
//ss<<xform;
//ss<<" -f "<<page<<" -l "<<page<<" "<<fn<<" "<<dfn;
//ss<<" -f "<<page<<" -l "<<page<<" "; // <<fn<<" "<<dfn;
//if (Cmd(cmd,ss.str(),flags)) return rc;
if (Cmd(cmd,xform,flags)) return rc;
// hopefully ok with the fileio impl else write a new one 
//cmd="cat \""+fn+"\" | "+cmd+" > \""+dfn+"\"";;
//cmd=cmd+" \""+fn+"\" \""+dfn+"\"";
ss<<cmd;
ss<<" -f "<<page<<" -l "<<page<<" \""<<fn<<"\" \""<<dfn<<"\"";
cmd=ss.str();
MM_ERR(MMPR("pdfsep cmd "<<MMPR(cmd)))
//cmd=cmd+" "+fn;
Blob data,b,err;
IdxTy c=m_hand.fileio(data,err,b,cmd);
MM_ERR(MMPR4(c,StrTy(err),xform,fn))
MM_ERR(MMPR4(cmd,StrTy(b), StrTy(data),xform))
return rc; 
}



StrTy Mutate(const StrTy & s, const StrTy & cmd)
{
StrTy d; 
const IdxTy rc=CmdExec(d,s,cmd,4);
return d;
} 
IdxTy CmdExec(StrTy & dest, const StrTy & s, const StrTy &cmd,  const IdxTy flags)
{
const bool always=true; // Bit(flags,0);
const bool file= Bit(flags,1);
const bool notrailingcrlf= Bit(flags,2); // 4 
const bool dfile= Bit(flags,3); /// 8
Blob d,err,cout;
StrTy _cmd;
if (file) { _cmd="cat \""+s+"\" |"+cmd; }
else { d=s; _cmd=cmd; }
IdxTy rc=m_hand.fileio(cout,err,d,_cmd,3);
if (always||(rc!=0)) { MM_ERR(MMPR3(dest,s,dfile)<< MMPR4(file,notrailingcrlf,flags,rc)<<MMPR4(cmd,StrTy(cout),StrTy(err),StrTy(d))) }
if (notrailingcrlf) {
IdxTy ncrlf= cout.no_trailing_crlf();
if (always) { MM_ERR(MMPR(ncrlf)) }
 }
if (!dfile) dest=StrTy(cout);
else { cout.save(dest); }
return rc;
}// cmd_exec





class _RisXlate {
public:
_RisXlate(): m_flags(0) {}
_RisXlate(const char * name, const char *  alt, const IdxTy flags)
:m_name(name),m_alt(alt),m_flags(flags) {}
_RisXlate(const char * name) :m_name(name),m_alt(),m_flags(1<<8) {}
_RisXlate(const StrTy & name) :m_name(name),m_alt(),m_flags(1<<8) {}


operator StrTy() const { return m_name; } 
const  StrTy&  alt() const { return m_alt; } 
const  StrTy&  name() const { return m_name; } 
bool non_key() const { return Bit(m_flags,0); } 
bool concat_multiple() const { return Bit(m_flags,1); } 
bool special() const { return Bit(m_flags,2); } 
bool discard() const { return Bit(m_flags,3); } 
bool placeholder() const { return Bit(m_flags,8); } 
StrTy m_name,m_alt;
IdxTy m_flags;

}; // RisXlate
typedef _RisXlate RisXlate;
typedef RisXlate Mty;
typedef std::map<StrTy, RisXlate> RisMap;
void  Rismap(RisMap& m ) const
{
// https://en.wikipedia.org/wiki/RIS_(file_format)
m["AB"]=Mty("abstract"," ",0);
m["AU"]=Mty("author"," and ",2);
m["A1"]=Mty("author"," and ",2);
m["A2"]=Mty("author"," and ",2);
m["A3"]=Mty("author"," and ",2);
m["A4"]=Mty("author"," and ",2);
m["DA"]=Mty("date"," ",0);
m["DO"]=Mty("doi"," ",0);
m["ER"]=Mty("end"," ",4+8);
m["EP"]=Mty("endpage"," ",4);
m["ID"]=Mty("name"," ",1);
m["IS"]=Mty("issue"," ",0);
m["JO"]=Mty("journal"," ",0);
// this could have more info... 
//m["PY"]=Mty("year"," ",0);
m["SN"]=Mty("serial"," ",0);
m["SP"]=Mty("pages"," ",4);
m["TI"]=Mty("title"," ",0);
m["T1"]=Mty("title"," ",0);
m["TY"]=Mty("type"," ",5);
m["UR"]=Mty("url"," ",0);
m["VL"]=Mty("volume"," ",0);
m["PMID"]=Mty("PMID"," ",0);
m["PMC"]=Mty("PMC"," ",0);
m["AUID"]=Mty("AUID"," ",0);
m["PHST"]=Mty("PHST"," ",0);
// fck 
//m["DP"]=Mty("year"," ",0);
m["UR"]=Mty("url"," ",0);
#if 0
else if ( $1=="PMID-") {f=one;}
else if ( $1=="AUID-") {f=one;}
else if ( $1=="PHST-") {f=one;}
else if ( substr($0,5,1)=="-") {f=one;}
# names may span multiple words but have comma sep between last and other 
# #if ( f=="AU" ) {fields=fields+1;$1=""; $2="";if (gsa=="") {gsa=$3} if ( au!="") {au=au" and ";} au=au""$3; $3=""; au=au","$0;};\
if ( f=="AU" ) {fields=fields+1;$1=""; $2="";if (gsa=="") {gsa=$3} if ( au!="") {au=au" and ";} au=au""$0;};\
if ( f=="A1" ) {fields=fields+1;$1=""; $2="";if (gsa=="") {gsa=$3} if ( au!="") {au=au" and ";} au=au""$0;};\
if ( f=="A4" ) {fields=fields+1;$1=""; $2="";if (gsa=="") {gsa=$3} if ( au!="") {au=au" and ";} au=au""$0;};\
if ( f=="PMC" ) {fields=fields+1;  pmc=$3;}
else if ( f=="PMID-" ) {fields=fields+1; pmid=$2;  }
#PY  - 1965/02/13/print
else if ( f=="PY" ) { fields=fields+1;gsb=substr($3,0,4); year=gsb;month=substr($3,5,2); day=substr($3,9,2); }
else if ( f=="DP" ) { fields=fields+1;gsb=$3; year=$3; }
else if ( f=="UR" ) { fields=fields+1;ur=$3; }
else if ( f=="TI" ) {if ( one=="TI") { fields=fields+1;}if ( title!="") title=title" ";  title=title""substr($0,7);if (gsc=="") {gsc=$3;}}
else if ( f=="T1" ) {if ( one=="T1") { fields=fields+1;}if ( title!="") title=title" ";  title=title""substr($0,6);if (gsc=="") {gsc=$3;}}
# these contain medline and nature ris terms
else if ( f=="JT" ) {fields=fields+1; jrnl=substr($0,7);}
else if ( f=="JO" ) {fields=fields+1; jrnl=substr($0,7);}
else if ( f=="JF" ) {fields=fields+1; jrnl=substr($0,7);}
else if ( f=="JA" ) {fields=fields+1; jrnl=substr($0,7);}
else if ( f=="PB" ) {fields=fields+1; publisher=substr($0,7);}
else if ( f=="VI" ) {fields=fields+1; vol=substr($0,7);}
else if ( f=="VL" ) {fields=fields+1; vol=substr($0,7);}
else if ( f=="PG" ) {fields=fields+1; pages=substr($0,7);}
else if ( f=="IP" ) {fields=fields+1; issue=substr($0,7);}
else if ( f=="IS" ) {fields=fields+1; issue=substr($0,7);}
else if ( f=="AB" ) {fields=fields+1; abs=substr($0,7);}
#endif

m["UR"]=Mty("url "," ",0);
m["JT"]=Mty("journal "," ",0);
m["JO"]=Mty("journal "," ",0);
m["JF"]=Mty("journal "," ",0);
m["JA"]=Mty("journal "," ",0);
m["PB"]=Mty("publisher "," ",0);
m["VI"]=Mty("voiume "," ",0);
m["VL"]=Mty("voiume "," ",0);
m["PG"]=Mty("pages "," ",0);
m["IS"]=Mty("issue "," ",0);
m["IP"]=Mty("issue "," ",0);
m["AB"]=Mty("abstract "," ",0);

}
#if 0
# enw is EndNote format 

#  <feff>%0 Journal Article
#  %T Targeting Mitochondria as Therapeutic Strategy for Metabolic Disorders
#  %J The Scientific World Journal
#  %V 2014
#  %A Sorriento, Daniela
#  %A Pascale, Antonietta Valeria
#  %A Finelli, Rosa
#  %A Carillo, Anna Lisa
#  %A Annunziata, Roberto
#  %A Trimarco, Bruno
#  %A Iaccarino, Guido
#  %R 10.1155/2014/604685
#  %D 2014
#  %U http://dx.doi.org/10.1155/2014/604685
#  %] 604685
#  %P 9

#endif

void  Enwmap(RisMap& m ) const
{
// m["A4"]=Mty("author"," and ",2);
//m["TY"]=Mty("type"," ",5);
MM_DIE(" enw not supported yet  no need has specal leaing char crap ")


}

#if 0
pmcroot="http://www.ncbi.nlm.nih.gov/pmc/articles/"
pubroot="http://www.ncbi.nlm.nih.gov/pubmed/articles/"
}\
{
one=$1;
if ( $2=="-") {f=one;}
# I really need to use a regex here wtf 
else if ( substr($0,5,1)=="-") {f=one;}
## else if ( $1=="...[^ ]-") {f=one;}
else if ( $1=="PMID-") {f=one;}
else if ( $1=="AUID-") {f=one;}
else if ( $1=="PHST-") {f=one;}
else if ( substr($0,5,1)=="-") {f=one;}
if ( f=="AU" ) {fields=fields+1;$1=""; $2=""; if ( au!="") {au=au" and ";} au=au""$3; $3=""; au=au","$0;};\
if ( f=="PMC" ) {fields=fields+1;  pmc=$3;}
else if ( f=="PMID-" ) {fields=fields+1; pmid=$2;  }
else if ( f=="DP" ) { fields=fields+1;year=$3; }
else if ( f=="DEP" ) {if (year=="") {  fields=fields+1;year=$3;}  }
else if ( f=="TI" ) {if ( one=="TI") { fields=fields+1;}if ( title!="") title=title" ";  title=title""substr($0,7);}
else if ( f=="AB" ) {if ( one=="AB") { fields=fields+1;}if ( abs!="") abs=abse" ";  abs=abs""substr($0,7);}
else if ( f=="JT" ) {fields=fields+1; jrnl=substr($0,7);}
else if ( f=="VI" ) {fields=fields+1; vol=substr($0,7);}
else if ( f=="PG" ) {fields=fields+1; pages=substr($0,7);}
else if ( f=="IP" ) {fields=fields+1; issue=substr($0,7);}
else{ }
if ( $2=="-") {lastf=one;}
}\
if (fields!=0){
if ( name == "" ) { if ( pmc!="" ) {name=pmc; namealt="PMID"pmid;} else if (pmid!="") name="PMID"pmid;}
tline="title={"title"}"
aline="author={"au"}"
cita="@article{"name",\n"tline",\n"aline;
b=""
if ( jrnl!="") {b=b",\njournal={"jrnl"}"; }
if ( vol!="") {b=b",\nvolume={"vol"}"; }
# should add abstract 
if ( issue!="") {b=b",\nnumber={"issue"}"; }
if ( pages!="") {b=b",\npages={"pages"}"; }
if ( year!="") {b=b",\nyear={"year"}"; }
if ( pmc!="") {b=b",\nurl={"pmcroot""pmc"/}"; }
else if ( pmid!="") {b=b",\nurl={"pubroot""pmid"/}"; }
cita=cita""b"\n}"
print cita;
if (namealt!="")
{
cita="@article{"namealt",\n"tline",\n"aline;
cita=cita""b;
cita=cita"\n}"
print cita;
} # namealt

// eutilsnew -out xxx -db pubmed -report medline 12633389
// DOPMC="$EU -v -out $eu_output -db pmc -report medline"

eutilsnew -out xxx -db pubmed -report medline 12633389
Count is 1 versus 1
marchywka@happy:/home/documents/cpp/proj/toobib$ cat xxx

PMID- 12633389
OWN - NLM
STAT- PubMed-not-MEDLINE
DCOM- 20030408
LR  - 20031104
IS  - 0031-9007 (Print)
IS  - 0031-9007 (Linking)
VI  - 90
IP  - 5
DP  - 2003 Feb 7
TI  - Low-temperature specific heat of the heavy-fermion superconductor PrOs4Sb12.
PG  - 057001
AB  - We report the magnetic field dependence of the specific-heat C of single crystals
      of the first Pr-based heavy-fermion superconductor Pr(Os4Sb12. The variation of C
      at low temperature and the magnetic phase diagram inferred from C, the
      resistivity and magnetization provide compelling evidence of a doublet ground
      state. Two distinct superconducting anomalies in C indicate an unconventional
      superconducting state, where the splitting may arise from a weak lifting of the
      ground state degeneracy. In combination this identifies Pr(Os4Sb12 as a strong
      contender for quadrupolar pairing, i.e., superconductivity that is neither
      electron-phonon nor magnetically mediated.
FAU - Vollmer, R
AU  - Vollmer R
AD  - Physikalisches Institut, Universitat Karlsruhe, Wolfgang-Gaede-Strasse 1,
      Germany.
FAU - Faisst, A
AU  - Faisst A
FAU - Pfleiderer, C
AU  - Pfleiderer C
FAU - V Lohneysen, H
AU  - V Lohneysen H
FAU - Bauer, E D
AU  - Bauer ED
FAU - Ho, P-C
AU  - Ho PC
FAU - Zapf, V
AU  - Zapf V
FAU - Maple, M B
AU  - Maple MB
LA  - eng
PT  - Journal Article
DEP - 20030205
PL  - United States
TA  - Phys Rev Lett
JT  - Physical review letters
JID - 0401141
EDAT- 2003/03/14 04:00
MHDA- 2003/03/14 04:01
CRDT- 2003/03/14 04:00
PHST- 2002/07/08 00:00 [received]
PHST- 2003/03/14 04:00 [pubmed]
PHST- 2003/03/14 04:01 [medline]
PHST- 2003/03/14 04:00 [entrez]
AID - 10.1103/PhysRevLett.90.057001 [doi]
PST - ppublish
SO  - Phys Rev Lett. 2003 Feb 7;90(5):057001. doi: 10.1103/PhysRevLett.90.057001. Epub 
      2003 Feb 5.


#endif


void  Pmcmap(RisMap& m ) const
{

m["AID"]=Mty("doi"," ",0);
m["LID"]=Mty("doi"," ",0);
m["AB"]=Mty("abstract"," ",0);
m["AD"]=Mty("address"," ",0);
m["FAU"]=Mty("altauthor"," and ",2);
m["AU"]=Mty("author"," and ",2);
m["A1"]=Mty("author"," and ",2);
m["A2"]=Mty("author"," and ",2);
m["A3"]=Mty("author"," and ",2);
m["A4"]=Mty("author"," and ",2);
m["DA"]=Mty("date"," ",0);
m["DEP"]=Mty("date"," ",0);
m["DO"]=Mty("doi"," ",0);
m["ER"]=Mty("end"," ",4+8);
m["EP"]=Mty("endpage"," ",4);
m["ID"]=Mty("name"," ",1);
m["IS"]=Mty("issue"," ",0);
m["JO"]=Mty("journal"," ",0);
// this could have more info 
//m["PY"]=Mty("year"," ",0);
m["SN"]=Mty("serial"," ",0);
m["SP"]=Mty("pages"," ",4);
m["TI"]=Mty("title"," ",0);
m["T1"]=Mty("title"," ",0);
m["TY"]=Mty("type"," ",5);
//m["PT"]=Mty("pubtype"," ",0);
m["UR"]=Mty("url"," ",0);
m["VL"]=Mty("volume"," ",0);
m["PMID"]=Mty("PMID"," ",0);
m["PMC"]=Mty("PMC"," ",0);
m["AUID"]=Mty("AUID"," ",0);
m["PHST"]=Mty("PHST"," , ",2);
// fck 
//m["DP"]=Mty("year"," ",0);
m["UR"]=Mty("url"," ",0);
m["UR"]=Mty("url"," ",0);
m["JT"]=Mty("journal"," ",0);
m["JO"]=Mty("journal"," ",0);
m["JF"]=Mty("journal"," ",0);
m["JA"]=Mty("journal"," ",0);
m["PB"]=Mty("publisher"," ",0);
m["VI"]=Mty("voiume"," ",0);
m["VL"]=Mty("voiume"," ",0);
m["PG"]=Mty("pages"," ",0);
m["IS"]=Mty("issue"," ",0);
m["IP"]=Mty("issue"," ",0);
m["AB"]=Mty("abstract"," ",0);


//MM_DIE(" pmc not supported yet  no need has specal leaing char crap ")

}


typedef std::map<StrTy, StrTy> Kv;

typedef IdxTy (Myt:: *FixFunc) ( Kv & kv, StrTy & name, StrTy & type, const Line & l, const Line & lw, const StrTy & val, const Mty & luv); 
IdxTy FixEnw( Kv & kv, StrTy& name, StrTy & type, const Line & l, const Line & lw, const StrTy & val, const Mty & luv)
{


const StrTy& key=luv.name();
if (luv.non_key())
{
if (key=="name") name=val;
else if (key=="type"){

if (val=="JOUR") type="article";
else type=val;
} // type 
}
else { if (luv.concat_multiple())
{
auto jj=kv.find(key);
if (jj!=kv.end()) kv[key]+=luv.alt()+val;
else  kv[key]=val;
}
else kv[key]=val;
}


return 0;
}
 IdxTy FixPmc( Kv & kv, StrTy& name, StrTy & type, const Line & l, const Line & lw, const StrTy & val, const Mty & luv)
{
const bool no_auto_keep=false;
// the comments with "@" are taken by bibtex as a start
// even with a leading "%" but these are usually email 
// addresses... 
// adding placeholder test may miss some however... 
if (luv.placeholder()&&!no_auto_keep) 
{ const StrTy k2=StrTy("%")+l[0]; kv[k2]=val;  } 

if((l[0]=="PY")||(l[0]=="DP"))
{
FixDateFu(kv,l,val,0);
/* const char * p=val.c_str();
const IdxTy len=val.length();
if (len>0) kv["year"]=StrTy(p,0,4);
if (len>5) kv["month"]= StrTy(p,5,2);
if (len>9) kv["day"]=StrTy(p,8,2);
*/
return 0 ; // continue;
}

const StrTy& key=luv.name();
if(key=="pages")
{
IdxTy l1=kv["pages"].length();
if (val==kv["pages"]) return 0;
if (l1!=0) kv["pages"]=val+"--"+kv["pages"];
else kv["pages"]=val;
return 0;
}
//endpage
if(key=="endpage")
{
if (val==kv["pages"]) return 0;
IdxTy l1=kv["pages"].length();
if (l1!=0) kv["pages"]=kv["pages"]+"--"+val;
else kv["pages"]=val;

return 0;
}
if (key=="doi")
{
// this needs to prserverse the type info 
//const StrTy x=Mutate(val,"sed -e 's/\\[.*//'");
const StrTy x=Mutate(val,"awk '{print $1}'");
const StrTy ty=Mutate(val,"awk '{print $2}'");
MM_ERR(" doi typing info "<<MMPR4(key,l[0],x,ty)<<MMPR(val))
StrTy & v=kv[key];
const IdxTy len=x.length();
if (len>5)
{
if (x.c_str()[0]=='1') 
if (x.c_str()[1]=='0') 
if (len>v.length()){    v=x; return 0; } 
}
//dont fall through this updates doi doh  let it fall through... 
return  0; 
}
if (l[0]=="SO")
{
// $ echo 1111 Now | grep "[0-9]\{4\} [A-Z][a-z][a-z]"
//| sed -e 's/.*\([0-9]\{4\}\)/\1/'
StrTy dscrape=Mutate(val,"grep -a  \"[0-9]\\{4\\} [A-Z][a-z][a-z]\"| sed -e 's/.*\\([0-9]\\{4\\} [A-Z][a-z][a-z][^a-z]\\)/\\1/'");
const char * p=dscrape.c_str();
const IdxTy len=dscrape.length();
if (len>0) if (kv.find("year")==kv.end())  kv["year"]=StrTy(p,0,4);
if (len>5) if (kv.find("month")==kv.end()) kv["month"]= StrTy(p,5,3);
//if (len>9) kv["day"]=StrTy(p,8,2);
return 0 ; // continue;

//return 0;
}
// PY handled above... 
if((key=="date") ||(l[0]=="PY"))
{// final assembly does this now and it is cleaner 
//MM_ERR(" date scraping left for final assembly")
const char * p=val.c_str();
const IdxTy len=val.length();
kv["date"]=val;
if (len>=4) kv["year"]=StrTy(p,0,4);
IdxTy yr=atoi(kv["year"].c_str());
if (yr==0) kv["year"]="";
if (yr != 0) if (len==10)
{
//if (len>0) kv["year"]=StrTy(p,0,4);
if (len>5) kv["month"]= StrTy(p,5,2);
if (len>9) kv["day"]=StrTy(p,8,2);
}
if (yr != 0) if (len==8)
{
//if (len>0) kv["year"]=StrTy(p,0,4);
kv["month"]= StrTy(p,4,2);
kv["day"]=StrTy(p,6,2);
}
IdxTy mo=atoi(kv["month"].c_str());
if ((mo==0)||(mo>12)) { kv["month"]=""; kv["day"]=""; }

return 0 ; // continue;
}
if (l[0]=="PMID")
{
if (name=="") name=StrTy("PMID")+val;
return 0; 
}
if (l[0]=="PMC")
{
//name=StrTy("PMC")+val;
name=val;
return 0; 
}

if (l[0]=="PT")
{
if (val=="Journal Article" )  type="article";
// PT is getting "Case Report " which is bad with the space.. 
//else 
//if (type=="") type=val;
kv["pubtype"]+=val+" ";
return 0; 
}

if (luv.non_key())
{
if (key=="name") name=val;
else if (key=="type"){

if (val=="JOUR") type="article";
else type=val;
} // type 
}
else { if (luv.concat_multiple())
{
auto jj=kv.find(key);
if (jj!=kv.end()) kv[key]+=luv.alt()+val;
else  kv[key]=val;
}
else { 
if (luv.placeholder()) {
// 2022-12-20 dropping multiple PT for example ... doh
//if (no_auto_keep) { const StrTy k2=StrTy("%")+key; kv[k2]=val;  } 
if (no_auto_keep) { const StrTy k2=StrTy("%")+key; kv[k2]+=val;  } 
}
// 2022-12-20 dropping multiple PT for example ... doh
//else kv[key]=val;
else kv[key]+=val;
}
}




return 0;
} // FixPmc 

IdxTy FixDateFu( Kv & kv,  const Line & l, const StrTy & val,const IdxTy flags)
{
const char * p=val.c_str();
const IdxTy len=val.length();
// crap 
std::vector<StrTy> nm;
nm.push_back("year");
nm.push_back("month");
nm.push_back("day");
IdxTy i=0;
IdxTy j=0; IdxTy k=0;
for(; i<len; ++i)
{
if (j>=nm.size()) break;
const char c=p[i];
if (c==' ')
{
kv[nm[j]]=StrTy(p,k,i-k);
k=i+1; ++j; // SHT FCK 
} //if 
} //i 

if (j<nm.size()) if (i>k) kv[nm[j]]=StrTy(p,k,i-k);

//if (len>0) kv["year"]=StrTy(p,0,4);
//if (len>5) kv["month"]= StrTy(p,5,2);
// for numeric values this should just pickup a zero 
//if (len==7) kv["month"]= StrTy(p,5,2);
//else if (len>7)  kv["month"]= StrTy(p,5,3);
//if (len>9) kv["day"]=StrTy(p,8,2);

return 0; // crap 
} // FixDateFu

IdxTy FixRis( Kv & kv, StrTy& name, StrTy & type, const Line & l, const Line & lw,  const StrTy & val, const Mty & luv)
{

//if(l[0]=="PY")
if((l[0]=="PY")||(l[0]=="DP"))
{
FixDateFu(kv,l,val,0);
#if 0 
const char * p=val.c_str();
const IdxTy len=val.length();
//crap 
for(IdxTy i=0; i<len; ++i)
{


}
if (len>0) kv["year"]=StrTy(p,0,4);
//if (len>5) kv["month"]= StrTy(p,5,2);
// for numeric values this should just pickup a zero 
if (len==7) kv["month"]= StrTy(p,5,2);
else if (len>7)  kv["month"]= StrTy(p,5,3);
if (len>9) kv["day"]=StrTy(p,8,2);
#endif


return 0 ; // continue;
}

const StrTy& key=luv.name();
if(key=="pages")
{
IdxTy l1=kv["pages"].length();
if (val==kv["pages"]) return 0;
if (l1!=0) kv["pages"]=val+"--"+kv["pages"];
else kv["pages"]=val;
return 0;
}
//endpage
if(key=="endpage")
{
if (val==kv["pages"]) return 0;
IdxTy l1=kv["pages"].length();
if (l1!=0) kv["pages"]=kv["pages"]+"--"+val;
else kv["pages"]=val;

return 0;
}

if(key=="date")
{
const char * p=val.c_str();
const IdxTy len=val.length();
if (len>0) kv["year"]=StrTy(p,0,4);
if (len>5) kv["month"]= StrTy(p,5,2);
if (len>9) kv["day"]=StrTy(p,8,2);
return 0 ; // continue;
}

if (luv.non_key())
{
if (key=="name") name=val;
else if (key=="type"){

if (val=="JOUR") type="article";
else type=val;
} // type 
}
else { if (luv.concat_multiple())
{
auto jj=kv.find(key);
if (jj!=kv.end()) kv[key]+=luv.alt()+val;
else  kv[key]=val;
}
else { 
// 2022-12-20 multiples 
//if (luv.placeholder()) {const StrTy k2=StrTy("%")+key; kv[k2]=val; }
if (luv.placeholder()) {const StrTy k2=StrTy("%")+key; kv[k2]+=val; }
else kv[key]+=val;
}
}


return 0; 
} 

AccessTy PmcToBib(BibEntry & d, const StrTy & fn, const IdxTy flags)
{ 
RisMap rm;
Pmcmap(rm);
AccessTy rc= LutToBib(d,fn,flags,rm,&Myt::FixPmc);
d.move("authors","altauthors",1);
d.move("author","altauthor",1);
return rc;
} // EnwToBib


AccessTy EnwToBib(BibEntry & d, const StrTy & fn, const IdxTy flags)
{ 
RisMap rm;
Enwmap(rm);
//return LutToBib(d,fn,flags,rm,FixEnw);
return LutToBib(d,fn,flags,rm,&Myt::FixEnw);

} // EnwToBib


AccessTy RisToBib(BibEntry & d, const StrTy & fn, const IdxTy flags)
{ 
RisMap rm;
Rismap(rm);
return LutToBib(d,fn,flags,rm,&Myt::FixRis);
}

// wtf? 2023-01-22
// PMID- 36356070
//OWN - NLM
//STAT- PubMed-not-MEDLINE

AccessTy LutToBib(BibEntry & d, const StrTy & fn, const IdxTy flags,
const RisMap & rm, FixFunc ff )
{
AccessTy rc=0;
Ragged r,w;
// tokenize based on char class transitions 
// this gets things like comma etc. 
// karger is putting non-ascii sht in the first 3 bytes wtf 
// just drop non-ascii sht for now 
//r.splitter(8);
r.splitter(7);
r.load(fn);
w.load(fn);
//RisMap rm;
//Rismap(rm);
WovDb  db;
IdxTy ln=0; 
StrTy type,name;
Kv kv;
MM_SZ_LOOP(i,r,sz)
{
++ln;
Line  l=r[i];
Line  lw=w[i];
{ Ss ss; MM_SZ_LOOP(jx,l,sz) { ss<<MMPR2(jx,l[jx])<<CRLF; }  MM_ERR(ss.str()); }
{ Ss ss; MM_SZ_LOOP(jx,lw,sz) { ss<<MMPR2(jx,lw[jx])<<CRLF; }  MM_ERR(ss.str()); }
const IdxTy len=l.size();
if (len<1) continue;
while (ln<sz)
{
const IdxTy szi1=r[i+1].size();
if (szi1==0) { ++i; ++ln; continue; } 
if (r[i+1][0]!="      ") break;
 ++ln;  ++i; 
//val+=r.sum(i,2,~0,""); 
// line break is equivalent to a space 
l.push_back(" ");
for(IdxTy j=1; j<r[i].size(); ++j) { l.push_back(r[i][j]); } 
lw.push_back(" ");
for(IdxTy j=1; j<w[i].size(); ++j) { lw.push_back(w[i][j]); } 
} // ln<sz

auto jj=rm.find(l[0]);
Mty luv=Mty(l[0]);
if (jj==rm.end())
{
MM_ERR( " unknown ris code "<<MMPR(r.sum(ln-1,0,~0)))
//continue;
} 
else luv=(*jj).second;
if (luv.discard()) continue; 


StrTy val; // =r.sum(i,4,~0,"");
const IdxTy ki=(l[0].size()>3)?3:4;
for(IdxTy k=ki; k<l.size(); ++k) val=val+l[k];

//IdxTy rcf= FixRis(  kv, name,type,  l,  val,  luv);
IdxTy rcf= (this->*ff)(  kv, name,type,  l, lw,  val,  luv);

#if 0
//( f=="PY" ) { fields=fields+1;gsb=substr($3,0,4); year=gsb;month=substr($3,5,2); day=substr($3,9,2); }
if(l[0]=="PY")
{
const char * p=val.c_str();
kv["year"]=StrTy(p,0,4);
kv["month"]= StrTy(p,5,2);
kv["day"]=StrTy(p,9,2);
continue;
}

const StrTy& key=luv.name();
if (luv.non_key())
{
if (key=="name") name=val;
else if (key=="type"){

if (val=="JOUR") type="article";
else type=val;
} // type 
}
else { if (luv.concat_multiple())
{
auto jj=kv.find(key);
if (jj!=kv.end()) kv[key]+=luv.alt()+val;
else  kv[key]=val;
}
else kv[key]=val;
}
#endif



} // ii 
d.name(name);
d.type(type);
d.add(kv);

#if 0
TY  - JOUR
AU  - Bongiovanni, Dario
AU  - Klug, Melissa
AU  - Lazareva, Olga
AU  - Weidlich, Simon
AU  - Biasi, Marina
AU  - Ursu, Simona
AU  - Warth, Sarah
AU  - Buske, Christian
AU  - Lukas, Marina
AU  - Spinner, Christoph D.
AU  - Scheidt, Moritz von
AU  - Condorelli, Gianluigi
AU  - Baumbach, Jan
AU  - Laugwitz, Karl-Ludwig
AU  - List, Markus
AU  - Bernlochner, Isabell
PY  - 2021
DA  - 2021/01/05
TI  - SARS-CoV-2 infection is associated with a pro-thrombotic platelet phenotype
JO  - Cell Death & Disease
SP  - 50
VL  - 12
IS  - 1
AB  - new compiler complains about crap in text FUCK 2025-08
SN  - 2041-4889
UR  - https://doi.org/10.1038/s41419-020-03333-9
DO  - 10.1038/s41419-020-03333-9
ID  - Bongiovanni2021
ER  - 

#endif



return rc;


}  // RisToBib

void Init(const Ragged & r)
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=0; i<sz; ++i)
{


} // i 

} // Init 


void Init() { 
m_map["any_to_exif"]= " exitutil -list "; 
//m_map["pdf_to_text"] = "pdftotext";
// 2023-01-04
m_map["pdf_to_text"] = "pdftotext -layout ";
m_map["pdf_page"] = "pdfseparate ";
m_map[ "html_to_rendered"]="lynx -width=10000 -dump -force_html "; 
// flags may be 8 or 0 wtf
m_map[ "html_to_parsed"]="testHTML --mjmflags 0 --mjm "; 
// TODO FIXME this still uses the command line utility but
// theheader is now integated... doh 
m_map[ "html_to_parsed_hier"]="testHTML --mjmflags hier --mjm "; 
//m_map[ "html_to_parsed"]="testHTML --mjmflags 8 --mjm "; 
m_map[ "json_to_kvp"]="mjsonu -cmd sax-json ";
m_map_2[ "json_to_kvp"]=" export -quit ";
//$MJSONU -cmd "sax-json $fntemp export" -quit 
} // Init
// MEMBERS


Hand m_hand;
Tdb m_config;
XformMap m_map;
XformMap m_map_2;
//StrTy m_hdoi,m_tdoi,m_mdoi,m_udoi;
//StrTy m_doised2;

}; // mjm_scrape_xform

//////////////////////////////////////////////

template <class Tr>
class mjm_scrape_xform_map : public std::map<typename Tr::StrTy, mjm_scrape_xform< Tr > >  
{
 typedef mjm_scrape_xform_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_scrape_xform< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_scrape_xform_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_scrape_xform_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SCRAPE_XFORM
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_scrape_xform <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SCRAPE_XFORM "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_scrape_xform<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SCRAPE_XFORM_H__ 
